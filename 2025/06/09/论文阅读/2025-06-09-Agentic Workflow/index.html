<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Agentic Workflow | ZJN_BLOG</title><meta name="keywords" content="论文阅读"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Agentic WorkflowToward Super Agent System with Hybrid AI RoutersMotivation早期的模型部署技术在应对高并发请求时表现不佳，效率问题凸显。这需要解决包括模型选择、任务分配、系统容错等在内的一系列复杂的技术挑战。  当系统接到某项任务时，需要智能地判断是交给某个 Agent 单独完成，还是交给多个 Agent 共同协同工作。 提升">
<meta property="og:type" content="article">
<meta property="og:title" content="Agentic Workflow">
<meta property="og:url" content="http://zjn-astonishe.github.io/2025/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-09-Agentic%20Workflow/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="Agentic WorkflowToward Super Agent System with Hybrid AI RoutersMotivation早期的模型部署技术在应对高并发请求时表现不佳，效率问题凸显。这需要解决包括模型选择、任务分配、系统容错等在内的一系列复杂的技术挑战。  当系统接到某项任务时，需要智能地判断是交给某个 Agent 单独完成，还是交给多个 Agent 共同协同工作。 提升">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2025-06-09T06:24:58.000Z">
<meta property="article:modified_time" content="2025-06-12T02:16:58.071Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2025/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-09-Agentic%20Workflow/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Agentic Workflow',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-12 10:16:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Agentic Workflow</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-09T06:24:58.000Z" title="发表于 2025-06-09 14:24:58">2025-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-12T02:16:58.071Z" title="更新于 2025-06-12 10:16:58">2025-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Agentic-Workflow"><a href="#Agentic-Workflow" class="headerlink" title="Agentic Workflow"></a>Agentic Workflow</h1><h2 id="Toward-Super-Agent-System-with-Hybrid-AI-Routers"><a href="#Toward-Super-Agent-System-with-Hybrid-AI-Routers" class="headerlink" title="Toward Super Agent System with Hybrid AI Routers"></a>Toward Super Agent System with Hybrid AI Routers</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>早期的模型部署技术在应对高并发请求时表现不佳，效率问题凸显。这需要解决包括模型选择、任务分配、系统容错等在内的一系列复杂的技术挑战。</p>
<ul>
<li>当系统接到某项任务时，需要智能地判断是交给某个 Agent 单独完成，还是交给多个 Agent 共同协同工作。</li>
<li>提升效率的关键：选“对的”模型，比选“大”模型更重要</li>
<li>用户的一条简单提示背后，不再是单一模型生成应答，而是一整套智能体系统在幕后完成复杂的任务分解、协作和执行流程。</li>
</ul>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>本质是一个”Prompt-to-Model”的分类系统。<br>通过谷歌的 BERT 等语义理解模型和监督学习方法，通过分析任务需求，动态选择最适合的专家模型对相关请求进行处理。<br><img src="" alt="Overview of the Super Agent System"><br><img src="" alt="Router 系统对路由器数据准备、路由器模型训练和部署流程的概述"></p>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p>考虑到真实高并发场景（如每秒数万次请求）下单点故障的情况，研究人员设计了一种冗余机制：当某次请求失败时，系统可自动切换到备用结点重新发起请求，以保障系统的持续正常运行。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>TensorOpera 与高通合作，成功将 Router 部署在高通显卡上，显著提升了能效比和性价比。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="意图路由和自动规划-Intent-Router-Planner"><a href="#意图路由和自动规划-Intent-Router-Planner" class="headerlink" title="意图路由和自动规划(Intent Router + Planner)"></a>意图路由和自动规划(Intent Router + Planner)</h4><p>用户只需要输入自然语言请求，系统会自动识别其意图并路由到合适的任务Agent。<br>系统还能自动生成多 Agent 协作的执行计划。</p>
<ul>
<li>以用户需要写一篇关于不稳定关税交易策略的文章为例，该系统会自动规划并协调三个 Agent 构成完整的流程，它们分别负责：查找实时关税信息、设计金融策略，以及实现 C++ 代码。</li>
<li>现阶段研究人员正在尝试更大规模的 Agent 协作，尝试让 1000 个 Agent 进行协作和交流，共同完成盖房子等更复杂的任务。</li>
</ul>
<p><img src="" alt="通过函数调用对用户意图进行分类"><br><img src="" alt="自动智能体工作流计划"></p>
<h4 id="任务专用智能体-Task-Agents"><a href="#任务专用智能体-Task-Agents" class="headerlink" title="任务专用智能体(Task Agents)"></a>任务专用智能体(Task Agents)</h4><p>用专业的Agent专注完成特定的任务。<br>每个 Task Agent 都是一个“任务专家”，集成了记忆（Memory）、工具使用能力（Tool Use）与检索增强生成能力（RAG，Retrieval-Augmented Generation）。</p>
<ul>
<li>可调用数据库、执行 API 操作，甚至与物理世界进行交互，从而实现从数字到物理的复杂任务自动化。</li>
</ul>
<p><img src="" alt="Task Agent"></p>
<h4 id="智能模型选择系统-Model-Router"><a href="#智能模型选择系统-Model-Router" class="headerlink" title="智能模型选择系统(Model Router)"></a>智能模型选择系统(Model Router)</h4><p>不同厂商的模型在架构、参数规模和优化目标上存在差异。需要路由选择当前任务的“最优解”模型。因此该模块为核心模块。</p>
<ul>
<li>综合考虑指标为: 准确率、响应速度、成本。</li>
</ul>
<p><img src="" alt="具有成本优化配置的模型路由器"></p>
<h4 id="端云混合部署"><a href="#端云混合部署" class="headerlink" title="端云混合部署"></a>端云混合部署</h4><p>并非传统的单体架构，而是采用模块化、插件化的设计理念，为不同场景需求提供灵活可配置的解决方案。</p>
<ul>
<li>开发者只需定义任务意图与流程规划，系统可自动分配 Agent 执行。</li>
<li>可根据实际场景灵活部署在本地、边缘或云端。</li>
<li>具备极强的“系统演化能力”，可随着模型更新动态替换，进而具备持续进化的能力。</li>
</ul>
<h2 id="AFlow-Automating-Agentic-Workflow-Generation"><a href="#AFlow-Automating-Agentic-Workflow-Generation" class="headerlink" title="AFlow: Automating Agentic Workflow Generation"></a>AFlow: Automating Agentic Workflow Generation</h2><h3 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h3><p>大型语言模型（LLMs）在解决多样化的复杂任务方面表现出色，但设计和优化其工作流需要<strong>大量人力</strong>，限制了可扩展性和跨任务技能迁移。</p>
<h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>AFLOW框架基于蒙特卡洛树搜索（MCTS），旨在自动生成和优化代理工作流。</p>
<ul>
<li>将工作流优化问题进行了形式化定义，工作流建模为由代码连接的结点和边，表示操作间的逻辑、依赖关系和流程，形成一个庞大的搜索空间。/</li>
<li>使用预定义的操作符作为构建块，并结合多种创新技术（如软混合概率选择、LLM驱动的结点扩展、执行评估和经验反向传播）来高效探索这一空间，自动创建优化的工作流，以最大化任务性能并减少人工干预。</li>
</ul>
<h3 id="智能工作流-Agentic-Workflow"><a href="#智能工作流-Agentic-Workflow" class="headerlink" title="智能工作流(Agentic Workflow)"></a>智能工作流(Agentic Workflow)</h3><p><img src="" alt="工作流组成"></p>
<h4 id="结点-Node"><a href="#结点-Node" class="headerlink" title="结点(Node)"></a>结点(Node)</h4><p>工作流$W$定义为一系列通过边连接的调用大语言模型的结点。每个结点$N_i$表示由LLM执行的具体操作。</p>
<script type="math/tex; mode=display">N=\{N_1, N_2, ..., N_i, ...\}</script><ul>
<li>模型$M$: 在结点$N_i$调用的具体语言模型。</li>
<li>提示$P$: 提供给模型的输入或任务描述。</li>
<li>温度$\tau$: 控制结点$N_i$中LLM输出随机性的参数。</li>
<li>输出格式$F$: 模型输出的结构化格式。</li>
</ul>
<h4 id="边-Edge"><a href="#边-Edge" class="headerlink" title="边(Edge)"></a>边(Edge)</h4><p>边$E$是定义结点关系的抽象结构，控制执行顺序(表示结点之间的执行顺序和逻辑关系)。可用结构: </p>
<ul>
<li>图结构: 一种灵活的结构，表示结点间的层次、顺序或并行关系，支持复杂的分支工作流。</li>
<li>代码: 一种全面的表示方法，能够表达线性序列、条件逻辑、循环，并结合图或网络结构，为LLM工作流执行提供精确控制。<ul>
<li>作为AFlow的主要边结构，最大化表达能力。</li>
</ul>
</li>
<li>神经网络: 一种可以表示结点间复杂非线性关系的结构，基于输入和反馈实现自适应和可学习的工作流。</li>
</ul>
<h3 id="自动工作流优化-Automated-Workflow-Optimization"><a href="#自动工作流优化-Automated-Workflow-Optimization" class="headerlink" title="自动工作流优化(Automated Workflow Optimization)"></a>自动工作流优化(Automated Workflow Optimization)</h3><p>给定任务$T$和评估函数$G$，自动工作流优化的目标是发现一个工作流$W$，使得$G(W, T)$最大化。可以被形式化为一个搜索过程，其中算法$A$探索搜索空间$S$以确定最优的工作流配置。</p>
<h4 id="搜索空间"><a href="#搜索空间" class="headerlink" title="搜索空间"></a>搜索空间</h4><script type="math/tex; mode=display">S=\{(N, E)\mid E\in\epsilon\}\\\mathcal{N}=\{N(M, \tau, P, F)\mid M\in \mathcal{M}, \tau\in[0, 1], P\in\mathcal{P}, F\in\mathcal{F}\}</script><ul>
<li>$\mathcal{M}$: 语言模型集合</li>
<li>$\mathcal{P}$: 提示集合</li>
<li>$\mathcal{F}$: 输出格式集合</li>
<li>$\epsilon$: 边结构集合</li>
</ul>
<h4 id="工作流优化问题"><a href="#工作流优化问题" class="headerlink" title="工作流优化问题"></a>工作流优化问题</h4><script type="math/tex; mode=display">W=A(S, G, T)\\W^*=\arg\max_{W\in S}G(W, T)</script><h3 id="AFlow"><a href="#AFlow" class="headerlink" title="AFlow"></a>AFlow</h3><p>为了增强搜索效率，AFlow简化了搜索空间，固定了模型$M$、温度$\tau$和格式$F$等关键参数，主要只关注代码表示的边$E$和提示$P$。并且引入了操作符$\mathcal{O}$。于是将优化问题形式化为:</p>
<script type="math/tex; mode=display">S_{AFlow} = \{(P_1, ..., P_n, E, O_1, ..., O_n)|P_i\in \mathcal{P}, E\in\epsilon, O_i\in \mathcal{O}\}\\ W^*=AFLOW(S_{AFlow}, G, T)</script><ul>
<li>$S_{AFlow}$表示由提示词、边、操作符组成的集合。</li>
<li>$W^*$表示通过AFLOW框架在给定$S_{AFlow}$、评估函数$G$、任务$T$下最大化的最优工作流配置。</li>
</ul>
<h4 id="操作符-O-模板"><a href="#操作符-O-模板" class="headerlink" title="操作符$O$模板"></a>操作符$O$模板</h4><p>操作符$O$是一系列常见的操作，以提升不同任务的搜索效率。</p>
<ul>
<li>Generate: 生成</li>
<li>Format: 格式化</li>
<li>Review and Revise: 审查与修订</li>
<li>Ensemble: 集成</li>
<li>Test: 测试</li>
<li>Programmer: 程序编写</li>
<li>自定义…</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Write a python function that can &#123;instruction&#125; and provide two runnnable test cases.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">&quot;SimpleWriteCode&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, instruction: <span class="built_in">str</span></span>):</span><br><span class="line">        prompt = self.PROMPT_TEMPLATE.<span class="built_in">format</span>(instruction=instruction)</span><br><span class="line"></span><br><span class="line">        rsp = <span class="keyword">await</span> self._aask(prompt)</span><br><span class="line"></span><br><span class="line">        code_text = SimpleWriteCode.parse_code(rsp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_code</span>(<span class="params">rsp</span>):</span><br><span class="line">        pattern = <span class="string">r&quot;```python(.*)```&quot;</span></span><br><span class="line">        <span class="keyword">match</span> = re.search(pattern, rsp, re.DOTALL)</span><br><span class="line">        code_text = <span class="keyword">match</span>.group(<span class="number">1</span>) <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">else</span> rsp</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br></pre></td></tr></table></figure>
<h4 id="提示词-P-模板"><a href="#提示词-P-模板" class="headerlink" title="提示词$P$模板"></a>提示词$P$模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">REFINE_ANSWER_PROMPT = <span class="string">&quot;&quot;&quot;给出数学问题以及代码执行的输出，请提供一个格式良好且详细的解答。遵循以下指南：</span></span><br><span class="line"><span class="string">1. 以清晰的问题陈述开始。</span></span><br><span class="line"><span class="string">2. 解释所采用的方法及使用的任何公式或概念。</span></span><br><span class="line"><span class="string">3. 使用LaTeX标记展示数学表达式的逐步计算过程。</span></span><br><span class="line"><span class="string">4. 解读代码输出并将其融入到你的解释中。</span></span><br><span class="line"><span class="string">5. 提供最终答案，并用\boxed&#123;&#125; LaTeX标记包裹。</span></span><br><span class="line"><span class="string">6. 确保所有数学符号都使用LaTeX格式。你的回答应当全面、数学上严谨且易于理解。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">GENERATE_SOLUTION_PROMPT = <span class="string">&quot;&quot;&quot;请逐步解决给定的数学问题。遵循以下指南：</span></span><br><span class="line"><span class="string">1. 清晰地陈述问题。</span></span><br><span class="line"><span class="string">2. 概述方法及相关的公式或概念。</span></span><br><span class="line"><span class="string">3. 提供详细的计算过程，使用LaTeX标记表示数学表达式。</span></span><br><span class="line"><span class="string">4. 解释每一步推理的理由。</span></span><br><span class="line"><span class="string">5. 最终答案需用\boxed&#123;&#125; LaTeX标记包裹。</span></span><br><span class="line"><span class="string">6. 确保所有数学符号都使用LaTeX格式。你的解答应该详尽、数学正确且易于理解。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">DETAILED_SOLUTION_PROMPT = <span class="string">&quot;&quot;&quot;为给定的数学问题提供一个全面的、步骤详细的解答。你的回答应包括：</span></span><br><span class="line"><span class="string">1. 对问题的清晰重述。</span></span><br><span class="line"><span class="string">2. 解释涉及的数学概念和定理。</span></span><br><span class="line"><span class="string">3. 通向解答的详细逻辑步骤。</span></span><br><span class="line"><span class="string">4. 每个步骤的清楚解释，包括背后的理由。</span></span><br><span class="line"><span class="string">5. 所有的数学表达式和方程都应使用LaTeX格式。</span></span><br><span class="line"><span class="string">6. 如果适用，提供视觉辅助或图表（在文本中描述）。</span></span><br><span class="line"><span class="string">7. 最终答案明确标注并用\boxed&#123;&#125; LaTeX标记包裹。</span></span><br><span class="line"><span class="string">8. 如果相关，简要说明结果的重要性。</span></span><br><span class="line"><span class="string">确保你的解答严格、易于跟随并且对学习该概念的人具有教育意义。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="代码边-E-模板"><a href="#代码边-E-模板" class="headerlink" title="代码边$E$模板"></a>代码边$E$模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code_python = generateCode()</span><br><span class="line">max_iter = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_iter):</span><br><span class="line">    flag = runcode(code_python)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">      <span class="keyword">return</span> true</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        code_python = regenerateCode()</span><br></pre></td></tr></table></figure>
<h4 id="AFlow框架总体结构"><a href="#AFlow框架总体结构" class="headerlink" title="AFlow框架总体结构"></a>AFlow框架总体结构</h4><p><img src="" alt="Overall AFLOW framework"></p>
<p>AFlow框架总体结构是</p>
<ul>
<li>设置一个由仅具有灵活提示参数的结点、给定的操作符集合以及代码表示的边组成的搜索空间。</li>
<li>在此搜索空间中执行基于蒙特卡洛树搜索(MCTS)的变体搜索。执行以下操作直到达到最大迭代次数或满足收敛条件为止。<ul>
<li>软混合概率选择: Soft-Mixed Probability Selection</li>
<li>基于LLM的扩展: LLM-Based Expansion</li>
<li>执行评估: Executing Evaluation</li>
<li>经验反向传播: Experience Backpropagation</li>
</ul>
</li>
</ul>
<h4 id="算法-文字描述"><a href="#算法-文字描述" class="headerlink" title="算法(文字描述)"></a>算法(文字描述)</h4><p>包括初始化、选择、扩展、评估、回传和终止条件等。</p>
<ul>
<li>初始化<ul>
<li>输入: 初始工作流$W_0$，评估器$G$，数据集$D$，迭代轮数$N$，操作符集$\mathcal{O}$，前k个结点$k$，早期停止轮数$n$。</li>
<li>输出: 最优工作流$W^*$</li>
<li>步骤: <ul>
<li>初始化结果集$result\leftarrow\empty$和经验集$experience\leftarrow\empty$。</li>
<li>将数据集$D$随机划分为验证集$D_V$(20%)和测试集$D_T$(80%)。</li>
<li>在验证集$D_V$上执行初始工作流$W_0$，得到分数$scores$。</li>
<li>根据分数$scores$选择高方差的实例，形成最终的验证集$D_V$。</li>
</ul>
</li>
</ul>
</li>
<li>迭代优化(从第1轮到第N轮)<ul>
<li>如果当前是第1轮，选择初始工作流$W_0$作为父结点$parent$。</li>
<li>如果不是，则根据软混合概率选择策略选择父结点$parent$。候选结点包括得分最高的$k$个结点和初始结点(公式见下一节<a href="#算法(伪代码">算法(伪代码)</a>))。</li>
<li>加载父结点的上下文$context$。</li>
<li>扩展: 使用LLM优化器$Optimizor$，利用过去的修改和相应的改进或失败生成新的工作流$W_{round}$和修改$modification$(新的提示和结点间连接)。</li>
<li>评估: 在验证集$D_V$上执行5次新的工作流$W_{round}$，计算平均分数$avgScore$和标准差。</li>
<li>回传: 创建经验$experience$并将其添加到经验集$experiences$。</li>
<li>如果$avgScore$高于最佳分数$bestScore$，则更新$W^*$和$bestScore$。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">results = []        <span class="comment"># 结果集，存储每轮迭代结果，包括轮数、分数和成本</span></span><br><span class="line">experiences = []    <span class="comment"># 经验集，存储每轮迭代的经验，包括父结点、修改和平均分数</span></span><br><span class="line">N = <span class="number">20</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">D_V, D_T = RandomSplit(D, <span class="number">0.2</span>, <span class="number">0.8</span>) <span class="comment"># 数据集分割</span></span><br><span class="line">scores = Execute(W_0, G, D_V) <span class="comment"># 初始工作流执行</span></span><br><span class="line">D_V = SelectHighVarianceInstances(D_V, scores, threshold) <span class="comment"># 高方差实例选择，形成最终的验证集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代优化</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">  <span class="comment"># 选择父结点</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">round</span> == <span class="number">1</span>:</span><br><span class="line">      parent = W_0</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      parent = SelectParent(results)</span><br><span class="line">  <span class="comment"># 加载上下文</span></span><br><span class="line">  context = LoadContext(parent, experiences)</span><br><span class="line">  <span class="comment"># 生成新工作流</span></span><br><span class="line">  W_round, modification = Optimizer(context, O)</span><br><span class="line">  <span class="comment"># 执行新工作流</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">      score, cost = Executor(W_round, G, D_V)</span><br><span class="line">      results.append((<span class="built_in">round</span>, score, cost))</span><br><span class="line">  avgScore = CalculateAverageScore(results[<span class="built_in">round</span>])</span><br><span class="line">  <span class="comment"># 创建经验</span></span><br><span class="line">  experience = CreateExperience(parent, modification, avgScore)</span><br><span class="line">  experiences.append(experience)</span><br><span class="line">  <span class="comment"># 更新最优工作流</span></span><br><span class="line">  <span class="keyword">if</span> avgScore &gt; bestScore:</span><br><span class="line">      W_star = W_round</span><br><span class="line">      bestScore = avgScore</span><br></pre></td></tr></table></figure>
<h4 id="算法-伪代码"><a href="#算法-伪代码" class="headerlink" title="算法(伪代码)"></a>算法(伪代码)</h4><p>整个循环流程是选择最优工作流，加载工作流上下文，生成新工作流，执行新工作流，保存经验，反向传播更新最优工作流。</p>
<p><img src="" alt="Detailed Explanation of the AFlow Algorithm"></p>
<ul>
<li>$D$: 数据集，$W_0$: 初始工作流, $G$: 评价函数, $N$: 循环次数, $O$: 操作符, $Top-k$: 前k个。</li>
<li>终止条件: 如果迭代n次都没发生变化或者到达最大迭代次数就停止算法。</li>
<li>$RandomSplit(D, 0.2, 0.8)$: 拆分数据集$D$，用20%作为验证集，80%作为测试集。</li>
</ul>
<p>在选择阶段，通过在验证集上评估一个空工作流创建初始工作流程。然后使用一种结合了均匀分布和基于得分的加权概率分布的软混合概率选择策略，从top-k工作流程以及初始工作流程中持续选择工作流程。不仅保证了探索新工作流程的能力，同时有助于避免陷入局部最优。</p>
<p><img src="" alt="一些函数的具体实现"></p>
<ul>
<li>$Execute(W_0, G, D_V)$: $D_V$数据集使用$W_0$初始工作流，运行$G$平均函数得到对应的分数。</li>
<li>$SelectHighVarianceInstances(D_V, scores, threshold)$: 选择$D_V$数据集中高方差的样本。</li>
<li>$round$: 当前迭代次数。</li>
<li>$parent$: 当前工作流结点。</li>
<li>$SelectParent(results)$: 根据评估结果选择工作流。<ul>
<li>根据分数降序排序，选择前k个结果，并用对应的分数计算混合概率: <script type="math/tex">P_{mixed}(i)=\lambda\cdot\frac{1}{n} + (1-\lambda)\frac{\exp(\alpha\cdot(s_i-s_{max}))}{\sum_{j=1}^{n}\exp(\alpha\cdot(s_j-s_{max}))}</script><ul>
<li>$n$是工作流的数量。</li>
<li>$s_i$是工作流$i$的分数。</li>
<li>$s_max$是最大分数。</li>
<li>$\alpha$用来控制分数的影响。</li>
<li>$\lambda$用来平衡均匀和加权的概率。</li>
</ul>
</li>
</ul>
</li>
<li>$LoadContext(parent, experience)$: 加载$parent$结点的上下文信息，包含修改和历史信息。</li>
<li>$Optimizer(context, O)$: 通过上下文信息和操作，生成新的工作流和修改。</li>
<li>$results$: 存储每轮迭代</li>
<li>$experiences$: 存储每轮迭代的经验，包含$parent$结点、修改和平均分数。</li>
<li>$context$: 上下文信息，包含修改和历史信息。</li>
<li>$CalculateAverageScore(results[round])$: 计算在当前工作流下的平均得分。</li>
<li>$CreateExperience(parent, modification, avgScore)$: 创建经验，包括$parent$结点、修改和平均分数等信息。</li>
</ul>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul>
<li>完整数据集: <ul>
<li>GSM8K</li>
<li>HumanEval</li>
<li>MBPP</li>
</ul>
</li>
<li>部分数据集: <ul>
<li>HotpotQA和DROP中抽取1000条样本。</li>
<li>MATH从难度等级5的4个经典问题类型中挑选617个问题。<ul>
<li>Combinatorics: 组合数学</li>
<li>Probability: 概率论</li>
<li>Number Theory: 数论</li>
<li>Pre-algebra: 代数</li>
<li>Pre-calculus: 微积分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Baselines"><a href="#Baselines" class="headerlink" title="Baselines"></a>Baselines</h4><ul>
<li>Manually designed methods<ul>
<li>IO(直接调用LLM)</li>
<li>Chain-of-Thought</li>
<li>Self Consistency CoT(5 answers)</li>
<li>MultiPersona Debate</li>
<li>Self-Refine(max 3 iteration rounds) and </li>
<li>MedPrompt(3 answers and 5 votes)</li>
</ul>
</li>
<li>Automated workflow optimization method<ul>
<li>ADAS</li>
</ul>
</li>
</ul>
<h4 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h4><ul>
<li>Solve Rate(%): GSM8K, MATH</li>
<li>pass@1(for code accuracy): HumanEval, MBPP</li>
<li>F1 Score: HotpotQA, DROP</li>
<li>The cost by tracking token usage(跟踪token的使用量) to construct a pareto front: for all datasets</li>
</ul>
<h2 id="Flow-Modularized-Agentic-Workflow-Automation"><a href="#Flow-Modularized-Agentic-Workflow-Automation" class="headerlink" title="Flow: Modularized Agentic Workflow Automation"></a>Flow: Modularized Agentic Workflow Automation</h2><h3 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h3><p>现有的LLM多智能体框架在工作流动态调整方面具有局限性。</p>
<ul>
<li>忽略动态任务重新分配，大部分工作流都是静态的、预先设定的，对任务环境变化的适应性有限。</li>
<li>在工作流设计中缺乏模块化和并行性。<ul>
<li>例如AutoGen虽然也能自动生成子任务和智能体，但是子任务是线性执行的，无法并行，在时延和效率上有改进点。</li>
</ul>
</li>
</ul>
<h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>在当前已有的多智能体框架基础上，通过在任务执行期间实现动态更新工作流程，并在规划工作流程时鼓励模块化，从而进一步改进现有的通用多智能体框架。</p>
<ul>
<li>支持基于全局信息对整个流程进行局部更新，使智能体能够有效适应意外情况，同时保持系统的一致性和连贯性。</li>
<li>模块化能设计具有高并行性和低依赖复杂性的工作流程。能并发执行子任务和最大限度地减少由复杂相互依赖关系引起的瓶颈，从而提高效率、鲁棒性和可扩展性。</li>
</ul>
<h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><h4 id="Formulating-a-Workflow-as-an-AOV-Graph"><a href="#Formulating-a-Workflow-as-an-AOV-Graph" class="headerlink" title="Formulating a Workflow as an AOV Graph"></a>Formulating a Workflow as an AOV Graph</h4><p>AOV图全称“Activity on Vertex graph”，是一种有向无环图。图中结点表示的是子任务，边表示的是结点的优先关系。主要功能是高效地可视化依赖关系和子任务的执行顺序。</p>
<ul>
<li>$G=(V, E, A)$<ul>
<li>$V$表示子任务集合。</li>
<li>$E\subset V\times V$<ul>
<li>$e_{ij}=(v_i, v_j)\in E$表示子任务$v_i$必须在$v_j$之前完成。</li>
</ul>
</li>
<li>$A$表示用于所有子任务的智能体集合。$a_j\in A$表示负责执行子任务子集$T_j\subset V$的智能体。</li>
</ul>
</li>
</ul>
<h4 id="Modularity-in-a-Workflow"><a href="#Modularity-in-a-Workflow" class="headerlink" title="Modularity in a Workflow"></a>Modularity in a Workflow</h4><p>系统设计的模块化涉及将系统划分为独立运行(需降低互相的依赖性)的模块，每个模块负责特定的功能，从而可以专注于各个组件，而不会影响整个系统。有助于系统的可扩展性和灵活性。</p>
<ul>
<li>工作流程中额外的依赖关系会降低子任务的预期成功率。<ul>
<li>考虑两个拓扑排序的工作流$A$和$B$，每个工作流都包含根据执行顺序排序的$N$个子任务。<ul>
<li>随机失败可能性: 每个子任务$v\in\mathcal{T}$有$p_f(0\lt p_f\lt 1)$的概率失败。</li>
<li>工作流$B$的额外依赖: 存在至少一个子任务$v^<em>\in\mathcal{T}$和一个子任务$b\in\mathcal{T}$，使得工作流$B$中$v^</em>$的直接前置任务(依赖)的集合为$D_B(v^<em>)=D_A(v^</em>)\bigcup\{b\}$，其中$D_A(v^<em>)$是工作流$A$中$v^</em>$的直接前置任务的集合。对于所有其他子任务$v\neq v^*$满足$D_A(v)\subseteq D_B(v)$。</li>
<li>于是工作流$A$的已完成子任务的期望严格大于$B$: $E[S_A]\gt E[S_B]$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为了鼓励生成的AOV图的模块化，定义了两个评估指标。</p>
<ul>
<li>并行性: 用于衡量子任务并发执行的程度。<ul>
<li>假设$S_t$表示在第t步执行的子任务集合。$T$为总步数(DAG的最大深度)，给定AOV图$G=(V, E, A)$，整体的并行度定义为步骤中的平均子任务比例:<ul>
<li>$P_{avg} = \frac{1}{T}\sum_{t=1}^{T}S_t$</li>
</ul>
</li>
</ul>
</li>
<li>依赖复杂度: 分析子任务图中的度分布测量子任务依赖结构。对于每个子任务$v_i$，定义$deg(v_i)$为在图$G$上的直接连接数。依赖复杂度由直接连接数的标准差量化:<ul>
<li>$C_{dependency}=\sigma_{deg(v_i)}=\sqrt{\frac{1}{|V|}\sum_{v_i\in V}(deg(v_i)-\bar{d})^2}$</li>
</ul>
</li>
</ul>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>首先根据给定的任务需求，制定初始工作流程，生成执行计划和智能体分配策略。在执行过程中，工作流程会不断完善和动态更新，直到任务完成。</p>
<p><img src="" alt="Flow流程"></p>
<h4 id="Generate-an-Initial-AOV-Graph"><a href="#Generate-an-Initial-AOV-Graph" class="headerlink" title="Generate an Initial AOV Graph"></a>Generate an Initial AOV Graph</h4><p>给定一个任务需求提示$P$，让LLM基于$P$和用于初始化的指定提示$P_{init}$生成一组候选AOV图$\{G_1, G_2, …, G_k\}=f(\mathcal{P}_{init}, \mathcal{P})$。每个候选AOV图$G_k=(V_k, E_k, A_k)$都使用并行性和依赖复杂度的度量公式进行评估，然后优先选择具有最高并行性分数的工作流。如果相同并行性分数，则选择具有最低依赖复杂度的工作流。</p>
<ul>
<li>早期强调并行性与模块化是因为:<ul>
<li>如果不在早期明确鼓励并行性和独立性，生成的工作流很可能会过于复杂，导致子任务执行效率低下。</li>
<li>在任务执行的早期阶段，缺乏足够的实际执行数据（如同“监督信息”）。这使得验证初始工作流的正确性非常具有挑战性。因此，与其尝试在没有数据的情况下完美规划，不如优先优化工作流的结构属性。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_TEMPLATE = <span class="string">&quot;You are an intelligent workflow planner. Given the following task requirements, generate a set of necessary sub-tasks along with their dependencies and assign appropriate agents to each task. Ensure that tasks that can be executed in parallel are identified to enhance efficiency. The workflow should be represented as a dictionary where each key is a task and its value contains the task’s status, data, number of parents not completed, child tasks, and assigned agent.&quot;</span></span><br><span class="line">Task_Requirements = &#123;TASK_REQUIREMENTS&#125;</span><br><span class="line">Output_Format = &#123; <span class="string">&quot;Task_A&quot;</span>: &#123; <span class="string">&quot;status&quot;</span>: <span class="string">&quot;not started&quot;</span>, <span class="string">&quot;data&quot;</span>: null, <span class="string">&quot;num_parents_not_completed&quot;</span>: <span class="number">0</span>, <span class="string">&quot;child&quot;</span>: [<span class="string">&quot;Task_B&quot;</span>, <span class="string">&quot;Task_C&quot;</span>], <span class="string">&quot;agent&quot;</span>: <span class="string">&quot;Agent_1&quot;</span> &#125;, <span class="string">&quot;Task_B&quot;</span>: &#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;not started&quot;</span>, <span class="string">&quot;data&quot;</span>: null, <span class="string">&quot;num_parents_not_completed&quot;</span>: <span class="number">1</span>, <span class="string">&quot;child&quot;</span>: [<span class="string">&quot;Task_D&quot;</span>], <span class="string">&quot;agent&quot;</span>: <span class="string">&quot;Agent_2&quot;</span> &#125;, ... &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Execution-Plan-Generation-and-Agent-Allocation"><a href="#Execution-Plan-Generation-and-Agent-Allocation" class="headerlink" title="Execution Plan Generation and Agent Allocation"></a>Execution Plan Generation and Agent Allocation</h4><p>在获得最佳AOV图后，会对子任务的依赖关系图执行拓扑排序，生成子任务的先行顺序$o: V\rightarrow\{1, 2, …, |V|\}$，使得对于任何边$(v_i, v_j)\in E$，都有$o(v_i)\lt o(v_j)$。结果是一个子任务步骤序列，其中每个步骤都包含可以并行执行的子任务。此执行计划最大限度地减少了执行所需的步骤数，同时确保所有子任务在最短时间内完成，并遵守其依赖关系。</p>
<p>而每个智能体$a_j\in A$都与一组子任务$T_i\subseteq V$相关联，表明该智能体负责处理该组子任务。但如果两个子任务$v_p, v_q$在同一步骤$s_i$中需要相同的智能体$a_i$，则创建一个该智能体的克隆，表示为$a’_j$，以此来实现同时运行两个子任务而不增加等待时间。</p>
<h4 id="Workflow-Refinement-and-Dynamic-Updating"><a href="#Workflow-Refinement-and-Dynamic-Updating" class="headerlink" title="Workflow Refinement and Dynamic Updating"></a>Workflow Refinement and Dynamic Updating</h4><p>利用LLM作为全局检查器(global inspector)，持续监控任务进度，并在必要时动态修改AOV图。<br>具体来说，给定任务需求提示$P$，更新提示$P_{update}$，当前的AOV图$G_t$，以及包含子任务状态和运行子任务的智能体输出的生成数据$D_t$。与初始化过程类似，生成K个候选AOV图$\{G_{t+1}^1, G_{t+1}^2, …, G_{t+1}^K\}=f(P_{update}, P, D_t)$。遵循与初始化时相同的选择策略，该策略优先选择具有最高并行分数的工作流，如果相同并行性分数，则选择具有最低依赖复杂度的工作流。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROMPT_TEMPLATE = <span class="string">&quot;You are an intelligent workflow updater. Based on the current workflow and the all subtasks’ progress data, update the workflow for acheving the objective by adding, removing, or modifying subtasks as necessary. Ensure that the updated workflow maintains modularity and maximizes parallel execution.&quot;</span></span><br><span class="line">Output_Format= &#123; <span class="string">&quot;Task_A&quot;</span>: &#123; <span class="string">&quot;status&quot;</span>: <span class="string">&quot;not started&quot;</span>, <span class="string">&quot;data&quot;</span>: null, ... &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>由于具有模块化约束，所以动态更新可以很大程度上满足灵活性，允许修改子任务分配，包括删除、添加、编辑、重新运行和重新分配智能体，而无需影响其他智能体及被分配的子任务。</p>
<p>通过足够的数据和计算资源，我们可以通过使用强化学习对 LLM 进行微调以生成 workflow，从而进一步增强框架。</p>
<ul>
<li>将训练 LLM 以最大化围绕关键绩效指标(如任务完成速度、资源利用率和 workflow 中断最小化)设计的奖励函数。</li>
</ul>
<h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>具体实现AOV图是采用基于字典的结构，表示为$\widetilde{G}$，以便在多智能体框架内高效管理和动态更新工作流。每个子任务$v$在$\widetilde{G}$中表示为一个key，其对应的value是另一个字典(封装了子任务的各种属性)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;subtask requirement&quot;: 任务需求的文本内容;</span></span><br><span class="line"><span class="string">&quot;status&quot;: 当前任务的状态 e.g. </span></span><br><span class="line"><span class="string">  &quot;not started&quot;, </span></span><br><span class="line"><span class="string">  &quot;in progress&quot;, </span></span><br><span class="line"><span class="string">  &quot;completed&quot;;</span></span><br><span class="line"><span class="string">&quot;data&quot;: 与此任务相关的数据;</span></span><br><span class="line"><span class="string">&quot;num_parents_not_completed&quot;: 未完成的父任务的数量，用于管理依赖关系。每个子任务的执行就绪状态由此决定，只有该属性计数为0的子任务才有资格并发运行;</span></span><br><span class="line"><span class="string">&quot;child&quot;: 依赖于当前任务完成的子任务列表;</span></span><br><span class="line"><span class="string">&quot;agent&quot;: 分配给该任务的智能体。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">G[v] = &#123;<span class="string">&quot;subtask requirement&quot;</span>, <span class="string">&quot;status&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;num_parents_not_completed&quot;</span>, <span class="string">&quot;child&quot;</span>, <span class="string">&quot;agent&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在每个子任务完成后，会进行系统的审查，以确定工作流程是否需要改进，确保所有依赖项都得到准确的考虑，并且工作流程与项目目标保持一致。</p>
<p>Flow还会通过询问此子任务的所有要求是否已满足来仔细检查每个子任务的完成情况。这将大大防止因智能体报告不准确或不可预见的系统异常而导致的错误。这种严格的验证过程增强了工作流管理系统的可靠性和完整性。</p>
<h3 id="Benchmark-1"><a href="#Benchmark-1" class="headerlink" title="Benchmark"></a>Benchmark</h3><h4 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h4><p>The existing multi-agent frameworks:</p>
<ul>
<li>AutoGen</li>
<li>Camel</li>
<li>MetaGPT</li>
</ul>
<p>Agents’ model:</p>
<ul>
<li>GPT-4o-mini</li>
<li>GPT-3.5-Turbo</li>
</ul>
<h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><ul>
<li><p>五子棋游戏开发：此任务需要创建一个具有用户界面和一个简单 AI 对手的五子棋游戏。玩家可以选择黑子或白子，用户界面清楚地指示轮次，并在游戏结束时宣布获胜者或平局。此任务展示了框架处理模块化设计和任务并行性的能力，因为它涉及同时协调游戏逻辑、AI 实现和用户界面开发。</p>
</li>
<li><p>LaTeX Beamer 写作：此任务侧重于生成 LaTeX 幻灯片，涵盖强化学习算法，包括动机、问题陈述、直观的解决方案和详细的数学公式。特定的页面要求是测试框架精确遵循指令的能力。该任务突出了框架在同时生成内容、格式和演示结构方面的并行处理能力。LaTeX 的结构化格式还测试了框架管理模块化和并发任务的效率。</p>
</li>
<li><p>网站设计：此任务涉及为 International Conference on Learning Representations 构建一个专业的网站，假设定于 2025 年 4 月 27 日至 5 月 1 日在旧金山举行。该网站必须具有关键要素，例如详细的会议日程和带有交互式地图的场地信息。此任务评估每个框架管理并行工作流程和模块化组件的能力，包括用户界面设计、功能以及对设计指南的遵守情况，展示了框架处理任务分解和执行的程度。</p>
</li>
</ul>
<h4 id="Metrics-1"><a href="#Metrics-1" class="headerlink" title="Metrics"></a>Metrics</h4><ul>
<li>Success Rate<ul>
<li>评估多智能体框架是否成功生成了完全满足任务需求的可执行输出。较高的分数表示在准确完成任务目标方面取得了更大的成功。不同的任务可能有不同的评估指标。</li>
</ul>
</li>
<li>Human Rating<ul>
<li>用于评估生成结果的质量与任务描述的一致性。召集了数十名具有编程和机器学习背景的参与者来对不同方法产生的结果进行排序。</li>
</ul>
</li>
</ul>
<h2 id="WORKFLOWLLM-ENHANCING-WORKFLOW-ORCHESTRATION-CAPABILITY-OF-LARGE-LANGUAGE-MODELS"><a href="#WORKFLOWLLM-ENHANCING-WORKFLOW-ORCHESTRATION-CAPABILITY-OF-LARGE-LANGUAGE-MODELS" class="headerlink" title="WORKFLOWLLM: ENHANCING WORKFLOW ORCHESTRATION CAPABILITY OF LARGE LANGUAGE MODELS"></a>WORKFLOWLLM: ENHANCING WORKFLOW ORCHESTRATION CAPABILITY OF LARGE LANGUAGE MODELS</h2><h2 id="GRAPH-ASSISTED-OFFLINE-ONLINE-DEEP-REINFORCEMENT-LEARNING-FOR-DYNAMIC-WORKFLOW-SCHEDULING"><a href="#GRAPH-ASSISTED-OFFLINE-ONLINE-DEEP-REINFORCEMENT-LEARNING-FOR-DYNAMIC-WORKFLOW-SCHEDULING" class="headerlink" title="GRAPH ASSISTED OFFLINE-ONLINE DEEP REINFORCEMENT LEARNING FOR DYNAMIC WORKFLOW SCHEDULING"></a>GRAPH ASSISTED OFFLINE-ONLINE DEEP REINFORCEMENT LEARNING FOR DYNAMIC WORKFLOW SCHEDULING</h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/08/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/2025-06-08-%E5%87%B8%E9%9B%86%E3%80%81%E5%87%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">凸集、凸函数与凸优化问题</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/29/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-29-LLM%20Agent%20Serving/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LLM Agent Serving</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Ray%20conclusion/" title="Ray conclusion"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="title">Ray conclusion</div></div></a></div><div><a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Sia/" title="Sia"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="title">Sia</div></div></a></div><div><a href="/2025/06/29/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-29-LLM%20Agent%20Serving/" title="LLM Agent Serving"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-29</div><div class="title">LLM Agent Serving</div></div></a></div><div><a href="/2025/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-30-LLM%20Agent%20Memory/" title="LLM Agent Memory"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="title">LLM Agent Memory</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Agentic-Workflow"><span class="toc-text">Agentic Workflow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Toward-Super-Agent-System-with-Hybrid-AI-Routers"><span class="toc-text">Toward Super Agent System with Hybrid AI Routers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%94%99"><span class="toc-text">容错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-text">Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%9B%BE%E8%B7%AF%E7%94%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A7%84%E5%88%92-Intent-Router-Planner"><span class="toc-text">意图路由和自动规划(Intent Router + Planner)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%93%E7%94%A8%E6%99%BA%E8%83%BD%E4%BD%93-Task-Agents"><span class="toc-text">任务专用智能体(Task Agents)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E7%B3%BB%E7%BB%9F-Model-Router"><span class="toc-text">智能模型选择系统(Model Router)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E4%BA%91%E6%B7%B7%E5%90%88%E9%83%A8%E7%BD%B2"><span class="toc-text">端云混合部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFlow-Automating-Agentic-Workflow-Generation"><span class="toc-text">AFlow: Automating Agentic Workflow Generation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation-1"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-1"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%B7%A5%E4%BD%9C%E6%B5%81-Agentic-Workflow"><span class="toc-text">智能工作流(Agentic Workflow)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9-Node"><span class="toc-text">结点(Node)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9-Edge"><span class="toc-text">边(Edge)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BC%98%E5%8C%96-Automated-Workflow-Optimization"><span class="toc-text">自动工作流优化(Automated Workflow Optimization)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%A9%BA%E9%97%B4"><span class="toc-text">搜索空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">工作流优化问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AFlow"><span class="toc-text">AFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-O-%E6%A8%A1%E6%9D%BF"><span class="toc-text">操作符$O$模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E8%AF%8D-P-%E6%A8%A1%E6%9D%BF"><span class="toc-text">提示词$P$模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BE%B9-E-%E6%A8%A1%E6%9D%BF"><span class="toc-text">代码边$E$模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AFlow%E6%A1%86%E6%9E%B6%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">AFlow框架总体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-%E6%96%87%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-text">算法(文字描述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-text">算法(伪代码)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmark"><span class="toc-text">Benchmark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">数据集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Baselines"><span class="toc-text">Baselines</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metrics"><span class="toc-text">Metrics</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow-Modularized-Agentic-Workflow-Automation"><span class="toc-text">Flow: Modularized Agentic Workflow Automation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation-2"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-2"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-1"><span class="toc-text">Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Formulating-a-Workflow-as-an-AOV-Graph"><span class="toc-text">Formulating a Workflow as an AOV Graph</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Modularity-in-a-Workflow"><span class="toc-text">Modularity in a Workflow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Workflow"><span class="toc-text">Workflow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Generate-an-Initial-AOV-Graph"><span class="toc-text">Generate an Initial AOV Graph</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Execution-Plan-Generation-and-Agent-Allocation"><span class="toc-text">Execution Plan Generation and Agent Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Workflow-Refinement-and-Dynamic-Updating"><span class="toc-text">Workflow Refinement and Dynamic Updating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmark-1"><span class="toc-text">Benchmark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Baseline"><span class="toc-text">Baseline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task"><span class="toc-text">Task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metrics-1"><span class="toc-text">Metrics</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WORKFLOWLLM-ENHANCING-WORKFLOW-ORCHESTRATION-CAPABILITY-OF-LARGE-LANGUAGE-MODELS"><span class="toc-text">WORKFLOWLLM: ENHANCING WORKFLOW ORCHESTRATION CAPABILITY OF LARGE LANGUAGE MODELS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GRAPH-ASSISTED-OFFLINE-ONLINE-DEEP-REINFORCEMENT-LEARNING-FOR-DYNAMIC-WORKFLOW-SCHEDULING"><span class="toc-text">GRAPH ASSISTED OFFLINE-ONLINE DEEP REINFORCEMENT LEARNING FOR DYNAMIC WORKFLOW SCHEDULING</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-30-LLM%20Agent%20Memory/" title="LLM Agent Memory">LLM Agent Memory</a><time datetime="2025-06-30T08:03:23.000Z" title="发表于 2025-06-30 16:03:23">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/29/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-29-LLM%20Agent%20Serving/" title="LLM Agent Serving">LLM Agent Serving</a><time datetime="2025-06-29T03:22:18.000Z" title="发表于 2025-06-29 11:22:18">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-09-Agentic%20Workflow/" title="Agentic Workflow">Agentic Workflow</a><time datetime="2025-06-09T06:24:58.000Z" title="发表于 2025-06-09 14:24:58">2025-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/2025-06-08-%E5%87%B8%E9%9B%86%E3%80%81%E5%87%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/" title="凸集、凸函数与凸优化问题">凸集、凸函数与凸优化问题</a><time datetime="2025-06-08T03:23:03.000Z" title="发表于 2025-06-08 11:23:03">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/%E6%99%BA%E8%83%BD%E4%BD%93/2025-04-29-Hammer%E7%AC%94%E8%AE%B0/" title="Hammer笔记">Hammer笔记</a><time datetime="2025-04-29T11:33:05.000Z" title="发表于 2025-04-29 19:33:05">2025-04-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>