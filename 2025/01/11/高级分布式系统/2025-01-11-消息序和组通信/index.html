<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>消息序和组通信 | ZJN_BLOG</title><meta name="keywords" content="高级分布式系统"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="消息序和组通信概述 消息顺序 非FIFO和FIFO 因果顺序(causal order) 同步顺序(synchronous order)   多播组通信 因果顺序(causal order) 完全顺序(total order)   故障发生时的预期行为语义 多播 应用层和网络层参与    一些符号 网络$(N, L)$ 事件集合$(E, \prec)$ 消息$m^i$:  发送该消息的事件: $s">
<meta property="og:type" content="article">
<meta property="og:title" content="消息序和组通信">
<meta property="og:url" content="http://zjn-astonishe.github.io/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="消息序和组通信概述 消息顺序 非FIFO和FIFO 因果顺序(causal order) 同步顺序(synchronous order)   多播组通信 因果顺序(causal order) 完全顺序(total order)   故障发生时的预期行为语义 多播 应用层和网络层参与    一些符号 网络$(N, L)$ 事件集合$(E, \prec)$ 消息$m^i$:  发送该消息的事件: $s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2025-01-11T11:43:17.000Z">
<meta property="article:modified_time" content="2025-04-14T03:05:11.078Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="高级分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '消息序和组通信',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-14 11:05:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">消息序和组通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-11T11:43:17.000Z" title="发表于 2025-01-11 19:43:17">2025-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-14T03:05:11.078Z" title="更新于 2025-04-14 11:05:11">2025-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">高级分布式系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="消息序和组通信"><a href="#消息序和组通信" class="headerlink" title="消息序和组通信"></a>消息序和组通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>消息顺序<ul>
<li>非FIFO和FIFO</li>
<li>因果顺序(causal order)</li>
<li>同步顺序(synchronous order)</li>
</ul>
</li>
<li>多播组通信<ul>
<li>因果顺序(causal order)</li>
<li>完全顺序(total order)</li>
</ul>
</li>
<li>故障发生时的预期行为语义</li>
<li>多播<ul>
<li>应用层和网络层参与</li>
</ul>
</li>
</ul>
<h3 id="一些符号"><a href="#一些符号" class="headerlink" title="一些符号"></a>一些符号</h3><ul>
<li>网络$(N, L)$</li>
<li>事件集合$(E, \prec)$</li>
<li>消息$m^i$: <ul>
<li>发送该消息的事件: $s^i$</li>
<li>接收该消息的事件: $r^i$</li>
</ul>
</li>
<li>发送事件: $s$</li>
<li>接收事件: $r$</li>
<li>消息$M$:<ul>
<li>发送: send(M)</li>
<li>接收: receive(M)</li>
</ul>
</li>
<li>对应事件: $a\sim b$，表示两个事件在同一个进程中发生</li>
<li>发送接收对: $T={(s, r)\in E_i\times E_j | s\quad corresponds\quad to\quad r}$</li>
</ul>
<h3 id="异步和FIFO执行"><a href="#异步和FIFO执行" class="headerlink" title="异步和FIFO执行"></a>异步和FIFO执行</h3><h4 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h4><ul>
<li>$(E, \prec)$，因果关系是一个偏序关系。</li>
<li>没有因果循环</li>
<li>逻辑链路上的交付不一定遵循FIFO顺序，例如，网络层IPv4无连接服务。</li>
</ul>
<h4 id="FIFO执行"><a href="#FIFO执行" class="headerlink" title="FIFO执行"></a>FIFO执行</h4><ul>
<li>对于所有的$(s, r)\in T$和$(s’, r’)\in T$<ul>
<li>如果$s\sim s’ \And r\sim r’ \And s\prec s’$，则$r\prec r’$($\prec$的意思是顺序，前面先发生，后面后发生)</li>
</ul>
</li>
<li>所有物理链路都遵循FIFO顺序。</li>
<li>逻辑链路本质上是非FIFO的。</li>
<li>为了在非FIFO链路上实现FIFO: <ul>
<li>每条消息中使用$⟨seq_num,conn_id⟩$(序号，连接号)。</li>
<li>接收者使用缓冲区排序消息</li>
<li>例如传输层的面向连接的服务TCP。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20and%20FIFO%20Executions.png" alt="img"></p>
<ul>
<li>左图是非FIFO执行，右图是FIFO执行</li>
</ul>
<h2 id="因果序-Causal-Order-CO"><a href="#因果序-Causal-Order-CO" class="headerlink" title="因果序(Causal Order, CO)"></a>因果序(Causal Order, CO)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>对于所有$(s, r)\in T$和$(s’, r’)\in T$，如果$r\sim r’$且$s\prec s’$，则$r\prec r’$<ul>
<li>如果发送事件$s$和$s’$通过因果关系相关联(不是物理时间顺序)，那么对应的接收事件$r$和$r’$在所有共同目的地以相同的顺序发生</li>
</ul>
</li>
<li><p>如果$send(m^1)\prec send(m^2)$，则对于消息$m^1, m^2$的每个共同目的地$d$，必须满足$deliver_d(m^1)\prec deliver_d(m^2)$</p>
<ul>
<li>当两个消息由同一进程发送时，CO 退化为 FIFO。</li>
</ul>
</li>
<li><p>用途: 更新共享数据，实现分布式共享内存、公平资源分配、协作应用、事件通知系统、分布式虚拟环境。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Causal%20Order.png" alt="img"></p>
<h3 id="消息的到达与交付"><a href="#消息的到达与交付" class="headerlink" title="消息的到达与交付"></a>消息的到达与交付</h3><ul>
<li>消息到达<ul>
<li>到达操作系统缓冲区的消息$m$在$P_i$可能需要延迟，直到$m$发送之前发送给$P_i$的消息(被超越的)到达</li>
<li>应用程序处理到达消息的事件被称为交付事件(接收不等于交付)</li>
</ul>
</li>
<li>没有消息被一系列消息超越: 同一发送者和接收者对之间没有消息被一系列消息超越</li>
</ul>
<h3 id="CO的其他特征"><a href="#CO的其他特征" class="headerlink" title="CO的其他特征"></a>CO的其他特征</h3><h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><ul>
<li>对于所有$(s, r)$和$(s’, r’)\in T$，如果$s\prec s’$，则$r\prec r’$</li>
</ul>
<h4 id="空区间属性-Empty-Interval-EI"><a href="#空区间属性-Empty-Interval-EI" class="headerlink" title="空区间属性(Empty-Interval, EI)"></a>空区间属性(Empty-Interval, EI)</h4><ul>
<li><p>$(E, \prec)$是一个EI执行，如果对于所有$(s, r)\in T$，在偏序关系中的开区间集合${x\in E | s\prec x\prec r}$为空</p>
<ul>
<li>对于$EI<s, r>$，存在某个线性扩展使得相应的区间${x\in E | s\prec x\prec r}$为空<ul>
<li>线性扩展是一个偏序关系$(E, \prec)$的任何全序关系$(E, \lt)$，其中偏序关系的所有排序关系都被保留</li>
<li>线性扩展中，一个空的$(s, r)$区间意味着$s$和$r$是可以任意接近的，即发送和接收是可以接近的，由垂直箭头表示</li>
</ul>
</li>
<li>执行$E$是CO的，当且仅当对于每个$M$，存在某个时空图，在该图中该消息$M$可以被画为垂直的箭头<ul>
<li>但是CO不能推出所有的消息都可以在同一个时空图中被画成垂直箭头，否则所有的发送和接收$(s, r)$区间在相同的线性扩展中为空，同步执行<ul>
<li>在因果顺序中，事件之间的关系是基于因果关系的偏序关系。这意味着，并非所有事件都可以被直接比较；有些事件可能是并行发生的，即它们之间没有因果关系。如果所有消息都能在同一时空图中画为垂直箭头，那么这将意味着存在一个全序关系，可以对所有事件进行排序。然而，在实际的分布式系统中，由于不同的进程可能有不同的时钟，并且不是所有的事件都具有因果关系，所以无法保证所有事件能够被如此排序。</li>
<li>如果所有消息可以在同一时空图中画为垂直箭头，那意味着我们实际上是在描述一种同步执行的情况。在这种情况下，每个消息的发送和接收事件在所有进程中看起来都是按相同的顺序发生的。然而，现实中的分布式系统通常是异步的，即不同进程的时间线是独立的，消息传递可能会有延迟，而且不同进程的时钟也可能不同步。因此，不可能保证所有消息的发送和接收事件能按照同一个时间线来表示。</li>
<li>对于一个满足因果顺序的执行来说，它并不需要满足空区间属性，意味着，在两个事件s和r之间可能存在其他事件x，这些事件既不在s的过去也不在r的未来。这样的情况就不能简单地通过一条垂直箭头来表示，因为那样会暗示s和r是连续的、中间没有任何其他事件发生。</li>
<li>满足因果顺序的执行允许存在弱共同过去和未来的概念，即一个事件可以发生在消息的发送事件和接收事件之间。如果所有消息都在同一时空图中画为垂直箭头，则意味着不存在这样的中间事件，这与分布式系统的实际情况不符。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="共同过去和未来-Common-Past-and-Future"><a href="#共同过去和未来-Common-Past-and-Future" class="headerlink" title="共同过去和未来(Common Past and Future)"></a>共同过去和未来(Common Past and Future)</h4><ul>
<li>一个执行$(E, \prec)$是CO当且仅当对于每对$(s, r)\in T$和每个事件$e\in E$<ul>
<li>弱共同过去: $e\prec r \Rightarrow \lnot(s\prec e)$</li>
<li>弱共同未来: $s\prec e\Rightarrow \lnot(e\prec r)$</li>
<li>如果$s$和$r$的过去是相同的(或者未来是相同的)，则$e\prec r\Rightarrow e\prec s$和$s\prec e\Rightarrow r\prec e$，得到CO执行的一个子类，即同步执行(synchronous executions)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="同步执行-Synchronous-executions"><a href="#同步执行-Synchronous-executions" class="headerlink" title="同步执行(Synchronous executions)"></a>同步执行(Synchronous executions)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>同步因果关系$&lt;&lt;$在$E$上是最小的传递关系，满足以下条件<ul>
<li>如果事件x在同一进程中发生在事件y之前，则$x&lt;&lt;y$，事件发生在之前则因果在前</li>
<li>如果$(s, r)\in T$，则对于所有$x\in E$，$[(x &lt;&lt; s \Leftrightarrow x &lt;&lt; r)]$，且$[(s &lt;&lt; x \Leftrightarrow r &lt;&lt; x)]$，如果s和r有因果关系，则与s或r有因果关系的事件x也必须保持相同的因果顺序</li>
<li>如果$x&lt;&lt;y \And y &lt;&lt; z$则$x &lt;&lt; z$，因果顺序是传递的</li>
</ul>
</li>
<li>同步执行<ul>
<li>$(E, &lt;&lt;)$是同步执行，其中因果关系$&lt;&lt;$是一个偏序关系</li>
</ul>
</li>
<li>对同步执行进行时间戳<ul>
<li>执行$(E, \prec)$是同步的当且仅当存在从$E$到$T$(标量时间戳)的映射，使得<ul>
<li>对于任何消息$M$，$T(s(M))=T(r(M))$，即发送事件和接收事件具有相同的时间戳</li>
<li>对于每个进程$P_i$，如果$e_i\prec e_i’$，则$T(e_i)\lt T(e_i’)$，之前发生的事件时间戳更小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Synchronous%20Executions1.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/deadlocks%20when%20using%20synchronous%20primitives.png" alt="img"></p>
<h2 id="异步执行与同步通信-Asynchronous-Execution-with-Synchronous-Communication"><a href="#异步执行与同步通信-Asynchronous-Execution-with-Synchronous-Communication" class="headerlink" title="异步执行与同步通信(Asynchronous Execution with Synchronous Communication)"></a>异步执行与同步通信(Asynchronous Execution with Synchronous Communication)</h2><ul>
<li>一个异步系统编写的程序使用同步原语运行(发送和接收必须配对)可能会导致死锁<ul>
<li>死锁发生在两个或多个进程互相等待对方的操作完成，从而无法继续执行。</li>
</ul>
</li>
<li>非RSC执行是指在同步通信下不可实现的异步执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/non-RSC%20A-executions.png" alt="img"></p>
<h3 id="RSC执行"><a href="#RSC执行" class="headerlink" title="RSC执行"></a>RSC执行</h3><ul>
<li><p>Realizable with Synchronous Communication (RSC) 是一个概念，用于描述异步系统中的执行是否可以被解释为等效于同步通信环境下的执行。如果一个异步执行(A-execution)可以通过某种方式重新排序，使得它看起来就像是在一个所有消息传递都是即时完成的同步系统中发生的，那么这个异步执行就是可由同步通信实现的(RSC)。</p>
</li>
<li><p>非分离线性扩展$(E, \prec)$</p>
<ul>
<li>$(E, \prec)$的一个线性扩展，使得对于每一对$(s, r)\in T$，区间${x\in E | s\prec x\prec r}$是空的</li>
</ul>
</li>
<li>RSC执行 <ul>
<li>一个异步执行是一个RSC执行，当且仅当存在一个非分离线性扩展的偏序关系$(E, \prec)$(在所有可能的线性扩展中，至少有一个满足非分离条件。)<ul>
<li>为了确定一个异步执行是否是RSC，我们需要找到一个线性扩展(即对事件的一个全序排列)，在这个排列中，对于每一个消息$m$的发送事件$s(m)$和接收事件$r(m)$，在它们之间的开区间${x\in E | s(m)\prec x\prec r(m)}$是空的。这意味着没有其他事件发生在消息的发送和接收之间，就像同步系统中那样。</li>
<li>检查所有线性扩展具有指数级成本！</li>
<li>实际测试使用Crown皇冠特征化方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Crown测试法"><a href="#Crown测试法" class="headerlink" title="Crown测试法"></a>Crown测试法</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>设$E$是一个执行，在$E$中，大小为k的Crown是一个序列$&lt;(s^i, r^i), i\in {0, 1, …, k-1}&gt;$，其中包含对应发送事件和接收事件配对，满足以下条件:<ul>
<li>$s^0\prec r^1$</li>
<li>$s^1\prec r^2$</li>
<li>…</li>
<li>$s^{k-2}\prec r^{k-1}$</li>
<li>$s^{k-1}\prec r^0$</li>
<li>即在一个大小为k的Crown中，每个发送事件$s^i$都发生在下一个接收事件$r^{i+1}$之前，直到最后一个接收事件$r^0$</li>
</ul>
</li>
<li>在一个Crown中，$s^i$和$r^{i+1}$可能在同一个进程，也可能在不同进程</li>
<li>非CO执行必须有一个Crown</li>
<li>CO执行(非同步的)也会有一个Crown</li>
<li>Crown中的循环依赖关系意味着无法串行地调度消息，因此不是RSC</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Crown%20Test%20for%20RSC%20executions.png" alt="img"></p>
<h4 id="Crown准则"><a href="#Crown准则" class="headerlink" title="Crown准则"></a>Crown准则</h4><ul>
<li>一个执行是RSC的，即它可以实现在具有同步通信的系统上，当且仅当它不包含任何的Crown</li>
<li>复杂度<ul>
<li>$O(|E|)$，$E$为通信事件的数量</li>
</ul>
</li>
</ul>
<h4 id="RSC执行的时间戳"><a href="#RSC执行的时间戳" class="headerlink" title="RSC执行的时间戳"></a>RSC执行的时间戳</h4><ul>
<li>执行$(E, \prec)$是RSC的当且仅当存在从$E$到$T$(标量时间戳)的映射，使得<ul>
<li>对于任何消息$M$，$T(s(M))=T(r(M))$</li>
<li>对于每个$(a, b)\in (E\times E)/T$，$a\prec b \Rightarrow T(a)\lt T(b)$</li>
</ul>
</li>
</ul>
<h3 id="消息排序范式的层次结构"><a href="#消息排序范式的层次结构" class="headerlink" title="消息排序范式的层次结构"></a>消息排序范式的层次结构</h3><h4 id="RSC条件"><a href="#RSC条件" class="headerlink" title="RSC条件"></a>RSC条件</h4><ul>
<li>一个A-execution(这是异步执行)是RSC的当且仅当它是一个S-execution</li>
</ul>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><ul>
<li>$RSC\subset CO\subset FIFO\subset A$<ul>
<li>更小的类对可能的消息排序有更多的限制</li>
<li>并发度最高的是A，最低的是SYNC</li>
<li>使用同步通信的程序最容易开发和验证</li>
<li>使用非FIFO通信的程序，导致A-execution，最难设计和验证</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Hierarchy%20of%20Message%20Ordering%20Paradigms.png" alt="img"></p>
<h3 id="异步原语在同步系统上模拟执行"><a href="#异步原语在同步系统上模拟执行" class="headerlink" title="异步原语在同步系统上模拟执行"></a>异步原语在同步系统上模拟执行</h3><ul>
<li><p>使发送者与接收者解耦，但这种实现成本较高。</p>
</li>
<li><p>按照消息在同步程序(S-program)中出现的顺序进行调度。</p>
<ul>
<li>如果同步程序中消息$m_1$先于消息$m_2$出现，则在异步系统上也应按此顺序调度这些消息。</li>
</ul>
</li>
<li>同步执行(S-execution)中的偏序关系保持不变。如果在同步执行中消息$m_1$必须先于消息$m_2$发送，则在异步系统上也必须保持</li>
<li>在异步系统上使用异步原语进行通信。发送和接收无需立即完成，可以在后台异步处理</li>
<li>当同步发送被调度时: 等待确认(ack)后再完成发送。发送方阻塞直到收到确认</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Async%20Programs%20on%20Sync%20Systems.png" alt="img"></p>
<h3 id="异步系统上模拟同步程序的顺序执行"><a href="#异步系统上模拟同步程序的顺序执行" class="headerlink" title="异步系统上模拟同步程序的顺序执行"></a>异步系统上模拟同步程序的顺序执行</h3><ul>
<li>确定性程序<ul>
<li>确定性接收: 重复运行产生相同的偏序关系。意味着确定性执行，即$(E, \prec)$是固定的</li>
</ul>
</li>
<li>非确定性(除了由于不可预测的消息延迟): <ul>
<li>接收调用不指定发送者。</li>
<li>多个发送和接收在一个进程中启用；可以以可交换的顺序执行。<ul>
<li>$G_1\rightarrow CL_1 || G_2\rightarrow CL_2 || \dots|| G_k\rightarrow CL_k$</li>
</ul>
</li>
</ul>
</li>
<li>如何在异步系统上调度非确定性的同步通信调用？<ul>
<li>用相应的事件匹配发送或接收</li>
</ul>
</li>
<li>二元会合(Binary rendezvous, 使用令牌实现)<ul>
<li>每个启动的交互有一个令牌</li>
<li>在线、原子地、分布式地进行调度</li>
<li>无Crown调度(安全性): 也保证进度</li>
<li>调度中的公平性和效率</li>
</ul>
</li>
</ul>
<h4 id="Bagrodia-的二元会合-Binary-Rendezvous-算法"><a href="#Bagrodia-的二元会合-Binary-Rendezvous-算法" class="headerlink" title="Bagrodia 的二元会合(Binary Rendezvous)算法"></a>Bagrodia 的二元会合(Binary Rendezvous)算法</h4><ul>
<li>假设: <ul>
<li>接收总是启用的，这意味着任何进程都可以随时接收消息</li>
<li>发送一旦启用，就保持启用状态。这意味着一旦进程开始发送消息，它将继续发送直到完成</li>
<li>为了打破死锁，使用进程标识符(PIDs)引入不对称性</li>
<li>每个进程一次只调度一个发送</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous%200.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous.png" alt="img"></p>
<ul>
<li>消息类型:<ul>
<li>$M$: 普通消息</li>
<li>$ack(M)$: 确认消息</li>
<li>$request(M)$: 请求发送消息</li>
<li>$permission(M)$: 响应发送请求</li>
</ul>
</li>
<li>进程在知道它可以成功同步当前消息时阻塞</li>
<li>防止消息循环死锁的措施:<ul>
<li>高优先级阻塞: 高优先级进程发送消息后，阻塞自身等待低优先级进程的确认。</li>
<li>低优先级非阻塞: 低优先级进程发送要发送消息的请求后，等待高优先级进程的许可。不需要阻塞等待<ul>
<li>高优先级进程返回许可后得阻塞直到收到低优先级进程发送的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous%201.png" alt="img"></p>
<h2 id="组通信-Group-Communication"><a href="#组通信-Group-Communication" class="headerlink" title="组通信(Group Communication)"></a>组通信(Group Communication)</h2><h3 id="单播、多播和广播"><a href="#单播、多播和广播" class="headerlink" title="单播、多播和广播"></a>单播、多播和广播</h3><ul>
<li>单播: 消息从一个发送者发送给一个接收者。</li>
<li>多播: 消息从一个发送者发送给一组接收者。</li>
<li>广播: 消息从一个发送者发送给所有接收者。</li>
</ul>
<h3 id="网络层或硬件辅助多播难以提供的功能"><a href="#网络层或硬件辅助多播难以提供的功能" class="headerlink" title="网络层或硬件辅助多播难以提供的功能"></a>网络层或硬件辅助多播难以提供的功能</h3><ul>
<li>应用特定的消息传递顺序语义: 不同的应用程序可能需要不同的消息传递顺序</li>
<li>适应动态成员变化: 组成员可能会动态加入或离开</li>
<li>每次发送时将多播消息发送到任意进程集: 发送者可以选择不同的接收者集合</li>
<li>提供多种容错语义: 不同的容错策略可能适用于不同的应用场景</li>
</ul>
<h3 id="封闭组与开放组"><a href="#封闭组与开放组" class="headerlink" title="封闭组与开放组"></a>封闭组与开放组</h3><ul>
<li>封闭组: 组成员固定，不允许动态加入或离开</li>
<li>开放组: 组成员可以动态加入或离开</li>
</ul>
<h3 id="Raynal-Schiper-Toueg-RST-算法"><a href="#Raynal-Schiper-Toueg-RST-算法" class="headerlink" title="Raynal-Schiper-Toueg (RST) 算法"></a>Raynal-Schiper-Toueg (RST) 算法</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Raynal-Schiper-Toueg%20(RST" alt="img">%20Algorithm.png)</p>
<ul>
<li><p>假设</p>
<ul>
<li>FIFO通道</li>
<li>活跃性: 假设没有故障，传播时间是有限的</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>SENT: 二维数组$SENT[1…n, 1…n]$，其中n是系统的进程数量。$SENT[i, j]$表示进程$P_i$发送给进程$P_j$的最后一条消息的序列号</li>
<li>DELIV: 一维数组，表示每个进程已经本地交付的消息数量</li>
</ul>
</li>
<li><p>消息格式</p>
<ul>
<li>每条消息不仅包含本身内容，还附带发送者的$SENT$数组副本，接收者可以了解到所有其他进程的最新消息状态</li>
</ul>
</li>
<li><p>发送事件: 当进程$P_i$想要向进程$P_j$发送消息时</p>
<ul>
<li>更新自身的$SENT$数组，增加$SENT[i, j]$</li>
<li>构建消息为$(M, SENT)$，其中$M$是实际消息内容，$SENT$是当前进程$P_i$的整个$SENT$数组</li>
</ul>
</li>
<li><p>接收事件: 当进程$P_i$收到一条来自进程$P_j$的消息$(M, ST)$</p>
<ul>
<li>首先检查是否可以立即交付这条消息，对于每一个进程$x$，如果$DELIV[x] &gt;= ST[x, i]$，那么就可以安全地交付消息$M$给进程$P_i$<ul>
<li>因为是异步的，所以可能后续先到达，如果没有因果序可以先交付，就会有这个情况。</li>
</ul>
</li>
<li>更新自己的$SENT$数组反映从$P_j$接收到的新信息，设置$max(SENT[x, y], ST[x, y])$</li>
<li>更新$DELIV[j]$，因为已经接收到并准备交付来自$P_j$的新消息</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>空间复杂度<ul>
<li>每个进程: $O(n^2)$</li>
<li>每条消息: $O(n^2)$</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>每次发送和接收事件: $O(n^2)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最优的-KS-算法-Optimal-KS-Algorithm"><a href="#最优的-KS-算法-Optimal-KS-Algorithm" class="headerlink" title="最优的 KS 算法(Optimal KS Algorithm)"></a>最优的 KS 算法(Optimal KS Algorithm)</h3><ul>
<li>$M_{i, a}$: 进程$P_i$发送的第a个多播消息</li>
</ul>
<h4 id="正确性交付条件"><a href="#正确性交付条件" class="headerlink" title="正确性交付条件"></a>正确性交付条件</h4><ul>
<li>消息$M’$携带信息$d\in M.Dests$，其中消息$M$在$Send(M’)$的因果过去被发送到$d$，如果$M$尚未被交付给$d$，则$M’$也不会交付给$d$</li>
</ul>
<h4 id="优化的必要和充分条件"><a href="#优化的必要和充分条件" class="headerlink" title="优化的必要和充分条件"></a>优化的必要和充分条件</h4><ul>
<li>存储和捎带信息的事件<ul>
<li>考虑信息$d\in M_{i, a}.Dests$应该在进程的日志中存储多长时间，并且应该捎带在信息上</li>
<li>只要且只有当以下两个传播约束成立时，需要捎带:<ul>
<li>约束1: 向后不可达性，确保消息不会过早被交付。未知消息$M_{i, a}$是否已经被交付给$d$</li>
<li>约束2: 向前可达性，未知是否已经向$d$发送了在$Send(M<em>{i, a})$因果未来的消息，因此不能保证使用基于传递性的推理来确保消息$M</em>{i, a}$将被交付给$d$</li>
</ul>
</li>
<li>如果两个约束为假，则信息$d\in M.Dests$必须不被存储或传播</li>
</ul>
</li>
<li>关于消息的两个约束条件使用$(source, ts, dest)$显示跟踪<ul>
<li>一旦有约束变为假，立即删除</li>
<li>每个多播消息显式跟踪$(source, timestamp, destination)$信息，并存储在日志Log和$O_M$中。</li>
</ul>
</li>
<li>关于消息两个约束的隐式跟踪无需存储或传播<ul>
<li>可以从显示信息推导</li>
<li>用于确定何时两个约束的显示信息变为假，该消息被存储/捎带</li>
<li>类型1: 存在$d\in M<em>{i, a}.Dests$且$d\notin l</em>{i, a}.Dests\vee d\notin o_{i, a}.Dests$<ul>
<li>当$l<em>{i, a}.Dests=\empty$或$o</em>{i, a}.Dests = \empty$</li>
</ul>
</li>
<li>类型2: 如果$a<em>1\lt a_2$且$l</em>{i, a<em>2}\in LOG_j$，则$l</em>{i, a_1}\in LOG_j$<ul>
<li>形如$l_{i, a}.Dests=\empty$的条目可以通过缺失推断，不应存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Code1.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Code2.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Example.png" alt="img"></p>
<h2 id="Total-Order"><a href="#Total-Order" class="headerlink" title="Total Order"></a>Total Order</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>对于每一对进程$P_i$和$P_j$，以及每一对消息$M_x$和$M_y$，如果两个消息都被两个进程接收，则<ul>
<li>$P_i$在交付$M_x$之前交付$M_y$，当且仅当$P_j$在交付$M_x$之前交付$M_y$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Group%20Communication.png" alt="img"></p>
<h3 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h3><ul>
<li>当$P_i$想要广播消息$M$到组$G$时<ul>
<li>发送$M(i, G)$到协调器</li>
</ul>
</li>
<li>当$M(i, G)$从$P_i$到达协调器<ul>
<li>发送$M(i, G)$到组G的各成员</li>
</ul>
</li>
<li>当$M(i, G)$从协调器到达$P_j$<ul>
<li>交付$M(i, G)$到应用</li>
</ul>
</li>
<li>复杂度<ul>
<li>时间复杂度: 每次传输要2次hop</li>
<li>消息数量复杂度: n</li>
</ul>
</li>
</ul>
<h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Total%20Message%20Order%203-phase%20Algorithm%20Code.png" alt="img"></p>
<p> <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Total%20Order%20Distributed%20Algorithm%20Example.png" alt="img"> </p>
<ul>
<li>复杂度<ul>
<li>三个阶段</li>
<li>n-1个目的地需要$3(n-1)$条消息</li>
<li>延迟: 3个消息跳数</li>
</ul>
</li>
<li>也能实现因果序</li>
</ul>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><h3 id="目的地关系四种分类"><a href="#目的地关系四种分类" class="headerlink" title="目的地关系四种分类"></a>目的地关系四种分类</h3><ul>
<li>SSSG (Single Source Single Group): 单个源和单个目的地组，容易实现</li>
<li>MSSG (Multiple Sources Single Group): 多个源和单个目的地组，容易实现(集中式算法)</li>
<li>SSMG (Single Source Multiple Groups): 单个源和多个，可能重叠的目的地组，容易实现</li>
<li>MSMG (Multiple Sources Multiple Groups): 多个源和多个，可能重叠的目的地组，半集中式的传播树算法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/A%20Nomenclature%20for%20Multicast.png" alt="img"></p>
<h3 id="用于多播的传播树-Propagation-Trees"><a href="#用于多播的传播树-Propagation-Trees" class="headerlink" title="用于多播的传播树(Propagation Trees)"></a>用于多播的传播树(Propagation Trees)</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul>
<li>组集: $G = {G_1, …, G_g}$</li>
<li>元组集: $MG = {MG_1, \dots, MG_h}$<ul>
<li>每个进程属于一个元组，并且在该元组中的每个其他进程具有完全相同的组成员资格</li>
<li>元组之外没有其他进程具有该确切的组成员资格</li>
</ul>
</li>
<li>转换<ul>
<li>多源多组(MSMG)到组 $\rightarrow$多源单组(MSSG)到元组</li>
</ul>
</li>
<li><p>管理节点</p>
<ul>
<li>每个元组中有一个区分的节点作为管理者</li>
</ul>
</li>
<li><p>传播森林/树</p>
<ul>
<li>所有元组组织成一个传播森林/树，满足以下条件<ul>
<li>对于用户组$G_i$, $PM(G_i)$位于树的最低可能就级别(离根最远)，使得所有目标包含$G_i$中任何节点的元组都属于以$PM(G_i)$为根的子树</li>
</ul>
</li>
</ul>
</li>
<li>传播树不是唯一的<ul>
<li>具有来自更多用户组成员的元组作为根节点，使得树高度较低</li>
</ul>
</li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul>
<li><p>主元组($PM(G)$)</p>
<ul>
<li>对于每个用户组$G_i$，选择其中一个元组作为其主元组(PM)，记为$PM(G_i)$   </li>
<li>传播树中所有其他元组的祖先   </li>
<li>唯一定义的   </li>
<li>对于任何元组$MG$，从该元组所属的任何用户组的主元组到$MG$都有一条唯一的路径</li>
<li>任何$PM(G_1)$和$PM(G_2)$要么位于同一棵树的同一分支上，要么位于不同的树上。在后一种情况下，它们的组成员集合是不相交的。</li>
<li>多播消息首先发送到元组$PM(G_i)$，因为只有以$PM(G_i)$为根的子树可以包含$G_i$中的节点。随后消息沿着以$PM(G_i)$为根的子树向下传播</li>
</ul>
</li>
<li><p>元组之间的关系   </p>
<ul>
<li>$MG_1$包含$MG_2$，如果$MG_1$是每个用户组$G$的子集，而$MG_2$也是这些用户组的子集</li>
<li>$MG_1$和$MG_2$相交，如果两者都不包含对方，且存在某个组$G$，使得$MG_1, MG_2\subset G$</li>
</ul>
</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20Example.png" alt="img"></p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20(CO%20and%20TO" alt="img">%20Code.png)</p>
<ul>
<li>每个进程都知道传播树</li>
<li>每个元组都有一个用于区分的进程(manager)</li>
<li>$SV_i[k]$在每个$P_i$处: 由$P_i$多播的消息数量，这些消息通过$PM(G_k)$传播。附带在每个由$P_i$发送的多播消息上</li>
<li>$RV_{manager(PM(G_z))}[k]$: 由$P_k$发送并被$PM(G_z)$接收的消息的数量</li>
<li>$manager(PM(G<em>z))$: 如果$SV_i[z]==RV</em>{manager(PM(G_z))}[i]$，则处理来自$P_i$的消息$M$，否则缓冲消息$M$直到条件成立</li>
<li>在非主元组的管理者处: 消息顺序已经确定，因为它从未直接从多播发送者接收消息。转发(伪代码的2d-2g)。</li>
</ul>
<h3 id="Total-Order的正确性"><a href="#Total-Order的正确性" class="headerlink" title="Total Order的正确性"></a>Total Order的正确性</h3><ul>
<li>考虑$MG_1, MG_2\subset G_x, G_y$<ul>
<li>$PM(G_x), PM(G_y)$都包含$MG_1, MG_2$，并且位于传播树的同一个分支上，终点是$MG_1$或$MG_2$</li>
<li>由树下主元组(+FIFO)看到的顺序等于由被它包含的元组中的进程看到的顺序</li>
</ul>
</li>
</ul>
<h3 id="因果序的正确性-Causal-order"><a href="#因果序的正确性-Causal-order" class="headerlink" title="因果序的正确性(Causal order)"></a>因果序的正确性(Causal order)</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20Correctness%20for%20CO.png" alt="img"></p>
<h3 id="应用级多播算法"><a href="#应用级多播算法" class="headerlink" title="应用级多播算法"></a>应用级多播算法</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Classification%20of%20Application-Level%20Multicast%20Algorithms.png" alt="img"></p>
<ul>
<li>基于通信历史的算法: RST, KS, Lamport, NewTop</li>
<li>基于特权的算法: Token-holder多播<ul>
<li>进程按 seq_no 的顺序传递消息</li>
<li>通常是封闭组，并且保证因果排序(CO)和总排序(TO)</li>
<li>示例：Totem, On-demand</li>
</ul>
</li>
<li>移动排序器算法: Change-Maxemchuck, Pinwheel<ul>
<li>排序器的令牌包含 seq_no 和已分配 seq_no 的消息列表(这些是发送的消息)</li>
<li>在接收令牌时，排序器为收到但未排序的消息分配 seq_nos，并将新排序的消息发送到目的地</li>
<li>目的地按 seq_no 的顺序传递消息</li>
</ul>
</li>
<li>固定排序器算法: 简化移动排序器的方法<ul>
<li>传播树、ISIS、Amoeba、Phoenix、Newtop-asymmetric</li>
</ul>
</li>
<li>目的地协议算法: 目的地接收有限的排序信息<ul>
<li>基于时间戳的(Lamport 的三阶段)</li>
<li>基于协议的，目的地之间达成一致</li>
</ul>
</li>
</ul>
<h3 id="容错多播的语义"><a href="#容错多播的语义" class="headerlink" title="容错多播的语义"></a>容错多播的语义</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>多播是非原子的！</li>
<li>在故障期间有明确定义的行为 $\Rightarrow$ 明确定义的恢复动作<ul>
<li>(统一)规范：指定故障进程的行为(良性故障模型)</li>
</ul>
</li>
</ul>
<h4 id="统一可靠的多播"><a href="#统一可靠的多播" class="headerlink" title="统一可靠的多播"></a>统一可靠的多播</h4><ul>
<li>有效性: 如果一个正确进程多播了消息 $M$，那么所有正确进程最终都会交付$M$。</li>
<li>(统一)一致性: 如果一个正确(或故障)进程交付了消息$M$，那么所有正确进程最终都会交付$M$。</li>
<li>(统一)完整性: 每个正确(或故障)进程最多交付一次消息$M$，并且仅当$M$之前由发送者多播时。</li>
<li>(统一)FIFO顺序: 如果一个进程在广播$M$之前广播了$M’$，那么没有正确(或故障)进程会在未先交付$M$的情况下交付$M’$</li>
<li>(统一)因果顺序: 如果一个进程在因果上先广播$M$再广播了$M’$，那么没有正确(或故障)进程会在未先交付$M$的情况下交付$M’$</li>
<li>(统一)总顺序: 如果正确(或故障)进程a和b都交付了$M$和$M’$，那么a在交付$M$之前交付$M’$当且仅当b在交付$M$之前交付$M’$</li>
</ul>
<h4 id="基于全局时钟或本地时钟的规范-需要时钟同步"><a href="#基于全局时钟或本地时钟的规范-需要时钟同步" class="headerlink" title="基于全局时钟或本地时钟的规范(需要时钟同步)"></a>基于全局时钟或本地时钟的规范(需要时钟同步)</h4><ul>
<li>(统一)Real Time $\Delta$-Timeliness: 对于某个已知的常数$\Delta$，如果$M$在实际时间$t$被多播，那么没有正确(或故障)进程在实际时间$t+\Delta$之后交付$M$，要求在此之前交付</li>
<li>(统一)Local $\Delta$-Timeliness: 对于某个已知的常数$\Delta$，如果$M$在本地时间$t_m$被多播，那么没有正确(或故障)进程在其本地时间$t_m+\Delta$之后交付$M$，要求在此之前交付</li>
</ul>
<h3 id="反向路径转发-Reverse-Path-Forwarding-RPF"><a href="#反向路径转发-Reverse-Path-Forwarding-RPF" class="headerlink" title="反向路径转发(Reverse Path Forwarding, RPF)"></a>反向路径转发(Reverse Path Forwarding, RPF)</h3><ul>
<li>用于受限泛洪</li>
<li>网络层多播利用拓扑结构<ul>
<li>例如，桥接局域网(LANs)使用生成树学习目的地并分发信息</li>
<li>IP层RPF近似于DVR/LSR类似算法，但成本更低</li>
</ul>
</li>
<li>主要特点<ul>
<li>广播被限制以近似生成树</li>
<li>近似的根生成树被识别出来，而无需计算或存储</li>
<li>消息数量更接近$|N|$节点数，而不是$|L|$边数</li>
</ul>
</li>
<li>具体步骤<ul>
<li>当进程$P_i$想要向组Dest发送消息$M$<ul>
<li>在所有出站链路上发送$M(i, Dest)$</li>
</ul>
</li>
<li>当节点i从节点j接收到消息$M(x, Dest)$<ul>
<li>如果$Next_hop(x) = j$，则这将是一个新消息</li>
<li>向除(i, j)以外的所有其他入站链路转发$M(x, Dest)$</li>
<li>否则忽略该消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Kou-Markowsky-Berman（KMB）启发式算法"><a href="#Kou-Markowsky-Berman（KMB）启发式算法" class="headerlink" title="Kou-Markowsky-Berman（KMB）启发式算法"></a>Kou-Markowsky-Berman（KMB）启发式算法</h3><ul>
<li>应用于Steiner树问题 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Kou-Markowsky-Berman%20Heuristic%20for%20Steiner%20Tree.png" alt="img"></p>
<h3 id="受约束的-延迟受限的-Steiner树-Constrained-Delay-bounded-Steiner-Trees"><a href="#受约束的-延迟受限的-Steiner树-Constrained-Delay-bounded-Steiner-Trees" class="headerlink" title="受约束的(延迟受限的)Steiner树(Constrained Delay-bounded Steiner Trees)"></a>受约束的(延迟受限的)Steiner树(Constrained Delay-bounded Steiner Trees)</h3><ul>
<li>对于给定的延迟容忍度$\Delta$，给定的源节点$s$和目标节点集$Dest$，其中${s}\bigcup Dest = N’\subset N$，识别一个覆盖所有$N’$中节点的生成树$T$，满足以下约束条件: <ul>
<li>$\sum_{l\in T} C(l)$最小化，其中$C(l)$是边的成本</li>
<li>对于所有$v\in N’$，路径$path(s, v)$上的所有边l的延迟之和$\sum_{l\in path(s, v)}D(l)\lt \Delta$，其中$path(s, v)$表示从s到v在T中的路径<ul>
<li>路径的成本和延迟分别表示为$C(x, y), D(x, y)$</li>
</ul>
</li>
<li>受约束的最便宜路径是从x到y的路径，其延迟要小于$\Delta$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Constrained%20(Delay-Bounded" alt="img">%20Steiner%20Trees%20Algorithm.png)</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Constrained%20(Delay-Bounded" alt="img">%20Steiner%20Trees%20Example.png)</p>
<ul>
<li>启发式算法<ul>
<li>启发式$CST_{CD}$: 尝试选择低成本的边，同时尽量最大化剩余允许的延迟</li>
<li>启发式$CST_C$: 确保满足延迟界限的同时最小化成本</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>找到所有节点上的受约束最短路径，$O(n^3\Delta)$(主导步骤)</li>
<li>在闭合图上构建受约束的最小生成树，该图有k个节点，$O(k^3)$</li>
<li>扩展受约束的生成树<ul>
<li>涉及将k条边扩展到最多n-1条边，并消除环路，$O(kn)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于核心的多播树"><a href="#基于核心的多播树" class="headerlink" title="基于核心的多播树"></a>基于核心的多播树</h3><ul>
<li>多播树动态构建，按需增长</li>
<li>每个组都有一个或多个核心节点</li>
<li>希望加入树作为接收者的节点<ul>
<li>发送单播加入消息到核心节点</li>
</ul>
</li>
<li>加入过程标记边<ul>
<li>加入消息在传输过程中标记边；它要么到达核心节点，要么到达已经属于树的一部分的某个节点</li>
<li>从加入消息开始到核心/多播树的路径被嫁接到多播树上</li>
</ul>
</li>
<li>树上的节点进行多播<ul>
<li>使用核心树上的泛洪来多播消息</li>
</ul>
</li>
<li>不在树上的节点<ul>
<li>向核心节点发送消息；一旦消息到达树上的任何节点，它就在树上泛洪</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">高级分布式系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%9C%AF%E8%AF%AD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">术语和基本算法</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/10/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2025-03-10-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法分析与问题的计算复杂度</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/21/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-21-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="分布式系统简介"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="title">分布式系统简介</div></div></a></div><div><a href="/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/" title="分布式计算模型"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="title">分布式计算模型</div></div></a></div><div><a href="/2024/09/29/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-29-%E9%80%BB%E8%BE%91%E6%97%B6%E9%97%B4/" title="逻辑时间"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-29</div><div class="title">逻辑时间</div></div></a></div><div><a href="/2024/10/25/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-10-25-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95/" title="全局状态及快照算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="title">全局状态及快照算法</div></div></a></div><div><a href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%9C%AF%E8%AF%AD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/" title="术语和基本算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="title">术语和基本算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1"><span class="toc-text">消息序和组通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%AC%A6%E5%8F%B7"><span class="toc-text">一些符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8CFIFO%E6%89%A7%E8%A1%8C"><span class="toc-text">异步和FIFO执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="toc-text">异步执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO%E6%89%A7%E8%A1%8C"><span class="toc-text">FIFO执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%BA%8F-Causal-Order-CO"><span class="toc-text">因果序(Causal Order, CO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%B0%E8%BE%BE%E4%B8%8E%E4%BA%A4%E4%BB%98"><span class="toc-text">消息的到达与交付</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CO%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E5%BE%81"><span class="toc-text">CO的其他特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F"><span class="toc-text">消息顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%8C%BA%E9%97%B4%E5%B1%9E%E6%80%A7-Empty-Interval-EI"><span class="toc-text">空区间属性(Empty-Interval, EI)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E8%BF%87%E5%8E%BB%E5%92%8C%E6%9C%AA%E6%9D%A5-Common-Past-and-Future"><span class="toc-text">共同过去和未来(Common Past and Future)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C-Synchronous-executions"><span class="toc-text">同步执行(Synchronous executions)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1-Asynchronous-Execution-with-Synchronous-Communication"><span class="toc-text">异步执行与同步通信(Asynchronous Execution with Synchronous Communication)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RSC%E6%89%A7%E8%A1%8C"><span class="toc-text">RSC执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Crown%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-text">Crown测试法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Crown%E5%87%86%E5%88%99"><span class="toc-text">Crown准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSC%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">RSC执行的时间戳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%92%E5%BA%8F%E8%8C%83%E5%BC%8F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">消息排序范式的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSC%E6%9D%A1%E4%BB%B6"><span class="toc-text">RSC条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">层次结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8E%9F%E8%AF%AD%E5%9C%A8%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C"><span class="toc-text">异步原语在同步系统上模拟执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%A8%A1%E6%8B%9F%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-text">异步系统上模拟同步程序的顺序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bagrodia-%E7%9A%84%E4%BA%8C%E5%85%83%E4%BC%9A%E5%90%88-Binary-Rendezvous-%E7%AE%97%E6%B3%95"><span class="toc-text">Bagrodia 的二元会合(Binary Rendezvous)算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E9%80%9A%E4%BF%A1-Group-Communication"><span class="toc-text">组通信(Group Communication)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%92%AD%E3%80%81%E5%A4%9A%E6%92%AD%E5%92%8C%E5%B9%BF%E6%92%AD"><span class="toc-text">单播、多播和广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%88%96%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E5%A4%9A%E6%92%AD%E9%9A%BE%E4%BB%A5%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">网络层或硬件辅助多播难以提供的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%97%AD%E7%BB%84%E4%B8%8E%E5%BC%80%E6%94%BE%E7%BB%84"><span class="toc-text">封闭组与开放组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raynal-Schiper-Toueg-RST-%E7%AE%97%E6%B3%95"><span class="toc-text">Raynal-Schiper-Toueg (RST) 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E7%9A%84-KS-%E7%AE%97%E6%B3%95-Optimal-KS-Algorithm"><span class="toc-text">最优的 KS 算法(Optimal KS Algorithm)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%BA%A4%E4%BB%98%E6%9D%A1%E4%BB%B6"><span class="toc-text">正确性交付条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E5%92%8C%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="toc-text">优化的必要和充分条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Total-Order"><span class="toc-text">Total Order</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="toc-text">集中式算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="toc-text">分布式算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD"><span class="toc-text">多播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%85%B3%E7%B3%BB%E5%9B%9B%E7%A7%8D%E5%88%86%E7%B1%BB"><span class="toc-text">目的地关系四种分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%A4%9A%E6%92%AD%E7%9A%84%E4%BC%A0%E6%92%AD%E6%A0%91-Propagation-Trees"><span class="toc-text">用于多播的传播树(Propagation Trees)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-text">元组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91"><span class="toc-text">逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Total-Order%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-text">Total Order的正确性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%BA%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7-Causal-order"><span class="toc-text">因果序的正确性(Causal order)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BA%A7%E5%A4%9A%E6%92%AD%E7%AE%97%E6%B3%95"><span class="toc-text">应用级多播算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E5%A4%9A%E6%92%AD%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-text">容错多播的语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-text">要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%A4%9A%E6%92%AD"><span class="toc-text">统一可靠的多播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%B1%80%E6%97%B6%E9%92%9F%E6%88%96%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%92%9F%E7%9A%84%E8%A7%84%E8%8C%83-%E9%9C%80%E8%A6%81%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5"><span class="toc-text">基于全局时钟或本地时钟的规范(需要时钟同步)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8F%91-Reverse-Path-Forwarding-RPF"><span class="toc-text">反向路径转发(Reverse Path Forwarding, RPF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kou-Markowsky-Berman%EF%BC%88KMB%EF%BC%89%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="toc-text">Kou-Markowsky-Berman（KMB）启发式算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E7%BA%A6%E6%9D%9F%E7%9A%84-%E5%BB%B6%E8%BF%9F%E5%8F%97%E9%99%90%E7%9A%84-Steiner%E6%A0%91-Constrained-Delay-bounded-Steiner-Trees"><span class="toc-text">受约束的(延迟受限的)Steiner树(Constrained Delay-bounded Steiner Trees)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%B8%E5%BF%83%E7%9A%84%E5%A4%9A%E6%92%AD%E6%A0%91"><span class="toc-text">基于核心的多播树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-30-LLM%20Agent%20Memory/" title="LLM Agent Memory">LLM Agent Memory</a><time datetime="2025-06-30T08:03:23.000Z" title="发表于 2025-06-30 16:03:23">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/29/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-29-LLM%20Agent%20Serving/" title="LLM Agent Serving">LLM Agent Serving</a><time datetime="2025-06-29T03:22:18.000Z" title="发表于 2025-06-29 11:22:18">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-09-Agentic%20Workflow/" title="Agentic Workflow">Agentic Workflow</a><time datetime="2025-06-09T06:24:58.000Z" title="发表于 2025-06-09 14:24:58">2025-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/08/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/2025-06-08-%E5%87%B8%E9%9B%86%E3%80%81%E5%87%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/" title="凸集、凸函数与凸优化问题">凸集、凸函数与凸优化问题</a><time datetime="2025-06-08T03:23:03.000Z" title="发表于 2025-06-08 11:23:03">2025-06-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/%E6%99%BA%E8%83%BD%E4%BD%93/2025-04-29-Hammer%E7%AC%94%E8%AE%B0/" title="Hammer笔记">Hammer笔记</a><time datetime="2025-04-29T11:33:05.000Z" title="发表于 2025-04-29 19:33:05">2025-04-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>