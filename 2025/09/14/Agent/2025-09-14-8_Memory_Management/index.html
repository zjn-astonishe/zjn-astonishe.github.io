<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>8. Memory Management | ZJN_BLOG</title><meta name="keywords" content="Agent"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Memory ManagementMotivationAgentic systems need to remember information from past interactions to perform complex tasks and provide coherent experiences.  Without a memory mechanism, agents are statel">
<meta property="og:type" content="article">
<meta property="og:title" content="8. Memory Management">
<meta property="og:url" content="http://zjn-astonishe.github.io/2025/09/14/Agent/2025-09-14-8_Memory_Management/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="Memory ManagementMotivationAgentic systems need to remember information from past interactions to perform complex tasks and provide coherent experiences.  Without a memory mechanism, agents are statel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2025-09-14T05:17:58.000Z">
<meta property="article:modified_time" content="2025-09-16T06:52:26.806Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="Agent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2025/09/14/Agent/2025-09-14-8_Memory_Management/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '8. Memory Management',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-16 14:52:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">8. Memory Management</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-14T05:17:58.000Z" title="发表于 2025-09-14 13:17:58">2025-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-16T06:52:26.806Z" title="更新于 2025-09-16 14:52:26">2025-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Agent/">Agent</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Agentic systems need to remember information from past interactions to perform complex tasks and provide coherent experiences. </p>
<p>Without a memory mechanism, agents are stateless, unable to maintain conversational context, learn from experience, or personalize responses for users. </p>
<p>This fundamentally limits them to simple, one-shot interactions, failing to handle multi-step processes or evolving user needs. </p>
<p>The core problem is how to effectively manage both the immediate, temporary information of a single conversation and the vast, persistent knowledge gathered over time.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>In agent systems, memory refers to an agent’s ability to retain and utilize information from past interactions, observations, and learning experiences. This capability allows agents to make informed decisions, maintain conversational context, and improve over time.</p>
<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>Agent memory is generally categorized into two main types:</p>
<ul>
<li>Short-Term Memory (Contextual Memory):<ul>
<li>This memory holds information currently being processed or recently accessed.</li>
<li>This memory primarily exists within the context window which contains recent messages, agent replies, tool usage results, and agent reflections from the current interaction. All inform the LLM’s subsequent responses and actions. </li>
<li>The context window has a limited capacity, restricting the amount of recent information an agent can directly access. <ul>
<li>Efficient short-term memory management involves keeping the most relevant information within this limited space, summarizing older conversation segments or emphasizing key details.</li>
<li>Long Context windows simply expands the size of this short-term memory, allowing more information to be held within a single interaction.</li>
</ul>
</li>
<li>However, it is still ephemeral and is lost once the session concludes, and it can be costly and inefficient to process every time. </li>
</ul>
</li>
<li>Long-Term Memory (Persistent Memory):<ul>
<li>This memory acts as a repository for information agents need to retain across various interactions, tasks or extended periods, akin to long-term knowledge bases.<ul>
<li>Data is typically stored outside the agent’s immediate processing environment, often in databases, knowledge graphs, or vector databases.</li>
<li>In vector databases, information is converted into numerical vectors and stored, enabling agents to retrieve data based on semantic similarity rather than exact keyword matches, a process known as semantic search.</li>
</ul>
</li>
<li>When an agent needs information from long-term memory, it queries the external storage, retrieves relevant data, and integrates it into the short-term context for immediate use, thus combining prior knowledge with the current interaction.</li>
</ul>
</li>
</ul>
<h2 id="Applicable-Scenarios"><a href="#Applicable-Scenarios" class="headerlink" title="Applicable Scenarios"></a>Applicable Scenarios</h2><p>Use this pattern when an agent needs to do more than answer a single question. It is essential for agents that must maintain context throughout a conversation, track progress in multi-step tasks, or personalize interactions by recalling user preferences and history. Implement memory management whenever the agent is expected to learn or adapt based on past successes, failures, or newly acquired information.</p>
<ul>
<li>Chatbots and Conversational AI<ul>
<li>Maintaining conversation flow relies on Short-term memory, so that they can remember prior user inputs to provide coherent responses.  </li>
<li>Long-term memory enables chatbots to recall user preferences, past issues, or prior discussions, offering personalized and continuous interactions.</li>
</ul>
</li>
<li>Task-Oriented Agent<ul>
<li>Managing mult-step tasks need short-term memory to track previous steps, current progress, and overall goals, which might reside in the task’s context or temporary storage.</li>
<li>Long-term memory is crucial for accessing specific user-related data not in the immediate context.</li>
</ul>
</li>
<li>Personalized Experiences<ul>
<li>Agent utilize long-term memory to store and retrieve user preferences, past behaviors, and personal information. This allows agents to adapt their responses and suggestions.</li>
</ul>
</li>
<li>Learning and Improvement<ul>
<li>Agents can refine their performance by learning from past interactions. Successful strategies, mistakes, and new information are stored in long-term memory, facilitating future adaptation. Reinforcement learning agents store learned strategies or knowledge in this way. </li>
</ul>
</li>
<li>Information Retrieval (RAG)<ul>
<li>Agents designed for answering questions access a knowledge base, their long-term memory, often implemented within Retrieval Augmented Generation (RAG). The agent retrieves relevant documents or data to inform its responses.</li>
</ul>
</li>
<li>Autonomous Systems<ul>
<li>Robots or self-driving cars require memory for maps, routes, object locations, and learned behaviors. This involves short-term memory for immediate surroundings and long-term memory for general environmental knowledge.</li>
</ul>
</li>
</ul>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><h3 id="Google-ADK"><a href="#Google-ADK" class="headerlink" title="Google ADK"></a>Google ADK</h3><p>Agentic frameworks like the Google ADK provide specific components to manage this, such as Session for the conversation thread and State for its temporary data. A dedicated MemoryService is used to interface with the long-term knowledge base, allowing the agent to retrieve and incorporate relevant past information into its current context.</p>
<p>The Google Agent Developer Kit (ADK) offers a structured method for managing context and memory, including components for practical application. A solid grasp of ADK’s Session, State and Memory is vital for building agents that need to retain information. </p>
<p>Every interaction with an agent can be considered a unique conversation thread. </p>
<h4 id="Session-Keeping-Track-of-Each-Chat"><a href="#Session-Keeping-Track-of-Each-Chat" class="headerlink" title="Session: Keeping Track of Each Chat"></a>Session: Keeping Track of Each Chat</h4><p>An individual chat thread that logs messages and actions (Events) for that specific interaction, also storing temporary data (State) relevant to that conversation.</p>
<p>The SessionService manages chat threads (Session objects) by handling their initiation, recording, and termination.</p>
<p>A Session object in ADK is designed to track and manage individual chat threads. </p>
<ul>
<li>Developers typically interact with Session objects indirectly through the SessionService. Upon initiation of a conversation with an agent, the SessionService generates a Session object, represented as “google.adk.sessions.Session”. This object encapsulates all data relevant to a specific conversation thread, including: <ul>
<li>Unique identifiers “(id, app_name, user_id)”, </li>
<li>A chronological record of events as “Event objects”, </li>
<li>A storage area for session-specific temporary data known as “State”</li>
<li>A timestamp indicating the last update “last_update_time”</li>
</ul>
</li>
</ul>
<p>The SessionService is responsible for managing the lifecycle of conversation sessions, which includes: </p>
<ul>
<li>Initiating new sessions, </li>
<li>Resuming previous sessions, </li>
<li>Recording session activity (including state updates), </li>
<li>Identifying active sessions, </li>
<li>Managing the removal of session data. </li>
</ul>
<p>The ADK provides several SessionService implementations with varying storage mechanisms for session history and temporary data, which determines how the agent’s interaction history and temporary data are stored and their persistence, such as:</p>
<ul>
<li>The “InMemorySessionService”, which is suitable for testing but does not provide data persistence across application restarts.</li>
<li>There is “DatabaseSessionService” if you want reliable saving to a database you manage. </li>
<li>There is also “VertexAiSessionService” which uses Vertex AI infrastructure for scalable production on Google Cloud.</li>
</ul>
<p>Each message exchange involves a cyclical process: </p>
<ul>
<li>A message is received, the Runner retrieves or establishes a Session using the SessionService, </li>
<li>The agent processes the message using the Session’s context (state and historical interactions), </li>
<li>The agent generates a response and may update the state.</li>
<li>The Runner encapsulates the response as an Event, and the “session_service.append_event” method records the new event and updates the state in storage. </li>
<li>The Session then awaits the next message. </li>
<li>Ideally, the “delete_session” method is employed to terminate the session when the interaction concludes. </li>
</ul>
<h4 id="State-The-Session’s-Scratchpad"><a href="#State-The-Session’s-Scratchpad" class="headerlink" title="State: The Session’s Scratchpad"></a>State: The Session’s Scratchpad</h4><p>Data stored within a Session, containing information relevant only to the current, active chat thread. </p>
<p>Each Session, representing a chat thread, includes a State component akin to an agent’s temporary working memory for the duration of that specific conversation. </p>
<ul>
<li>“session.events” logs the entire chat history, </li>
<li>“session.state” stores and updates dynamic data points relevant to the active chat. It operates as a dictionary, storing data as key-value pairs. Its core function is to enable the agent to retain and manage details essential for coherent dialogue, such as: <ul>
<li>user preferences,</li>
<li>task progress,</li>
<li>incremental data collection,</li>
<li>conditional flags influencing subsequent agent actions.</li>
</ul>
</li>
</ul>
<p>The state’s structure comprises string keys paired with values of serializable Python types, including strings, numbers, booleans, lists, and dictionaries containing these basic types. </p>
<p>State is dynamic, evolving throughout the conversation. The permanence of these changes depends on the configured SessionService.</p>
<p>State organization can be achieved using key prefixes to define data scope and persistence. Keys without prefixes are session-specific. </p>
<ul>
<li>The “user”: prefix associates data with a user ID across all sessions.</li>
<li>The “app”: prefix designates data shared among all users of the application.</li>
<li>The “temp”: prefix indicates data valid only for the current processing turn and is not persistently stored.</li>
</ul>
<p>The agent accesses all state data through a single “session.state” dictionary. </p>
<p>The SessionService handles data retrieval, merging, and persistence. State should be updated upon adding an Event to the session history via “session_service.append(event)”. </p>
<ul>
<li>The simple way:<ul>
<li>Using “ouput_key” for Agent Text Replies. This is the easiest method if you just want to save your agent’s final text response directly into the state. </li>
<li>When you set up your “LlmAgent”, just tell it the “output_key” you want to use. </li>
<li>The Runner sees this and automatically creates the necessary actions with a “state_delta” to save the response to the state when it “append_event”. </li>
</ul>
</li>
<li>The Standard way: <ul>
<li>Using “EventActions.state_delta” for More Complicated Updates. For times when you need to do more complex things (updating several keys at once, saving things that aren’t just text, targeting specific scopes (user, app), or making updates that aren’t tied to the agent’s final text reply). </li>
<li>You should manually build a dictionary of your state changes (the state_delta) and include it within the “EventActions” of the Event you’re appending.</li>
</ul>
</li>
</ul>
<p>Note that direct modification of the “session.state” dictionary after retrieving a session is strongly discouraged as it bypasses the standard event processing mechanism. Such direct changes will not be recorded in the session’s event history, may not be persisted by the selected “SessionService”, could lead to concurrency issues, and will not update essential metadata such as timestamps. </p>
<p>The recommended methods for updating the session state are </p>
<ul>
<li>Using the “output_key” parameter on an “LlmAgent” (specifically for the agent’s final text responses) or </li>
<li>Including state changes within “EventActions.state_delta” when appending an event via “session_service.append_event()”. </li>
<li>The “session.state” should primarily be used for reading existing data. When designing your state, keep it simple, use basic data types, give your keys clear names and use prefixes correctly, avoid deep nesting, and always update state using the append_event process.</li>
</ul>
<h4 id="Memory-Long-Term-Knowledge-with-MemoryService"><a href="#Memory-Long-Term-Knowledge-with-MemoryService" class="headerlink" title="Memory: Long-Term Knowledge with MemoryService"></a>Memory: Long-Term Knowledge with MemoryService</h4><p>A searchable repository of information sourced from various past chats or external sources, serving as a resource for data retrieval beyond the immediate conversation.</p>
<p>The “MemoryService” oversees the storage and retrieval of long-term knowledge. </p>
<p>Session and State can be conceptualized as short-term memory for a single chat session, whereas the Long-Term Knowledge managed by the “MemoryService” functions as a persistent and searchable repository, which may contain information from multiple past interactions or external sources. </p>
<p>The “MemoryService”, as defined by the “BaseMemoryService” interface, establishes a standard for managing this searchable, long-term knowledge. Its primary functions include </p>
<ul>
<li>Adding information, which involves extracting content from a session and storing it using the “add_session_to_memory” method, </li>
<li>Retrieving information, which allows an agent to query the store and receive relevant data using the “search_memory” method.</li>
</ul>
<p>The ADK offers several implementations for creating this long-term knowledge store. </p>
<ul>
<li>The “InMemoryMemoryService” provides a temporary storage solution suitable for testing purposes, but data is not preserved across application restarts. </li>
<li>For production environments, the “VertexAiRagMemoryService” is typically utilized. This service leverages Google Cloud’s Retrieval Augmented Generation (RAG) service, enabling scalable, persistent, and semantic search capabilities. </li>
</ul>
<h3 id="LangChain-and-LangGraph"><a href="#LangChain-and-LangGraph" class="headerlink" title="LangChain and LangGraph"></a>LangChain and LangGraph</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li>ChatMessageHistory: Manual Memory Management<ul>
<li>For direct and simple control over a conversation’s history outside of a formal chain, this method allows for the manual tracking of dialogue exchanges.</li>
</ul>
</li>
<li>ConversationBufferMemory(perhaps abandoned): Automated Memory for Chains<ul>
<li>For integrating memory directly into chains, this method is a common choice. It holds a buffer of the conversation and makes it available to your prompt. Its behavior can be customized with two key parameters:<ul>
<li>“memory_key”: A string that specifies the variable name in your prompt that will hold the chat history. It defaults to “history”</li>
<li>“return_messages”: A boolean that dictates the format of the history. <ul>
<li>If False (the default), it returns a single formatted string, which is ideal for standard LLMs.</li>
<li>If True, it returns a list of message objects, which is the recommended format for Chat Models.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Short-Term-Memory"><a href="#Short-Term-Memory" class="headerlink" title="Short-Term Memory"></a>Short-Term Memory</h4><p>This is thread-scoped, meaning it tracks the ongoing conversation within a single session or thread. It provides immediate context, but a full history can challenge an LLM’s context window, potentially leading to errors or poor performance. </p>
<p>LangGraph manages short-term memory as part of the agent’s state, which is persisted via a checkpointer, allowing a thread to be resumed at any time.</p>
<h4 id="Long-Term-Memory"><a href="#Long-Term-Memory" class="headerlink" title="Long-Term Memory"></a>Long-Term Memory</h4><p>This stores user-specific or application-level data across sessions and is shared between conversational threads. It is saved in custom “namespaces” and can be recalled at any time in any thread. </p>
<p>LangGraph provides stores to save and recall long-term memories, enabling agents to retain knowledge indefinitely. It stores long-term memories as JSON documents in a store. Each memory is organized under a custom namespace (like a folder) and a distinct key (like a file name). This hierarchical structure allows for easy organization and retrieval of information. </p>
<ul>
<li>Semantic Memory: Remembering Facts<ul>
<li>This involves retaining specific facts and concepts, such as user preferences or domain knowledge. </li>
<li>It is used to ground an agent’s responses, leading to more personalized and relevant interactions. </li>
<li>This information can be managed as a continuously updated user “profile” (a JSON document) or as a “collection” of individual factual documents.</li>
</ul>
</li>
<li>Episodic Memory: Remembering Experiences<ul>
<li>This involves recalling past events or actions. </li>
<li>For AI agents, episodic memory is often used to remember how to accomplish a task. </li>
<li>In practice, it is frequently implemented through few-shot example prompting, where an agent learns from past successful interaction sequences to perform tasks correctly.</li>
</ul>
</li>
<li>Procedural Memory: Remembering Rules<ul>
<li>This is the memory of how to perform tasks —— the agent’s core instructions and behaviors, often contained in its system prompt. It is common for agents to modify their own prompts to adapt and improve. </li>
<li>An effective technique is “Reflection”, where an agent is prompted with its current instructions and recent interactions, then asked to refine its own instructions.</li>
</ul>
</li>
</ul>
<h3 id="Vertex-Memory-Bank"><a href="#Vertex-Memory-Bank" class="headerlink" title="Vertex Memory Bank"></a>Vertex Memory Bank</h3><p>Memory Bank, a managed service in the Vertex AI Agent Engine, provides agents with persistent, long-term memory. The service uses Gemini models to asynchronously analyze conversation histories to extract key facts and user preferences. </p>
<p>This information is stored persistently, organized by a defined scope like user ID, and intelligently updated to consolidate new data and resolve contradictions. </p>
<p>Upon starting a new session, the agent retrieves relevant memories through either a full data recall or a similarity search using embeddings. This process allows an agent to maintain continuity across sessions and personalize responses based on recalled information.</p>
<p>The agent’s runner interacts with the VertexAiMemoryBankService, which is initialized first. This service handles the automatic storage of memories generated during the agent’s conversations. Each memory is tagged with a unique “USER_ID” and “APP_NAME”, ensuring accurate retrieval in the future.</p>
<ul>
<li>Memory Bank offers seamless integration with the Google ADK, providing an immediate out-of-the-box experience. </li>
<li>For users of other agent frameworks, such as LangGraph and CrewAI, Memory Bank also offers support through direct API calls. </li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Agent/">Agent</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/09/08/Agent/2025-09-08-7_Multi_Agent_Collaboration/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">7. Multi-Agent Collaboration</div></div></a></div><div class="next-post pull-right"><a href="/2025/09/14/Agent/2025-09-14-9_Learning_and_Adaptation/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">9_Learning_and_Adaptation</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/09/07/Agent/2025-09-07-2_Routing/" title="2. Routing"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-07</div><div class="title">2. Routing</div></div></a></div><div><a href="/2025/09/07/Agent/2025-09-07-1_Prompt_Chaining/" title="1. Prompt Chaining"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-07</div><div class="title">1. Prompt Chaining</div></div></a></div><div><a href="/2025/09/08/Agent/2025-09-08-3_Parallelization/" title="3. Parallelization"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="title">3. Parallelization</div></div></a></div><div><a href="/2025/09/08/Agent/2025-09-08-4_Reflection/" title="4. Reflection"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="title">4. Reflection</div></div></a></div><div><a href="/2025/09/08/Agent/2025-09-08-5_Tool_Use/" title="5. Tool_Use"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="title">5. Tool_Use</div></div></a></div><div><a href="/2025/09/08/Agent/2025-09-08-6_Planning/" title="6. Planning"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="title">6. Planning</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Management"><span class="toc-text">Memory Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Definition"><span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Template"><span class="toc-text">Template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applicable-Scenarios"><span class="toc-text">Applicable Scenarios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coding"><span class="toc-text">Coding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Google-ADK"><span class="toc-text">Google ADK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Keeping-Track-of-Each-Chat"><span class="toc-text">Session: Keeping Track of Each Chat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State-The-Session%E2%80%99s-Scratchpad"><span class="toc-text">State: The Session’s Scratchpad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Long-Term-Knowledge-with-MemoryService"><span class="toc-text">Memory: Long-Term Knowledge with MemoryService</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LangChain-and-LangGraph"><span class="toc-text">LangChain and LangGraph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Short-Term-Memory"><span class="toc-text">Short-Term Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Long-Term-Memory"><span class="toc-text">Long-Term Memory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vertex-Memory-Bank"><span class="toc-text">Vertex Memory Bank</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-21_Exploration_and_Discovery/" title="21_Exploration_and_Discovery">21_Exploration_and_Discovery</a><time datetime="2025-09-14T05:24:13.000Z" title="发表于 2025-09-14 13:24:13">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-20_Prioritization/" title="20_Prioritization">20_Prioritization</a><time datetime="2025-09-14T05:23:46.000Z" title="发表于 2025-09-14 13:23:46">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-19_Evaluation_and_Monitoring/" title="19_Evaluation_and_Monitoring">19_Evaluation_and_Monitoring</a><time datetime="2025-09-14T05:23:25.000Z" title="发表于 2025-09-14 13:23:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-18_Guardrails_Safety_Patterns/" title="18_Guardrails_Safety_Patterns">18_Guardrails_Safety_Patterns</a><time datetime="2025-09-14T05:23:02.000Z" title="发表于 2025-09-14 13:23:02">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-17_Reasoning_Techniques/" title="17_Reasoning_Techniques">17_Reasoning_Techniques</a><time datetime="2025-09-14T05:22:31.000Z" title="发表于 2025-09-14 13:22:31">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>