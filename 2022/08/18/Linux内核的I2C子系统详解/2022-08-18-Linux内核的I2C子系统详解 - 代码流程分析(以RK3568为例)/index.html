<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例) | ZJN_BLOG</title><meta name="keywords" content="Linux设备驱动开发,I2C"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Linux内核里的I2C驱动框架 每一个i2c_adapter对应一条实际的I2C总线。在总线上挂载着I2C设备实物，每个I2C设备对应一个i2c_client，一个i2c_client只能挂载在一个i2c_driver。一般来说，一个i2c_driver可以匹配多个i2c_client，会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如write&#x2F;read&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例)">
<meta property="og:url" content="http://zjn-astonishe.github.io/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BB%A5RK3568%E4%B8%BA%E4%BE%8B)/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="1. Linux内核里的I2C驱动框架 每一个i2c_adapter对应一条实际的I2C总线。在总线上挂载着I2C设备实物，每个I2C设备对应一个i2c_client，一个i2c_client只能挂载在一个i2c_driver。一般来说，一个i2c_driver可以匹配多个i2c_client，会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如write&#x2F;read&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2022-08-18T09:34:01.000Z">
<meta property="article:modified_time" content="2024-11-09T04:33:57.462Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="Linux设备驱动开发">
<meta property="article:tag" content="I2C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BB%A5RK3568%E4%B8%BA%E4%BE%8B)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-09 12:33:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-18T09:34:01.000Z" title="发表于 2022-08-18 17:34:01">2022-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-09T04:33:57.462Z" title="更新于 2024-11-09 12:33:57">2024-11-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/I2C/">I2C</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/I2C/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">设备驱动开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Linux内核里的I2C驱动框架"><a href="#1-Linux内核里的I2C驱动框架" class="headerlink" title="1. Linux内核里的I2C驱动框架"></a>1. Linux内核里的I2C驱动框架</h1><p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%9B%BE%E7%89%872.png?raw=true" alt="Linux内核里I2C驱动框架"></p>
<p>每一个i2c_adapter对应一条实际的I2C总线。在总线上挂载着I2C设备实物，每个I2C设备对应一个i2c_client，一个i2c_client只能挂载在一个i2c_driver。一般来说，一个i2c_driver可以匹配多个i2c_client，会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如<code>write/read/ioctl</code>。通过调用i2c_adapter提供的通信方法，完成对I2C设备的操作。</p>
<p>根据上图展示的Linux内核里的I2C驱动框架，可以总结出I2C驱动框架的构建流程如下：</p>
<h2 id="1-1-注册I2C子系统核心层-主要是注册I2C总线"><a href="#1-1-注册I2C子系统核心层-主要是注册I2C总线" class="headerlink" title="1.1. 注册I2C子系统核心层(主要是注册I2C总线)"></a>1.1. 注册I2C子系统核心层(主要是注册I2C总线)</h2><p>I2C作为物理总线，通过调用<code>postcore_initcall()</code>函数将<code>i2c_init()</code>函数注册到系统中，使得在内核启动过程中便会调用初始化函数<code>i2c_init()</code>完成I2C总线注册(SPI同理)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">i2c_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = <span class="built_in">of_alias_get_highest_id</span>(<span class="string">&quot;i2c&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">down_write</span>(&amp;__i2c_board_lock);</span><br><span class="line">	<span class="keyword">if</span> (retval &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">		__i2c_first_dynamic_bus_num = retval + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">up_write</span>(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">	retval = <span class="built_in">bus_register</span>(&amp;i2c_bus_type);       <span class="comment">// 注册I2C总线</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	is_registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	i2c_adapter_compat_class = <span class="built_in">class_compat_register</span>(<span class="string">&quot;i2c-adapter&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_err;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	retval = <span class="built_in">i2c_add_driver</span>(&amp;dummy_driver);         <span class="comment">// 注册一个空驱动</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ENABLED</span>(CONFIG_OF_DYNAMIC))</span><br><span class="line">		<span class="built_in">WARN_ON</span>(<span class="built_in">of_reconfig_notifier_register</span>(&amp;i2c_of_notifier));</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ENABLED</span>(CONFIG_ACPI))</span><br><span class="line">		<span class="built_in">WARN_ON</span>(<span class="built_in">acpi_reconfig_notifier_register</span>(&amp;i2c_acpi_notifier));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	<span class="built_in">class_compat_unregister</span>(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	is_registered = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">bus_unregister</span>(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I2C总线上分别存储了i2c_driver链和i2c_client链。当任何一个i2c_driver或者i2c_client去注册时，I2C总线都会调用<code>i2c_device_match()</code>函数对<code>i2c_client.name</code>和<code>i2c_driver.id_table[].name</code>进行循环匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bus_type</span> i2c_bus_type = &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,         <span class="comment">// 负责总线上的device和driver匹配</span></span><br><span class="line">	.probe		= i2c_device_probe,         <span class="comment">// 在匹配成功后会执行以完成注册的收尾工作</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(i2c_bus_type);        <span class="comment">// 模块导出，可供其他模块使用</span></span><br><span class="line"><span class="comment">// 负责总线上的device和driver匹配的函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client = <span class="built_in">i2c_verify_client</span>(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_driver</span>	*driver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">i2c_of_match_device</span>(drv-&gt;of_match_table, client))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">acpi_driver_match_device</span>(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	driver = <span class="built_in">to_i2c_driver</span>(drv);                    <span class="comment">// 找到i2c_driver</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finally an I2C match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">i2c_match_id</span>(driver-&gt;id_table, client))     <span class="comment">// 用i2c_driver的id_table和device匹配。驱动名多个，但设备名只有一个，说明一个驱动可以对应多个设备(尤其是同一类型)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>i2c_device_match()</code>函数的源码可知：如果<code>i2c_driver.id_table[]</code>中没有能够和<code>client</code>匹配的，函数将直接返回。如果能够匹配，则返回1。并且I2C总线在后续会调用<code>probe()</code>函数完成注册的收尾工作。</p>
<p>但是要搞清楚<code>match()</code>和<code>probe()</code>函数是何时被何者所调用的，则还需进行深入了解。根据描述知道<code>probe()</code>函数执行于<code>match()</code>函数之后，且匹配触发的前提是要有i2c_driver或者i2c_client注册。所以尝试从i2c_driver的注册代码中寻找答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span></span><br><span class="line"><span class="comment"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">module</span> *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;driver-&gt;clients);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">	 * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = <span class="built_in">driver_register</span>(&amp;driver-&gt;driver);     <span class="comment">// 实际注册位置</span></span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_register_driver);</span><br></pre></td></tr></table></figure>
<p>注意到<code>i2c_register_driver</code>函数中实际是调用了<code>driver_register()</code>函数完成注册，继续寻找函数中有关总线的调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/driver.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_register - register driver with bus</span></span><br><span class="line"><span class="comment"> * @drv: driver to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We pass off most of the work to the bus_add_driver() call,</span></span><br><span class="line"><span class="comment"> * since most of the things we have to do deal with the bus</span></span><br><span class="line"><span class="comment"> * structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	ret = <span class="built_in">bus_add_driver</span>(drv);              <span class="comment">// 在总线上添加传递的驱动(将驱动添加到总线的驱动链表中)</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(driver_register);</span><br></pre></td></tr></table></figure>
<p><code>driver_register()</code>函数中调用了<code>bus_add_driver()</code>函数，将驱动添加到总线上，持续跟踪直到找到有关<code>match</code>和<code>probe</code>的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bus_add_driver</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe)     <span class="comment">// 提到probe</span></span><br><span class="line">    &#123;</span><br><span class="line">		error = <span class="built_in">driver_attach</span>(drv);         <span class="comment">// 跟踪driver_attach();</span></span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_attach - try to bind driver to devices.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Walk the list of devices that the bus has on it and try to</span></span><br><span class="line"><span class="comment"> * match the driver with each one.  If driver_probe_device()</span></span><br><span class="line"><span class="comment"> * returns 0 and the @dev-&gt;driver is set, we&#x27;ve found a</span></span><br><span class="line"><span class="comment"> * compatible pair.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bus_for_each_dev</span>(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);  <span class="comment">// 继续跟踪发现实际是在调用__driver_attach();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(driver_attach);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_for_each_dev - device iterator.</span></span><br><span class="line"><span class="comment"> * @bus: bus type.</span></span><br><span class="line"><span class="comment"> * @start: device to start iterating from.</span></span><br><span class="line"><span class="comment"> * @data: data for the callback.</span></span><br><span class="line"><span class="comment"> * @fn: function to be called for each device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over @bus&#x27;s list of devices, and call @fn for each,</span></span><br><span class="line"><span class="comment"> * passing it @data. If @start is not NULL, we use that device to</span></span><br><span class="line"><span class="comment"> * begin iterating from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We check the return of @fn each time. If it returns anything</span></span><br><span class="line"><span class="comment"> * other than 0, we break out and return that value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> The device that returns a non-zero value is not retained</span></span><br><span class="line"><span class="comment"> * in any way, nor is its refcount incremented. If the caller needs</span></span><br><span class="line"><span class="comment"> * to retain this data, it should do so, and increment the reference</span></span><br><span class="line"><span class="comment"> * count in the supplied callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bus_for_each_dev</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> device *start,</span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="type">void</span> *data, <span class="type">int</span> (*fn)(<span class="keyword">struct</span> device *, <span class="type">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">klist_iter</span> i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bus || !bus-&gt;p)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">klist_iter_init_node</span>(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,</span><br><span class="line">			     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class="literal">NULL</span>));	<span class="comment">// 	链表头开始遍历连接在总线上的设备链表</span></span><br><span class="line">	<span class="keyword">while</span> (!error &amp;&amp; (dev = <span class="built_in">next_device</span>(&amp;i)))</span><br><span class="line">		error = <span class="built_in">fn</span>(dev, data);</span><br><span class="line">	<span class="built_in">klist_iter_exit</span>(&amp;i);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(bus_for_each_dev);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __driver_attach(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_driver</span> *drv = data;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock device and try to bind to it. We drop the error</span></span><br><span class="line"><span class="comment">	 * here and always return 0, because we need to keep trying</span></span><br><span class="line"><span class="comment">	 * to bind to devices and some drivers will return an error</span></span><br><span class="line"><span class="comment">	 * simply if it didn&#x27;t support the device.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * driver_probe_device() will spit a warning if there</span></span><br><span class="line"><span class="comment">	 * is an error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">driver_match_device</span>(drv, dev);        <span class="comment">// 驱动和设备匹配</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* no match */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">		<span class="built_in">driver_deferred_probe_add</span>(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Bus failed to match device: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">device_driver_attach</span>(drv, dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_driver_attach - attach a specific driver to a specific device</span></span><br><span class="line"><span class="comment"> * @drv: Driver to attach</span></span><br><span class="line"><span class="comment"> * @dev: Device to attach it to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Manually attach driver to a device. Will acquire both @dev lock and</span></span><br><span class="line"><span class="comment"> * @dev-&gt;parent lock if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">device_driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	__device_driver_lock(dev, dev-&gt;parent);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If device has been removed or someone has already successfully</span></span><br><span class="line"><span class="comment">	 * bound a driver before us just skip the driver probe call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)</span><br><span class="line">		ret = <span class="built_in">driver_probe_device</span>(drv, dev);</span><br><span class="line">	__device_driver_unlock(dev, dev-&gt;parent);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_probe_device - attempt to bind device &amp; driver together</span></span><br><span class="line"><span class="comment"> * @drv: driver to bind a device to</span></span><br><span class="line"><span class="comment"> * @dev: device to try to bind to the driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns -ENODEV if the device is not registered,</span></span><br><span class="line"><span class="comment"> * 1 if the device is bound successfully and 0 otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be called with @dev lock held.  When called for a</span></span><br><span class="line"><span class="comment"> * USB interface, @dev-&gt;parent lock must be held as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the device has a parent, runtime-resume the parent before driver probing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_probe_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">pm_runtime_barrier</span>(dev);</span><br><span class="line">	<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">		ret = <span class="built_in">really_probe_debug</span>(dev, drv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = <span class="built_in">really_probe</span>(dev, drv);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/base.h */</span> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;<span class="built_in">match</span>(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，可知是<code>driver_match_device</code>函数调用了I2C总线的<code>match()</code>函数完成对驱动和设备的匹配工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">really_probe</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;<span class="built_in">probe</span>(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;<span class="built_in">probe</span>(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client = <span class="built_in">i2c_verify_client</span>(dev);   <span class="comment">// 设备</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_driver</span>	*driver;                            <span class="comment">// 驱动</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)           <span class="comment">// 找不到设备，失败，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	client-&gt;irq = client-&gt;init_irq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">		<span class="type">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY) &#123;</span><br><span class="line">			<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Using Host Notify IRQ\n&quot;</span>);</span><br><span class="line">			<span class="comment">/* Keep adapter active when Host Notify is required */</span></span><br><span class="line">			<span class="built_in">pm_runtime_get_sync</span>(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line">			irq = <span class="built_in">i2c_smbus_host_notify_to_irq</span>(client);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">			irq = <span class="built_in">of_irq_get_byname</span>(dev-&gt;of_node, <span class="string">&quot;irq&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (irq == -EINVAL || irq == -ENODATA)</span><br><span class="line">				irq = <span class="built_in">of_irq_get</span>(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ACPI_COMPANION</span>(dev)) &#123;</span><br><span class="line">			irq = <span class="built_in">i2c_acpi_get_irq</span>(client);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = irq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">			irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		client-&gt;irq = irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	driver = <span class="built_in">to_i2c_driver</span>(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * An I2C ID table is not mandatory, if and only if, a suitable OF</span></span><br><span class="line"><span class="comment">	 * or ACPI ID table is supplied for the probing device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;id_table &amp;&amp;</span><br><span class="line">	    !<span class="built_in">acpi_driver_match_device</span>(dev, dev-&gt;driver) &amp;&amp;</span><br><span class="line">	    !<span class="built_in">i2c_of_match_device</span>(dev-&gt;driver-&gt;of_match_table, client)) &#123;</span><br><span class="line">		status = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">		<span class="type">int</span> wakeirq;</span><br><span class="line"></span><br><span class="line">		wakeirq = <span class="built_in">of_irq_get_byname</span>(dev-&gt;of_node, <span class="string">&quot;wakeup&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (wakeirq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = wakeirq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">device_init_wakeup</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span> &amp;&amp; wakeirq != client-&gt;irq)</span><br><span class="line">			status = <span class="built_in">dev_pm_set_dedicated_wake_irq</span>(dev, wakeirq);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">			status = <span class="built_in">dev_pm_set_wake_irq</span>(dev, client-&gt;irq);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">			<span class="built_in">dev_warn</span>(&amp;client-&gt;dev, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">of_clk_set_defaults</span>(dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">dev_pm_domain_attach</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过函数指针的方式调用了i2c_driver的probe函数。即当一个device和一个driver匹配上以后还会去执行driver里面的probe函数完成i2c_driver注册的收尾工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * When there are no more users of probe(),</span></span><br><span class="line"><span class="comment">	 * rename probe_new to probe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;probe_new)</span><br><span class="line">		status = driver-&gt;<span class="built_in">probe_new</span>(client);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (driver-&gt;probe)</span><br><span class="line">		status = driver-&gt;<span class="built_in">probe</span>(client,</span><br><span class="line">				       <span class="built_in">i2c_match_id</span>(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		status = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">	<span class="built_in">dev_pm_domain_detach</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">	<span class="built_in">dev_pm_clear_wake_irq</span>(&amp;client-&gt;dev);</span><br><span class="line">	<span class="built_in">device_init_wakeup</span>(&amp;client-&gt;dev, <span class="literal">false</span>);</span><br><span class="line">put_sync_adapter:</span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY)</span><br><span class="line">		<span class="built_in">pm_runtime_put_sync</span>(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合<code>really_probe()</code>函数和I2C总线的<code>i2c_device_probe()</code>函数，可以知道是i2c_driver在注册的过程中调用了<code>really_probe()</code>函数从而调用I2C总线的<code>i2c_device_probe()</code>函数，进而调用i2c_driver自己的<code>probe()</code>函数，从而完成硬件初始化等后续工作。</p>
<h2 id="1-2-注册i2c-adapter并将其添加到I2C总线"><a href="#1-2-注册i2c-adapter并将其添加到I2C总线" class="headerlink" title="1.2. 注册i2c_adapter并将其添加到I2C总线"></a>1.2. 注册i2c_adapter并将其添加到I2C总线</h2><p><code>i2c_adapter</code>在硬件上对应Soc的I2C控制器，在内核中被认为是一个设备，而其对应驱动即是总线驱动。它向接在I2C控制器上的I2C设备提供在I2C总线上通信的基础方法，通过操作Soc的I2C控制器相关的寄存器实现数据收发。<code>i2c_adapter</code>一般通过两种方法注册：</p>
<ul>
<li>一种做法是为I2C适配器创建一个platform设备注册到<code>platform_bus_type</code>总线上与I2C适配器的platform驱动匹配，在驱动的probe函数中向I2C总线添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
<li>另一种做法是I2C适配器作为pci设备注册到PCI总线上与I2C适配器的pci驱动匹配，在驱动的probe函数中向i2c_bus_type添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
</ul>
<p>RK平台采用的是第一种方法。总线驱动的文件存储在路径<code>/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses</code>中，RK平台的总线驱动文件为<code>i2c-rk3x.c</code>。</p>
<h3 id="1-2-1-关键数据结构定义"><a href="#1-2-1-关键数据结构定义" class="headerlink" title="1.2.1. 关键数据结构定义"></a>1.2.1. 关键数据结构定义</h3><ul>
<li>总线驱动定义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> rk3x_i2c_driver = &#123;</span><br><span class="line">    <span class="comment">/** .probe()：</span></span><br><span class="line"><span class="comment">     * 当驱动注册完毕，并且匹配成功，则会自动调用该方法对硬件进行初始化操作：</span></span><br><span class="line"><span class="comment">     * a. 注册设备号，并且注册fops(为用户提供设备标示，同时提供文件操作io接口)</span></span><br><span class="line"><span class="comment">     * b. 创建设备节点</span></span><br><span class="line"><span class="comment">     * c. 初始化硬件的各项信息，如ioremap(io地址映射虚拟地址)</span></span><br><span class="line"><span class="comment">     * d. 实现各种io功能接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    .probe   = rk3x_i2c_probe,      </span><br><span class="line">    .remove  = rk3x_i2c_remove,</span><br><span class="line">    .driver  = &#123;</span><br><span class="line">        .name  = <span class="string">&quot;rk3x-i2c&quot;</span>,                <span class="comment">// 用于驱动和设备匹配，确保驱动和设备一致，否则无法匹配成功</span></span><br><span class="line">        .of_match_table = rk3x_i2c_match,   <span class="comment">// 匹配表</span></span><br><span class="line">        .pm = &amp;rk3x_i2c_pm_ops,	            <span class="comment">// dev_pm_ops类型的结构体，用来赋值设备完成运行时的电源管理</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>总线驱动通信方法定义<blockquote>
<p>因为每家芯片厂商SoC内部的I2C控制器是不一样的，所以 <code>i2c_algorithm</code> 中直接涉及硬件层面上的代码都是由芯片商提供。例如：对I2C控制器的寄存器操作。 <code>i2c_algorithm</code> 提供的通信函数控制适配器产生特定的访问信号，虽然不同的I2C总线控制器被抽象成不同的 <code>i2c_adapter</code> ，但是如果操作方式相同，则可以共享同一个 <code>i2c_algorithm</code> 。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 总线驱动通信方法定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> rk3x_i2c_algorithm = &#123;</span><br><span class="line">    .master_xfer		= rk3x_i2c_xfer,            <span class="comment">// 通信方法，如果不支持I2C访问，则为NULL</span></span><br><span class="line">    .master_xfer_atomic	= rk3x_i2c_xfer_polling,            <span class="comment">// 通信方法，仅使用于原子上下文</span></span><br><span class="line">    .functionality		= rk3x_i2c_func,            <span class="comment">// 检测通信方法支持的功能或协议，设备驱动一般会调用这个回调来确认适配器支持的协议类型</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-设备树信息"><a href="#1-2-2-设备树信息" class="headerlink" title="1.2.2. 设备树信息"></a>1.2.2. 设备树信息</h3><p>RK3568共有6个I2C控制器，分别为I2C0~I2C5，每个控制器对应不同的寄存器基地址(i2c0是0xfdd40000)， <code>.compatible</code> 属性都是 <code>rockchip, rk3399-i2c</code> ，即对应了同一个adapter驱动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi */</span></span><br><span class="line">    i2c0: i2c@fdd40000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd40000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;  <span class="comment">// 起始地址0xfdd40000, 长度0x10000</span></span><br><span class="line">        clocks = &lt;&amp;pmucru CLK_I2C0&gt;, &lt;&amp;pmucru PCLK_I2C0&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">46</span> IRQ_TYPE_LEVEL_HIGH&gt;;  <span class="comment">// 中断和触发方式</span></span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;   <span class="comment">//表示用一个32位的数来描述地址</span></span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;      <span class="comment">//表示用0个32位的数来描述该地址的大小</span></span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;    <span class="comment">// 目前状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">    i2c1: i2c@fe5a0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5a0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C1&gt;, &lt;&amp;cru PCLK_I2C1&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">47</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c1_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c2: i2c@fe5b0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5b0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C2&gt;, &lt;&amp;cru PCLK_I2C2&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">48</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c2m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c3: i2c@fe5c0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5c0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C3&gt;, &lt;&amp;cru PCLK_I2C3&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">49</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c3m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c4: i2c@fe5d0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5d0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C4&gt;, &lt;&amp;cru PCLK_I2C4&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">50</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c4m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c5: i2c@fe5e0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5e0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C5&gt;, &lt;&amp;cru PCLK_I2C5&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">51</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c5m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 <code>rk3x_i2c_driver</code> 作为一个 <code>platform_driver</code> 注册到内核， <code>rk3x_i2c_match</code> 作为结构体中的参数实际是一个记录设备信息的结构体数组。系统启动后会比较DTS中的匹配属性与驱动匹配表中是否相符，如果相符则会进入 <code>rk3x_i2c_probe</code> 接口，完成驱动各项参数的初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// rk3x_i2c_driver结构体中.driver的匹配表参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> rk3x_i2c_match[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1108-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1108_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1126-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1126_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3066-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3066_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3188-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3188_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3228-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3228_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3288-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3288_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>, <span class="comment">// 符合DTS中描述的匹配字符串</span></span><br><span class="line">        .data = &amp;rk3399_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param usb               设备名</span></span><br><span class="line"><span class="comment"> * @param skel_table        该设备加入到模块中时对应产生的设备搜索符号</span></span><br><span class="line"><span class="comment"> * @return 生成一个名为__mod_pci_device_table局部变量，这个变量指向第二个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">MODULE_DEVICE_TABLE</span>(of, rk3x_i2c_match); <span class="comment">// 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-注册和卸载i2c-adapter"><a href="#1-2-3-注册和卸载i2c-adapter" class="headerlink" title="1.2.3. 注册和卸载i2c_adapter"></a>1.2.3. 注册和卸载i2c_adapter</h3><p>为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 <code>module_platform_driver</code> 替换 <code>module_init</code> 和 <code>module_exit</code> (实际还要调用一次宏定义函数 <code>module_driver</code> 才能完成替换)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/platform_device.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_platform_driver() - Helper macro for drivers that don&#x27;t do</span></span><br><span class="line"><span class="comment"> * anything special in module init/exit.  </span></span><br><span class="line"><span class="comment"> * This eliminates a lot of boilerplate.  </span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and</span></span><br><span class="line"><span class="comment"> * calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_platform_driver(__platform_driver) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="built_in">module_driver</span>(__platform_driver, platform_driver_register, \</span><br><span class="line">            platform_driver_unregister)</span><br><span class="line">			</span><br><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/device/driver.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in module init/exit. This eliminates a lot of boilerplate.</span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * module_init() and module_exit().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @__unregister: unregister function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register and __unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta"><span class="comment">// 注册方法，替代module_init()</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init __driver##_init(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_init</span>(__driver##_init); \</span><br><span class="line"><span class="comment">// 卸载方法，替代module_exit()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __driver##_exit(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_exit</span>(__driver##_exit); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-i2c-adapter相关函数配置"><a href="#1-2-4-i2c-adapter相关函数配置" class="headerlink" title="1.2.4. i2c_adapter相关函数配置"></a>1.2.4. i2c_adapter相关函数配置</h3><ul>
<li>注册收尾函数probe()</li>
</ul>
<blockquote>
<p><code>platform_driver</code> 在注册时会遍历 <code>platform</code> 总线上的 <code>platform_device</code> ，当条件( <code>.compatible</code> 属性或 <code>id_table</code> )匹配(通过得分机制，得分最高的最终会匹配成功)时，便会调用 <code>rk3x_i2c_probe</code> 函数。如何调用参考上文总线部分的<code>i2c_driver</code>的<code>probe()</code>函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> *match;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c;	<span class="comment">// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u32 value;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> clk_rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作</span></span><br><span class="line"><span class="comment">     * devm_kzalloc — Resource-managed kzalloc</span></span><br><span class="line"><span class="comment">     * @param pdev: 申请内存的目标设备</span></span><br><span class="line"><span class="comment">     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。</span></span><br><span class="line"><span class="comment">     * @return: 成功返回首地址，失败返回NULL</span></span><br><span class="line"><span class="comment">     * 为适配器结构体申请内存，为后续实例化完成基础工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> rk3x_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (!i2c)	<span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到rk3x_i2c_match数组里与之匹配的那个struct of_device_id</span></span><br><span class="line"><span class="comment">     * i2c_adapter驱动会兼容多个RK平台(如rk3188/rk3288/rk3399等)的i2c控制器，</span></span><br><span class="line"><span class="comment">     * 各个平台有些差异，差异性的信息可以通过.data这个成员指针保存起来，用到的时候再取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = <span class="built_in">of_match_node</span>(rk3x_i2c_match, np); </span><br><span class="line">    <span class="comment">// 取出所匹配的i2c控制器的配置信息</span></span><br><span class="line">    i2c-&gt;soc_data = match-&gt;data; </span><br><span class="line">    <span class="comment">/* use common interface to get I2C timing properties */</span></span><br><span class="line">    <span class="built_in">i2c_parse_fw_timings</span>(&amp;pdev-&gt;dev, &amp;i2c-&gt;t, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// i2c_adapter部分成员初始化</span></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">strlcpy</span>(i2c-&gt;adap.name, <span class="string">&quot;rk3x-i2c&quot;</span>, <span class="built_in">sizeof</span>(i2c-&gt;adap.name));</span><br><span class="line">    <span class="comment">// 拥有者</span></span><br><span class="line">    i2c-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">// 通信方法</span></span><br><span class="line">    i2c-&gt;adap.algo = &amp;rk3x_i2c_algorithm;</span><br><span class="line">    i2c-&gt;adap.retries = <span class="number">3</span>;</span><br><span class="line">    i2c-&gt;adap.dev.of_node = np;</span><br><span class="line">    i2c-&gt;adap.algo_data = i2c;</span><br><span class="line">    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">    i2c-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;i2c-&gt;lock);</span><br><span class="line">    <span class="comment">// 初始化等待队列头部，等待在进程调度中使用</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;i2c-&gt;wait);</span><br><span class="line">    <span class="comment">// 通知链机制，在内核重启之前会调用回调函数rk3x_i2c_restart_notify</span></span><br><span class="line">    i2c-&gt;i2c_restart_nb.notifier_call = rk3x_i2c_restart_notify;</span><br><span class="line">    i2c-&gt;i2c_restart_nb.priority = <span class="number">128</span>;</span><br><span class="line">    ret = <span class="built_in">register_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;failed to setup i2c restart handler.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从dts中获取设备的物理基址</span></span><br><span class="line">    i2c-&gt;regs = <span class="built_in">devm_platform_ioremap_resource</span>(pdev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;regs))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(i2c-&gt;regs);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Switch to new interface if the SoC also offers the old one.</span></span><br><span class="line"><span class="comment">	 * The control bit is located in the GRF register space.</span></span><br><span class="line"><span class="comment">	 * grf_offset: offset inside the grf regmap for setting the i2c type</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;grf_offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">regmap</span> *grf; </span><br><span class="line">        grf = <span class="built_in">syscon_regmap_lookup_by_phandle</span>(np, <span class="string">&quot;rockchip,grf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(grf)) &#123;</span><br><span class="line">            <span class="type">int</span> bus_nr;</span><br><span class="line">            <span class="comment">/* Try to set the I2C adapter number from dt */</span></span><br><span class="line">            bus_nr = <span class="built_in">of_alias_get_id</span>(np, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bus_nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;rk3x-i2c needs i2cX alias&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1108_soc_data &amp;&amp; bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1108 i2c2 set grf offset-0x408, bit-10 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">26</span>) | <span class="built_in">BIT</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1126_soc_data &amp;&amp;</span><br><span class="line">                    bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1126 i2c2 set pmugrf offset-0x118, bit-4 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">20</span>) | <span class="built_in">BIT</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* rk3xxx 27+i: write mask, 11+i: value */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">27</span> + bus_nr) | <span class="built_in">BIT</span>(<span class="number">11</span> + bus_nr);</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">regmap_write</span>(grf, i2c-&gt;soc_data-&gt;grf_offset,</span><br><span class="line">                        value);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;Could not write to GRF: %d\n&quot;</span>,</span><br><span class="line">                    ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* IRQ setup(中断设置) */</span></span><br><span class="line">    irq = <span class="built_in">platform_get_irq</span>(pdev, <span class="number">0</span>);	<span class="comment">// platform_device结构体中存储有所用到的中断号</span></span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> irq;</span><br><span class="line">    ret = <span class="built_in">devm_request_irq</span>(&amp;pdev-&gt;dev, irq, rk3x_i2c_irq,</span><br><span class="line">                    <span class="number">0</span>, <span class="built_in">dev_name</span>(&amp;pdev-&gt;dev), i2c);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;cannot request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储用户主动申请的内存区域指针防止丢失</span></span><br><span class="line">    <span class="built_in">platform_set_drvdata</span>(pdev, i2c);</span><br><span class="line">    <span class="comment">// 平台时钟设置</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;calc_timings == rk3x_i2c_v0_calc_timings) &#123;</span><br><span class="line">        <span class="comment">/* Only one clock to use for bus clock and peripheral clock */</span></span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">        i2c-&gt;pclk = i2c-&gt;clk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        i2c-&gt;pclk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;clk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;clk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get bus clk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;pclk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;pclk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get periph clk\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare bus clk: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare periph clock: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> err_clk;</span><br><span class="line">    &#125;</span><br><span class="line">    i2c-&gt;clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;</span><br><span class="line">    ret = <span class="built_in">clk_notifier_register</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to register clock notifier\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_pclk;</span><br><span class="line">    &#125;</span><br><span class="line">    clk_rate = <span class="built_in">clk_get_rate</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">rk3x_i2c_adapt_div</span>(i2c, clk_rate);</span><br><span class="line">    <span class="comment">// 向内核添加i2c_adapter</span></span><br><span class="line">    ret = <span class="built_in">i2c_add_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err_clk_notifier;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clk_notifier:</span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">err_pclk:</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">err_clk:</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放函数remove()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得rk3x_i2c_probe中存储的主动申请的内存区域指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = <span class="built_in">platform_get_drvdata</span>(pdev);</span><br><span class="line">    <span class="comment">// 卸载i2c_adapter</span></span><br><span class="line">    <span class="built_in">i2c_del_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销时钟</span></span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="built_in">unregister_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb); </span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通信方法函数master_xfer()</li>
</ul>
<blockquote>
<p>实现总线上数据传输，rk3x_i2c提供了两种方式来处理阻塞进程唤醒。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 使用等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_polling</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num, <span class="type">bool</span> polling)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = (<span class="keyword">struct</span> rk3x_i2c *)adap-&gt;algo_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> timeout, flags;</span><br><span class="line">    u32 val;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;suspended)</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 使能时钟</span></span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">    i2c-&gt;is_last_msg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * Process msgs. We can handle more than one message at once (see</span></span><br><span class="line"><span class="comment">        * rk3x_i2c_setup()).</span></span><br><span class="line"><span class="comment">        * i+ret就是指一次循环处理多条msg</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i += ret) &#123;</span><br><span class="line">        ret = <span class="built_in">rk3x_i2c_setup</span>(i2c, msgs + i, num - i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i2c msg处理出错</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;rk3x_i2c_setup() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ret为本轮已处理的msgs数量，i为过去已处理的msgs数量，如果刚好等于msgs总数，则</span></span><br><span class="line">        <span class="keyword">if</span> (i + ret &gt;= num)</span><br><span class="line">            i2c-&gt;is_last_msg = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 启动i2c_adapter</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_start</span>(i2c);	</span><br><span class="line">        <span class="comment">// 释放自旋锁，并恢复标志寄存器的值为变量flags保存的值</span></span><br><span class="line">        <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区分调用的是rk3x_i2c_xfer还是rk3x_i2c_xfer_polling</span></span><br><span class="line">        <span class="keyword">if</span> (!polling) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                * 调用rk3x_i2c_xfer, 挂起等待队列头i2c-&gt;wait(wait_queue_head_t)。</span></span><br><span class="line"><span class="comment">                * 直到i2c_adapter不再繁忙或者等待超时，则调用wake_up(i2c-&gt;wait)会唤醒进程并继续往下执行</span></span><br><span class="line"><span class="comment">                * 如果未超时且i2c_adapter繁忙，则进程会被阻塞</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">            timeout = <span class="built_in">wait_event_timeout</span>(i2c-&gt;wait, !i2c-&gt;busy,</span><br><span class="line">                                <span class="built_in">msecs_to_jiffies</span>(WAIT_TIMEOUT));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">rk3x_i2c_wait_xfer_poll</span>(i2c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得自旋锁，并且备份本地中断和中断状态到flags变量</span></span><br><span class="line">        <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时了</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;timeout, ipd: 0x%02x, state: %d\n&quot;</span>,</span><br><span class="line">                <span class="built_in">i2c_readl</span>(i2c, REG_IPD), i2c-&gt;state);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Force a STOP condition without interrupt */</span></span><br><span class="line">            <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">            val = <span class="built_in">i2c_readl</span>(i2c, REG_CON) &amp; REG_CON_TUNING_MASK;</span><br><span class="line">            val |= REG_CON_EN | REG_CON_STOP;</span><br><span class="line">            <span class="built_in">i2c_writel</span>(i2c, val, REG_CON);</span><br><span class="line"></span><br><span class="line">            i2c-&gt;state = STATE_IDLE;</span><br><span class="line"></span><br><span class="line">            ret = -ETIMEDOUT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时，但是i2c_adapter运行中产生错误</span></span><br><span class="line">        <span class="keyword">if</span> (i2c-&gt;error) &#123;</span><br><span class="line">            ret = i2c-&gt;error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺利完成i2c通信？</span></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭i2c总线</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭时钟</span></span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;clk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出错返回ret，成功返回处理msgs的数量</span></span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_wait_xfer_poll</span><span class="params">(<span class="keyword">struct</span> rk3x_i2c *i2c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ktime_get()得到当前时间，ktime_add_ms来设置超时时间。</span></span><br><span class="line">    <span class="type">ktime_t</span> timeout = <span class="built_in">ktime_add_ms</span>(<span class="built_in">ktime_get</span>(), WAIT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * READ_ONCE是一个用来读取变量的宏，为了避免编译器优化导致多线程时读取出错而编写</span></span><br><span class="line"><span class="comment">        * ktime_compare用来确定是否超时</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">READ_ONCE</span>(i2c-&gt;busy) &amp;&amp;</span><br><span class="line">            <span class="built_in">ktime_compare</span>(<span class="built_in">ktime_get</span>(), timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没超时且i2c_adapter繁忙，则延时等待</span></span><br><span class="line">        <span class="built_in">udelay</span>(<span class="number">5</span>); </span><br><span class="line">        <span class="comment">// 设置中断</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_irq</span>(<span class="number">0</span>, i2c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回i2c_adapter的状态</span></span><br><span class="line">    <span class="keyword">return</span> !i2c-&gt;busy; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>功能检测函数func()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 无格式i2c-level命令(Pure SMBus适配器不能用这些命令)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="comment">// 处理所有的能够被I2C adapter仿真的SMBus命令(RK平台的控制器兼容I2C与SMBus总线)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE | \</span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WORD_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PROC_CALL | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_I2C_BLOCK | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PEC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟知的有I2C_M_IGNORE_NAK, I2C_M_REV_DIR_ADDR, I2C_M_NOSTART, I2C_MNO_RD_ACK等flags(I2C寄存器状态？)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 <span class="comment">/* I2C_M_IGNORE_NAK etc. */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_quick命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="comment">//  处理SMBus read_byte &amp; write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data &amp; write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data &amp; write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus process_call命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="comment">// 处理SMBus wrtie_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data &amp; write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 <span class="comment">/* I2C-like block xfer  */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 <span class="comment">/* w/ 1-byte reg. addr. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出所支持的命令集(检测通信方法支持的功能或协议)</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">rk3x_i2c_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-添加到I2C总线"><a href="#1-2-5-添加到I2C总线" class="headerlink" title="1.2.5. 添加到I2C总线"></a>1.2.5. 添加到I2C总线</h3><p>I2C核心层为i2c_adapter开放了添加适配器的接口函数i2c_add_adapter()。在注册收尾工作<code>rk3x_i2c_probe()</code>函数的最后，调用<code>i2c_add_adapter()</code>函数向I2C总线添加i2c_adapter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter - declare i2c adapter, use dynamic bus number</span></span><br><span class="line"><span class="comment"> * @adapter: the adapter to add</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine is used to declare an I2C adapter when its bus number</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t matter or when its bus number is specified by an dt alias.</span></span><br><span class="line"><span class="comment"> * Examples of bases when the bus number doesn&#x27;t matter: I2C adapters</span></span><br><span class="line"><span class="comment"> * dynamically added by USB links or PCI plugin cards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When this returns zero, a new bus number was allocated and stored</span></span><br><span class="line"><span class="comment"> * in adap-&gt;nr, and the specified adapter became available for clients.</span></span><br><span class="line"><span class="comment"> * Otherwise, a negative errno value is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev = &amp;adapter-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在设备树节点(在rk3x_i2c_probe中赋值)</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">        <span class="comment">// 获得总线号，因为总线驱动可以兼容多个同一平台的I2C控制器。一般会在dts里指定，即静态分配ID号</span></span><br><span class="line">		id = <span class="built_in">of_alias_get_id</span>(dev-&gt;of_node, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果找到I2C总线号则直接注册</span></span><br><span class="line">		<span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			<span class="keyword">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 为i2c_adapter动态分配ID并绑定</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adapter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_add_adapter); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>i2c_add_adapter</code>()函数有两种添加到总线的方式。如果在遍历设备树过程中获得了I2C总线的总线号，那么调用<code>__i2c_add_numbered_adapter()</code>静态添加。如果找不到，则需要动态添加，调用<code>i2c_register_adapter()</code>注册到I2C总线。</p>
<p><code>of_alias_get_id()</code>函数遍历设备树的alias节点下的设备节点，通过传入的两个参数查找设备树中与adapter匹配的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_alias_get_id</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *stem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">alias_prop</span> *app;</span><br><span class="line">	<span class="type">int</span> id = -ENODEV;</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;of_mutex);</span><br><span class="line">    <span class="comment">// 遍历链表aliases_lookup(成员为alias_prop)，逐一对比字符串stem。</span></span><br><span class="line">	<span class="built_in">list_for_each_entry</span>(app, &amp;aliases_lookup, link) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉dtsi中aliases节点内的非I2C节点</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(app-&gt;stem, stem) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果字符串匹配且找到对应的设备树节点，则说明找到了adapter(I2C控制器)设备节点的ID号</span></span><br><span class="line">		<span class="keyword">if</span> (np == app-&gt;np) &#123;</span><br><span class="line">			id = app-&gt;id;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;of_mutex);</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__i2c_add_numbered_adapter()</code>函数将i2c_adapter静态添加到I2C总线，代码部分实际和动态添加非常相似(不过是调用函数时传入的形参不同)。最终也是调用<code>i2c_register_adapter()</code>注册到I2C总线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1</span></span><br><span class="line"><span class="comment"> * @adap: the adapter to register (with adap-&gt;nr initialized)</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See i2c_add_numbered_adapter() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __i2c_add_numbered_adapter(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 使id号和adapter结构体按照IDR机制关联起来(IDR用类基树结构构造稀疏数组，以ID为索引来找到对应数组元素，进而找到对应的数据结构指针)</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adap, adap-&gt;nr, adap-&gt;nr + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">    <span class="comment">// 注册i2c_adapter</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>i2c_adapter注册总线的核心函数<code>i2c_register_adapter()</code>，最重要的任务是将设备树中I2C总线节点下的I2C设备转化成<code>i2c_client</code>，以备后续使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can&#x27;t register until after driver model init 得先注册I2C总线才能注册adapter */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN_ON</span>(!is_registered)) &#123;</span><br><span class="line">		res = -EAGAIN;</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity checks 如果adapter没有name和algo算法，则直接返回，无法注册 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(!adap-&gt;name[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>))</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;</span>, adap-&gt;name);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;lock_ops)</span><br><span class="line">		adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">	adap-&gt;locked_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;bus_lock);</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;mux_lock);</span><br><span class="line">	<span class="built_in">mutex_init</span>(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">		adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register soft irqs for Host Notify */</span></span><br><span class="line">	res = <span class="built_in">i2c_setup_host_notify_irq_domain</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t create Host Notify IRQs (%d)\n&quot;</span>,</span><br><span class="line">		       adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_set_name</span>(&amp;adap-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 本来这里进去会有调用总线probe的机会，但是由于i2c bus</span></span><br><span class="line"><span class="comment">	 * 没有指定match回调，所以会在中途返回，而且返回的是0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = <span class="built_in">device_register</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;</span>, adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">of_i2c_setup_smbus_alert</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pm_runtime_no_callbacks</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">pm_suspend_ignore_children</span>(&amp;adap-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">pm_runtime_enable</span>(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">i2c_init_recovery</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;adapter [%s] registered\n&quot;</span>, adap-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	res = <span class="built_in">class_compat_create_link</span>(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="built_in">dev_warn</span>(&amp;adap-&gt;dev,</span><br><span class="line">			 <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    <span class="comment">// 构建从设备的软件抽象i2c_client，并与adapter建立联系</span></span><br><span class="line">	<span class="built_in">of_i2c_register_devices</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_install_space_handler</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_register_devices</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		<span class="built_in">i2c_scan_static_board_info</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify drivers */</span></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">bus_for_each_drv</span>(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);		<span class="comment">// 通知I2C总线上已经注册的I2C驱动与新注册的adap进行匹配</span></span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_reg:</span><br><span class="line">	<span class="built_in">init_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">	<span class="built_in">device_unregister</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">wait_for_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">out_list:</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/<em> /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c </em>/<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">of_i2c_register_devices</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *bus, *node;</span><br><span class="line">    <span class="comment">// 构建i2c_client</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only register child devices if the adapter has a node pointer set 设备树节点不为空 */</span></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;dev.of_node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找设备树节点中名称有直接描述I2C总线的节点，为了缩小查找范围</span></span><br><span class="line">	bus = <span class="built_in">of_get_child_by_name</span>(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>);</span><br><span class="line">    <span class="comment">// 没找到则从头开始遍历</span></span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		bus = <span class="built_in">of_node_get</span>(adap-&gt;dev.of_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个子节点，调用of_i2c_register_device解析设备树节点内容</span></span><br><span class="line">	for_each_available_child_of_node(bus, node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_test_and_set_flag</span>(node, OF_POPULATED))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		client = <span class="built_in">of_i2c_register_device</span>(adap, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client)) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;Failed to create I2C device for %pOF\n&quot;</span>,</span><br><span class="line">				 node);</span><br><span class="line">			<span class="built_in">of_node_clear_flag</span>(node, OF_POPULATED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">of_node_put</span>(bus);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/of/base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	of_get_child_by_name - Find the child node by name for a given parent</span></span><br><span class="line"><span class="comment"> *	@node:	parent node</span></span><br><span class="line"><span class="comment"> *	@name:	child name to look for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      This function looks for child node for given matching name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns a node pointer if found, with refcount incremented, use</span></span><br><span class="line"><span class="comment"> *	of_node_put() on it when done.</span></span><br><span class="line"><span class="comment"> *	Returns NULL if node is not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">device_node</span> *<span class="built_in">of_get_child_by_name</span>(<span class="type">const</span> <span class="keyword">struct</span> device_node *node,</span><br><span class="line">				<span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *child;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(node, child)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_name_eq</span>(child, name))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(of_get_child_by_name);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">i2c_client</span> *<span class="built_in">of_i2c_register_device</span>(<span class="keyword">struct</span> i2c_adapter *adap, </span><br><span class="line"></span><br><span class="line">						 <span class="keyword">struct</span> device_node *node)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_board_info</span> info;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_i2c_get_board_info</span>(&amp;adap-&gt;dev, node, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(ret);</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">i2c_new_client_device</span>(adap, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client))</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_i2c_get_board_info</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_node *node,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="keyword">struct</span> i2c_board_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 addr;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="built_in">sizeof</span>(*info));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_modalias_node</span>(node, info-&gt;type, <span class="built_in">sizeof</span>(info-&gt;type)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: modalias failure on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_property_read_u32</span>(node, <span class="string">&quot;reg&quot;</span>, &amp;addr);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: invalid reg on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_TEN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info-&gt;addr = addr;</span><br><span class="line">	info-&gt;of_node = node;</span><br><span class="line">	info-&gt;fwnode = <span class="built_in">of_fwnode_handle</span>(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_property_read_bool</span>(node, <span class="string">&quot;host-notify&quot;</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_HOST_NOTIFY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_get_property</span>(node, <span class="string">&quot;wakeup-source&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(of_i2c_get_board_info);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终<code>i2c_new_client_device()</code>函数将设备树中的I2C子节点转换为<code>i2c_client</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /home/zjn/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device - instantiate an i2c device</span></span><br><span class="line"><span class="comment"> * @adap: the adapter managing the device</span></span><br><span class="line"><span class="comment"> * @info: describes one I2C device; bus_num is ignored</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create an i2c device. Binding is handled through driver model</span></span><br><span class="line"><span class="comment"> * probe()/remove() methods.  A driver may be bound to this device when we</span></span><br><span class="line"><span class="comment"> * return from this function, or any later moment (e.g. maybe hotplugging will</span></span><br><span class="line"><span class="comment"> * load the driver module).  This call is not appropriate for use by mainboard</span></span><br><span class="line"><span class="comment"> * initialization logic, which usually runs during an arch_initcall() long</span></span><br><span class="line"><span class="comment"> * before any i2c_adapter could exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This returns the new i2c client, which may be saved for later use with</span></span><br><span class="line"><span class="comment"> * i2c_unregister_device(); or an ERR_PTR to describe the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_client</span> *</span><br><span class="line"><span class="built_in">i2c_new_client_device</span>(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client;</span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">kzalloc</span>(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line">	client-&gt;flags = info-&gt;flags;</span><br><span class="line">	client-&gt;addr = info-&gt;addr;</span><br><span class="line"></span><br><span class="line">	client-&gt;init_irq = info-&gt;irq;</span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;init_irq)</span><br><span class="line">		client-&gt;init_irq = <span class="built_in">i2c_dev_irq_from_resources</span>(info-&gt;resources,</span><br><span class="line">							 info-&gt;num_resources);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strlcpy</span>(client-&gt;name, info-&gt;type, <span class="built_in">sizeof</span>(client-&gt;name));</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_validity</span>(client-&gt;addr, client-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line">		<span class="keyword">goto</span> out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address business */</span></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_ex</span>(adap, <span class="built_in">i2c_encode_flags_to_addr</span>(client));</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">			<span class="string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,</span><br><span class="line">			status, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">	client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">	client-&gt;dev.of_node = <span class="built_in">of_node_get</span>(info-&gt;of_node);</span><br><span class="line">	client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">i2c_dev_set_name</span>(adap, client, info, status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties) &#123;</span><br><span class="line">		status = <span class="built_in">device_add_properties</span>(&amp;client-&gt;dev, info-&gt;properties);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,</span><br><span class="line">				client-&gt;name, status);</span><br><span class="line">			<span class="keyword">goto</span> out_err_put_of_node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">device_register</span>(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_free_props;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">		client-&gt;name, <span class="built_in">dev_name</span>(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_free_props:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties)</span><br><span class="line">		<span class="built_in">device_remove_properties</span>(&amp;client-&gt;dev);</span><br><span class="line"></span><br><span class="line">out_err_put_of_node:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">of_node_put</span>(info-&gt;of_node);</span><br><span class="line"></span><br><span class="line">out_err_silent:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kfree</span>(client);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(status);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(i2c_new_client_device); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-I2C设备驱动实现"><a href="#1-3-I2C设备驱动实现" class="headerlink" title="1.3. I2C设备驱动实现"></a>1.3. I2C设备驱动实现</h2><p>由本文最开始给出的框架图可知，实现I2C设备驱动通常有两条路径：</p>
<h3 id="1-3-1-将I2C控制器暴露给应用的方式"><a href="#1-3-1-将I2C控制器暴露给应用的方式" class="headerlink" title="1.3.1. 将I2C控制器暴露给应用的方式"></a>1.3.1. 将I2C控制器暴露给应用的方式</h3><p>该方式采用标准的 <code>file_operations</code> 字符设备的形式，将 <code>i2c_adapter</code> 设备化，在<code>/dev</code>目录下创建<code>i2c-n(n=0, 1, 2...)</code>设备节点。所实现的驱动可看作是一种” <code>i2c_driver</code> 成员函数 + 字符设备驱动”的虚拟驱动，需要由应用层通过 <code>read()</code> 、 <code>write()</code> 函数根据芯片手册直接对I2C控制器进行配置时序等操作，以实现对从设备的控制。这种方式是把对硬件的具体操作放在应用层去实现，适合用来快速测试一款I2C设备的功能，或者在 <code>i2c_driver</code> 工作不正常的时候排查具体是设备驱动工作问题还是主机驱动工作问题。并不能作为主流的开发方式。详细可见 <code>.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-dev.c</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_MAJOR	89		<span class="comment">/* Device major number		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_MINORS	MINORMASK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module load/unload record keeping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">i2c_dev_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;i2c /dev entries driver\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 申请设备号，I2C_MAJOR为89，次设备号为0，I2C_MINORS为1&lt;&lt;20-1，表示次设备号的数量。</span></span><br><span class="line">	<span class="comment">// 就是把这个主设备号对应的次设备号都申请了。</span></span><br><span class="line">	res = <span class="built_in">register_chrdev_region</span>(<span class="built_in">MKDEV</span>(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">// 创建一个同名类，在 /sys/class中可以看到</span></span><br><span class="line">	i2c_dev_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;i2c-dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c_dev_class)) &#123;</span><br><span class="line">		res = <span class="built_in">PTR_ERR</span>(i2c_dev_class);</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line">	i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">	<span class="comment">// 注册i2c总线的通知函数</span></span><br><span class="line">	<span class="comment">// 参数2详见下</span></span><br><span class="line">	res = <span class="built_in">bus_register_notifier</span>(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">	<span class="comment">// 遍历i2c总线上的所有设备，每次都执行第二个参数对应的函数</span></span><br><span class="line">	<span class="built_in">i2c_for_each_dev</span>(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">	<span class="built_in">class_destroy</span>(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">	<span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS);</span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;%s: Driver Initialisation failed\n&quot;</span>, __FILE__);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_notifier_call</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="type">unsigned</span> <span class="type">long</span> action,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev = data;</span><br><span class="line">	<span class="comment">// 发生的事件类型</span></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">	<span class="comment">// 此i2c总线下发生添加设备事件</span></span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		<span class="comment">// 创建设备文件之类的操作</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">i2cdev_attach_adapter</span>(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 此i2c总线下发生删除设备事件</span></span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">i2cdev_detach_adapter</span>(dev, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> *adap;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_dev</span> *i2c_dev;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若设备类型不是i2c适配器，直接返回</span></span><br><span class="line">	<span class="comment">// 也有可能是 i2c_client 设备</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从i2c设备结构体中获取i2c适配器结构体</span></span><br><span class="line">	adap = <span class="built_in">to_i2c_adapter</span>(dev);</span><br><span class="line">	<span class="comment">// 分配内存</span></span><br><span class="line">	i2c_dev = <span class="built_in">get_free_i2c_dev</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c_dev))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(i2c_dev);</span><br><span class="line">	<span class="comment">// 设置文件操作接口</span></span><br><span class="line">	<span class="built_in">cdev_init</span>(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class="line">	i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">device_initialize</span>(&amp;i2c_dev-&gt;dev);</span><br><span class="line">	i2c_dev-&gt;dev.devt = <span class="built_in">MKDEV</span>(I2C_MAJOR, adap-&gt;nr);</span><br><span class="line">	i2c_dev-&gt;dev.<span class="keyword">class</span> = i2c_dev_class;</span><br><span class="line">	i2c_dev-&gt;dev.parent = &amp;adap-&gt;dev;</span><br><span class="line">	i2c_dev-&gt;dev.release = i2cdev_dev_release;</span><br><span class="line">	<span class="built_in">dev_set_name</span>(&amp;i2c_dev-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	<span class="comment">// 注意次设备号为适配器对应的编号，可以自己指定，也可以有系统分配</span></span><br><span class="line">	<span class="comment">// 参数3为此设备哈的数量，此fops只对应此设备号的文件</span></span><br><span class="line">	res = <span class="built_in">cdev_device_add</span>(&amp;i2c_dev-&gt;cdev, &amp;i2c_dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">put_i2c_dev</span>(i2c_dev, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;</span>,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> i2cdev_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read		= i2cdev_read,</span><br><span class="line">	.write		= i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	= i2cdev_ioctl,</span><br><span class="line">	.compat_ioctl	= compat_i2cdev_ioctl,</span><br><span class="line">	.open		= i2cdev_open,</span><br><span class="line">	.release	= i2cdev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 从inode获取次设备号，就是适配器的编号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minor = <span class="built_in">iminor</span>(inode);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> *adap;</span><br><span class="line">	<span class="comment">// 根据次设备号从i2c总线获取对应的适配器</span></span><br><span class="line">	adap = <span class="built_in">i2c_get_adapter</span>(minor);</span><br><span class="line">	<span class="keyword">if</span> (!adap)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This creates an anonymous i2c_client, which may later be</span></span><br><span class="line"><span class="comment">	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This client is ** NEVER REGISTERED ** with the driver model</span></span><br><span class="line"><span class="comment">	 * or I2C core code!!  It just holds private copies of addressing</span></span><br><span class="line"><span class="comment">	 * information and maybe a PEC flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// client表示某个具体的i2c设备，为其分配内存</span></span><br><span class="line">	client = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*client), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client) &#123;</span><br><span class="line">		<span class="built_in">i2c_put_adapter</span>(adap);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置具体的i2c设备的名字</span></span><br><span class="line">	<span class="built_in">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class="string">&quot;i2c-dev %d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	<span class="comment">// 设置具体的i2c设备归属的适配器</span></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line">	<span class="comment">// 以后可以通过file的此成员获取client指针</span></span><br><span class="line">	file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After opening an instance of this character special file, a file</span></span><br><span class="line"><span class="comment"> * descriptor starts out associated only with an i2c_adapter (and bus).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg</span></span><br><span class="line"><span class="comment"> * traffic to any devices on the bus used by that adapter.  That&#x27;s because</span></span><br><span class="line"><span class="comment"> * the i2c_msg vectors embed all the addressing information they need, and</span></span><br><span class="line"><span class="comment"> * are submitted directly to an i2c_adapter.  However, SMBus-only adapters</span></span><br><span class="line"><span class="comment"> * don&#x27;t support that interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To use read()/write() system calls on that file descriptor, or to use</span></span><br><span class="line"><span class="comment"> * SMBus interfaces (and work with SMBus-only hosts!), you must first issue</span></span><br><span class="line"><span class="comment"> * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous</span></span><br><span class="line"><span class="comment"> * (never registered) i2c_client so it holds the addressing information</span></span><br><span class="line"><span class="comment"> * needed by those system calls and by this SMBus interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">i2cdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 分配内存，用于接收消息</span></span><br><span class="line">	tmp = <span class="built_in">kzalloc</span>(count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: i2c-%d reading %zu bytes.\n&quot;</span>,</span><br><span class="line">		<span class="built_in">iminor</span>(<span class="built_in">file_inode</span>(file)), count);</span><br><span class="line">	<span class="comment">// 核心函数，接受一个i2c消息</span></span><br><span class="line">	ret = <span class="built_in">i2c_master_recv</span>(client, tmp, count);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, tmp, ret))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">	<span class="built_in">kfree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">i2cdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">size_t</span> count, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 把用户空间的buf拷贝内核空间的tmp</span></span><br><span class="line">	tmp = <span class="built_in">memdup_user</span>(buf, count);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(tmp))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(tmp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;</span>,</span><br><span class="line">		<span class="built_in">iminor</span>(<span class="built_in">file_inode</span>(file)), count);</span><br><span class="line">	<span class="comment">// 核心函数，发送一个i2c消息</span></span><br><span class="line">	ret = <span class="built_in">i2c_master_send</span>(client, tmp, count);</span><br><span class="line">	<span class="built_in">kfree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_send - issue a single I2C message in master transmit mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Data that will be written to the slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_transfer_buffer_flags</span>(client, (<span class="type">char</span> *)buf, count, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_recv - issue a single I2C message in master receive mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where to store data read from slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_transfer_buffer_flags</span>(client, buf, count, I2C_M_RD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer - execute a single or combined I2C message</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *	terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that there is no requirement that each message be sent to</span></span><br><span class="line"><span class="comment"> * the same slave address, although that is the most common model.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* REVISIT the fault reporting model here is weak:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get an error after receiving N bytes from a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get a NAK after transmitting N bytes to a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot; ... or to let the master</span></span><br><span class="line"><span class="comment">	 *    continue executing the rest of this combined message, if</span></span><br><span class="line"><span class="comment">	 *    that&#x27;s the appropriate response.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When for example &quot;num&quot; is two and we successfully complete</span></span><br><span class="line"><span class="comment">	 *    the first message but get an error part way through the</span></span><br><span class="line"><span class="comment">	 *    second, it&#x27;s unclear whether that should be reported as</span></span><br><span class="line"><span class="comment">	 *    one (discarding status on the second message) or errno</span></span><br><span class="line"><span class="comment">	 *    (discarding status on the first one).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = __i2c_lock_bus_helper(adap);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">	<span class="built_in">i2c_unlock_bus</span>(adap, I2C_LOCK_SEGMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_transfer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer_buffer_flags - issue a single I2C message transferring data</span></span><br><span class="line"><span class="comment"> *			       to/from a buffer</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where the data is stored</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to transfer, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes transferred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_transfer_buffer_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">char</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">int</span> count, u16 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 传入参数构建消息结构体</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_msg</span> msg = &#123;</span><br><span class="line">		.addr = client-&gt;addr,</span><br><span class="line">		.flags = flags | (client-&gt;flags &amp; I2C_M_TEN),</span><br><span class="line">		.len = count,</span><br><span class="line">		.buf = buf,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">i2c_transfer</span>(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If everything went ok (i.e. 1 msg transferred), return #bytes</span></span><br><span class="line"><span class="comment">	 * transferred, else error code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_transfer_buffer_flags);</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-将I2C控制器抽象成公共驱动的方式"><a href="#1-3-2-将I2C控制器抽象成公共驱动的方式" class="headerlink" title="1.3.2. 将I2C控制器抽象成公共驱动的方式"></a>1.3.2. 将I2C控制器抽象成公共驱动的方式</h3><p>该方式是把所有代码都放在驱动层实现，直接向应用层提供最终结果，即应用层甚至可以不知道I2C的存在。例如电容式触摸屏驱动直接向应用层提供 <code>/dev/input/eventn</code> 的操作接口，接收上报到应用层的输入事件。而不需要直到具体是怎么上报的，甚至应用层不知道触摸屏是使用I2C总线和主机进行数据交互的。</p>
<p>rk开发板用的触摸屏是汇顶科技的gt1x型电容式触摸屏，驱动代码位于/driver/input/touchscreen/gt1x/gt1x.c，电容触摸屏通过IIC总线与SOC进行通信，利用其自带的触摸IC完成坐标计算后通过IIC将坐标信息传输给SOC，坐标的计算过程不需要SOC的参与，从这个角度上来说，电容触摸屏就是一个挂载到SOC上的IIC slave设备，与通常所说的Sensor是一样的性质。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_ts_init - Driver Install function.</span></span><br><span class="line"><span class="comment"> * Return   0---succeed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">gt1x_ts_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GTP_DEBUG_FUNC</span>();</span><br><span class="line">	<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP driver installing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_add_driver</span>(&amp;gt1x_ts_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_ts_probe -   I2c probe.</span></span><br><span class="line"><span class="comment"> * @client: i2c device struct.</span></span><br><span class="line"><span class="comment"> * @id: device id.</span></span><br><span class="line"><span class="comment"> * Return  0: succeed, -1: failed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gt1x_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s32 ret = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_AUTO_UPDATE</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*do NOT remove these logs*/</span></span><br><span class="line">	<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP Driver Version: %s&quot;</span>, GTP_DRIVER_VERSION);</span><br><span class="line">	<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP I2C Address: 0x%02x&quot;</span>, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	gt1x_i2c_client = client;</span><br><span class="line">	<span class="built_in">spin_lock_init</span>(&amp;irq_lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查i2c适配器的能力</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">i2c_check_functionality</span>(client-&gt;adapter, I2C_FUNC_I2C)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;I2C check functionality failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GTP_CONFIG_OF	<span class="comment">/* device tree support */</span></span></span><br><span class="line">	<span class="comment">// 解析设备树</span></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;dev.of_node) &#123;</span><br><span class="line">		ret = <span class="built_in">gt1x_parse_dt</span>(&amp;client-&gt;dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	<span class="comment">// 申请GPIO端口</span></span><br><span class="line">	ret = <span class="built_in">gt1x_request_io_port</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP request IO port failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 触摸IC初始化</span></span><br><span class="line">	ret = <span class="built_in">gt1x_init</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP init failed!!!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_wq = <span class="built_in">create_singlethread_workqueue</span>(<span class="string">&quot;gt1x_wq&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!gt1x_wq) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Creat workqueue failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">INIT_WORK</span>(&amp;gt1x_work, gt1x_ts_work_func);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">gt1x_request_input_dev</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP request input dev failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">gt1x_request_irq</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP works in polling mode.&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP works in interrupt mode.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_GESTURE_WAKEUP</span></span><br><span class="line">	<span class="built_in">enable_irq_wake</span>(client-&gt;irq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">gt1x_irq_enable</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_ESD_PROTECT</span></span><br><span class="line">	<span class="comment">/*must before auto update*/</span></span><br><span class="line">	<span class="built_in">gt1x_init_esd_protect</span>();</span><br><span class="line">	<span class="built_in">gt1x_esd_switch</span>(SWITCH_ON);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_AUTO_UPDATE</span></span><br><span class="line">	thread = <span class="built_in">kthread_run</span>(gt1x_auto_update_proc, (<span class="type">void</span> *)<span class="literal">NULL</span>, <span class="string">&quot;gt1x_auto_update&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(thread)) &#123;</span><br><span class="line">		ret = <span class="built_in">PTR_ERR</span>(thread);</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Failed to create auto-update thread: %d.&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">gt1x_register_powermanger</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_parse_dt - parse platform infomation form devices tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gt1x_parse_dt</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *np;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *tp_type;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *root;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *machine_compatible;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	np = dev-&gt;of_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">of_property_read_string</span>(np, <span class="string">&quot;goodix,ic_type&quot;</span>, &amp;tp_type)) &#123;</span><br><span class="line">		<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP ic_type: %s&quot;</span>, tp_type);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(tp_type, <span class="string">&quot;gt5688&quot;</span>))</span><br><span class="line">			gt1x_gt5688 = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据NAME获取GPIO</span></span><br><span class="line">	gt1x_int_gpio = <span class="built_in">of_get_named_gpio</span>(np, <span class="string">&quot;goodix,irq-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//根据NAME获取GPIO</span></span><br><span class="line">	gt1x_rst_gpio = <span class="built_in">of_get_named_gpio</span>(np, <span class="string">&quot;goodix,rst-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 判断上述两个GPIO口是否可用</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gpio_is_valid</span>(gt1x_int_gpio) || !<span class="built_in">gpio_is_valid</span>(gt1x_rst_gpio)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Invalid GPIO, irq-gpio:%d, rst-gpio:%d&quot;</span>,</span><br><span class="line">				gt1x_int_gpio, gt1x_rst_gpio);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vdd_ana = <span class="built_in">devm_regulator_get_optional</span>(dev, <span class="string">&quot;vdd_ana&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">PTR_ERR</span>(vdd_ana) == -ENODEV) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;vdd_ana not specified, fallback to power-supply&quot;</span>);</span><br><span class="line">		vdd_ana = <span class="built_in">devm_regulator_get_optional</span>(dev, <span class="string">&quot;power&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">PTR_ERR</span>(vdd_ana) == -ENODEV) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;power not specified, ignore power ctrl&quot;</span>);</span><br><span class="line">			vdd_ana = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(vdd_ana)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;regulator get of vdd_ana/power-supply failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(vdd_ana);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_ics_slot_report = <span class="built_in">of_property_read_bool</span>(dev-&gt;of_node, <span class="string">&quot;gtp_ics_slot_report&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	root = <span class="built_in">of_find_node_by_path</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (root) &#123;</span><br><span class="line">		machine_compatible = <span class="built_in">of_get_property</span>(root, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">of_node_put</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(machine_compatible, <span class="string">&quot;linux&quot;</span>))</span><br><span class="line">			dev-&gt;driver-&gt;pm = &amp;gt1x_ts_pm_ops;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">s32 <span class="title">gt1x_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s32 ret = <span class="number">-1</span>;</span><br><span class="line">	s32 retry = <span class="number">0</span>;</span><br><span class="line">	u8 reg_val[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* power on */</span></span><br><span class="line">	<span class="built_in">gt1x_power_switch</span>(SWITCH_ON);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (retry++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line">		gt1x_init_failed = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* reset ic */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_reset_guitar</span>();	<span class="comment">// reset IC</span></span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Reset guitar failed!&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check main system firmware */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_i2c_read_dbl_check</span>(GTP_REG_FW_CHK_MAINSYS, reg_val, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (reg_val[<span class="number">0</span>] != <span class="number">0xBE</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Check main system not pass[0x%2X].&quot;</span>, reg_val[<span class="number">0</span>]);</span><br><span class="line">			gt1x_init_failed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !GTP_AUTO_UPDATE</span></span><br><span class="line">		<span class="comment">/* debug info  */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_i2c_read_dbl_check</span>(GTP_REG_FW_CHK_SUBSYS, reg_val, <span class="number">1</span>);	<span class="comment">// IIC读写测试，检查IC是否初始化成功</span></span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; reg_val[<span class="number">0</span>] == <span class="number">0xAA</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Check subsystem not pass[0x%2X].&quot;</span>, reg_val[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if the initialization fails, set default setting */</span></span><br><span class="line">	ret |= gt1x_init_failed;	</span><br><span class="line">	<span class="comment">// 判断IC是否初始化成功，如果没有使用默认配置</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Init failed, use default setting&quot;</span>);</span><br><span class="line">		gt1x_abs_x_max = GTP_MAX_WIDTH;</span><br><span class="line">		gt1x_abs_y_max = GTP_MAX_HEIGHT;</span><br><span class="line">		gt1x_int_type = GTP_INT_TRIGGER;</span><br><span class="line">		gt1x_wakeup_level = GTP_WAKEUP_LEVEL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get chip type */</span></span><br><span class="line">	<span class="comment">// 获取触摸IC的芯片类型：GT1X 、GT2X，对于不同的芯片类型会有不同的同步方式</span></span><br><span class="line">	ret = <span class="built_in">gt1x_get_chip_type</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Get chip type failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read version information */</span></span><br><span class="line">	ret = <span class="built_in">gt1x_read_version</span>(&amp;gt1x_version);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Get verision failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init and send configs */</span></span><br><span class="line">	<span class="comment">// 配置驱动IC，初始化完成后不可以再调用该函数</span></span><br><span class="line">	ret = <span class="built_in">gt1x_init_panel</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Init panel failed.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_workqueue = <span class="built_in">create_singlethread_workqueue</span>(<span class="string">&quot;gt1x_workthread&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gt1x_workqueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Create workqueue failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init auxiliary  node and functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_DEBUG_NODE</span></span><br><span class="line">	<span class="built_in">gt1x_init_debug_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_CREATE_WR_NODE</span></span><br><span class="line">	<span class="built_in">gt1x_init_tool_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_GESTURE_WAKEUP || GTP_HOTKNOT</span></span><br><span class="line">	<span class="built_in">gt1x_init_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_PROXIMITY</span></span><br><span class="line">	<span class="built_in">gt1x_ps_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_CHARGER_SWITCH</span></span><br><span class="line">	<span class="built_in">gt1x_init_charger</span>();</span><br><span class="line">	<span class="built_in">gt1x_charger_config</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">gt1x_charger_switch</span>(SWITCH_ON);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_SMART_COVER</span></span><br><span class="line">	<span class="built_in">gt1x_smart_cover_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_WITH_STYLUS</span></span><br><span class="line">	<span class="built_in">gt1x_pen_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gt1x_ts_probe 函数完成了触摸IC的初始化、以及中断事件的初始化，当中断发生时，调用中断处理函数（中断处理函数的上半部分，触摸中断事件需要处理的信息较多，不能全部放到中断处理函数当中去，这里通过工作队列实现了将中断处理分为上下两个部分，在中断处理函数的上半部分调用了queue_work 将中断需要处理的信息作为任务提交到了工作队列），显然这个工作队列也是在probe中完成的初始化以及创建一个专用的内核线程来执行提交到工作队列中的函数gt1x_ts_work_func。<br>分析到这里，我们可以完整的总结出一次input 事件上报的链路了：</p>
<p>触摸屏IC初始化完成-&gt;手指点击触摸屏-&gt;引发一次中断-&gt;gt1x_ts_irq_handler-&gt;queue_work(gt1x_wq, &gt;1x_work)-&gt;gt1x_ts_work_func-&gt;gt1x_touch_event_handler-&gt;gt1x_touch_down-&gt;input_report_abs-&gt;input_event-&gt;input_handle_event-&gt;input_pass_event-&gt;handler.event-&gt;evdev_event-&gt;evdev_events-&gt;evedv_pass_values</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/">Linux设备驱动开发</a><a class="post-meta__tags" href="/tags/I2C/">I2C</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20I2C%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%80%BB%E8%A7%88/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内核的I2C子系统详解 - I2C驱动开发总览</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/13/USBIP/2023-02-13-usbip%E5%92%8Clinux%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">usbip和Linux系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20I2C%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%80%BB%E8%A7%88/" title="Linux内核的I2C子系统详解 - I2C驱动开发总览"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">Linux内核的I2C子系统详解 - I2C驱动开发总览</div></div></a></div><div><a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E5%89%8D%E8%A8%80%E5%AF%BC%E5%BC%95/" title="Linux内核的I2C子系统详解 - 前言导引"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">Linux内核的I2C子系统详解 - 前言导引</div></div></a></div><div><a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/" title="Linux内核的I2C子系统详解 - 通信原理"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">Linux内核的I2C子系统详解 - 通信原理</div></div></a></div><div><a href="/2022/08/09/RK3568%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/2022-08-09-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E9%A9%B1%E5%8A%A8/" title="Linux内核的I2C子系统详解"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-09</div><div class="title">Linux内核的I2C子系统详解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Linux%E5%86%85%E6%A0%B8%E9%87%8C%E7%9A%84I2C%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">1. Linux内核里的I2C驱动框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%B3%A8%E5%86%8CI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%B1%82-%E4%B8%BB%E8%A6%81%E6%98%AF%E6%B3%A8%E5%86%8CI2C%E6%80%BB%E7%BA%BF"><span class="toc-text">1.1. 注册I2C子系统核心层(主要是注册I2C总线)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B3%A8%E5%86%8Ci2c-adapter%E5%B9%B6%E5%B0%86%E5%85%B6%E6%B7%BB%E5%8A%A0%E5%88%B0I2C%E6%80%BB%E7%BA%BF"><span class="toc-text">1.2. 注册i2c_adapter并将其添加到I2C总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2.1. 关键数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF"><span class="toc-text">1.2.2. 设备树信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8D%B8%E8%BD%BDi2c-adapter"><span class="toc-text">1.2.3. 注册和卸载i2c_adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-i2c-adapter%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">1.2.4. i2c_adapter相关函数配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E6%B7%BB%E5%8A%A0%E5%88%B0I2C%E6%80%BB%E7%BA%BF"><span class="toc-text">1.2.5. 添加到I2C总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3. I2C设备驱动实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%B0%86I2C%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9A%B4%E9%9C%B2%E7%BB%99%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3.1. 将I2C控制器暴露给应用的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%B0%86I2C%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8A%BD%E8%B1%A1%E6%88%90%E5%85%AC%E5%85%B1%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3.2. 将I2C控制器抽象成公共驱动的方式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/MCP/2025-04-14-Function%20Calling,%20MCP%20and%20A2A/" title="Function Calling, MCP and A2A">Function Calling, MCP and A2A</a><time datetime="2025-04-14T12:54:40.000Z" title="发表于 2025-04-14 20:54:40">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/%E6%99%BA%E8%83%BD%E4%BD%93/2025-04-14-OS%20Agents%20%E7%AC%94%E8%AE%B0/" title="OS Agents 笔记">OS Agents 笔记</a><time datetime="2025-04-14T03:05:57.000Z" title="发表于 2025-04-14 11:05:57">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/MCP/2025-04-08-MCP/" title="MCP">MCP</a><time datetime="2025-04-08T07:31:07.000Z" title="发表于 2025-04-08 15:31:07">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2025-03-10-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="算法分析与问题的计算复杂度">算法分析与问题的计算复杂度</a><time datetime="2025-03-10T11:53:48.000Z" title="发表于 2025-03-10 19:53:48">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/" title="消息序和组通信">消息序和组通信</a><time datetime="2025-01-11T11:43:17.000Z" title="发表于 2025-01-11 19:43:17">2025-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>