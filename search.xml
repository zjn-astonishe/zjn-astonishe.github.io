<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>C_C++基础知识 2</title>
    <url>/2022/03/13/C%E3%80%81C++/2022-03-13-C_C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%202/</url>
    <content><![CDATA[<h1 id="C-C-基础知识-2"><a href="#C-C-基础知识-2" class="headerlink" title="C_C++基础知识 2"></a>C_C++基础知识 2</h1><h2 id="C-C-中的存储相关"><a href="#C-C-中的存储相关" class="headerlink" title="C/C++中的存储相关"></a>C/C++中的存储相关</h2><h3 id="c-c-中变量的作用域"><a href="#c-c-中变量的作用域" class="headerlink" title="c/c++中变量的作用域"></a>c/c++中变量的作用域</h3><ul>
<li>作用域即一个变量的有效范围、生命周期。</li>
<li>变量的有效作用域由变量所在的最近一对括号确定。<ul>
<li>从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号。</li>
</ul>
</li>
<li>全局变量<ul>
<li>在所有函数体的外部定义。</li>
<li>程序的所在部分(甚至其他文件)都可以使用，全局变量不受作用域的影响，生命周期从定义开始一直到程序结束。</li>
<li>如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用该全局变量。</li>
</ul>
</li>
<li>局部变量<ul>
<li>局限于一个函数的变量，通常被称为自动变量(在进入作用域时自动生成，离开作用域时自动消失)。</li>
<li>函数中定义局部变量在函数中作用域结束时消失。当再次调用这个函数时，会重新创建变量的存储空间，其值会被重新初始化。</li>
<li>局部变量默认为auto。</li>
</ul>
</li>
<li>寄存器变量<ul>
<li>一种局部变量。关键字register告诉编译器”尽可能快地访问这个变量”。加快访问速度取决于现实，通常是在寄存器中放置变量来实现(不保证一定实现，只是暗示编译器)。</li>
<li>register变量是有限制的：<ul>
<li>不可能得到或计算register变量的地址; </li>
<li>register变量只能在一个块中声明(不可能有全局的或静态的register变量，不过c语言里register关键字可以在全局中定义变量)。</li>
<li>可以在一个函数中(即在参数表中)使用register变量作为一个形式参数。</li>
</ul>
</li>
<li>要避免使用关键字register。</li>
</ul>
</li>
<li>静态变量<ul>
<li>如果想使局部变量的值在程序的整个生命期里仍然存在，可以定义函数的局部变量为static(静态的)，并给它一个初始化。</li>
<li>静态局部变量只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。</li>
<li>静态局部变量和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只在定义自己的函数体内始终可见。</li>
<li>static局部变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易改变。这会使错误局部化，更容易被发现。</li>
<li>同样存在静态全局变量，具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li>
</ul>
</li>
<li>外部变量<ul>
<li>extern告诉编译器存在着一个变量和函数，即使编译器在当前的文件中没有看到它。这个变量或函数可能在一个文件或者在当前文件的后面定义。</li>
</ul>
</li>
<li>const常量<ul>
<li>const告诉编译器这个名字表示常量，不管是内部的还是用户定义的数据类型都可以定义为const。如果定义了某对象为常量，然后试图改变它，编译器将会产生错误。在C++中一个const必须有初始值。</li>
</ul>
</li>
<li>volatile变量<ul>
<li>限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。</li>
</ul>
</li>
</ul>
<h3 id="C语言检索内存情况，内存分配的方式"><a href="#C语言检索内存情况，内存分配的方式" class="headerlink" title="C语言检索内存情况，内存分配的方式"></a>C语言检索内存情况，内存分配的方式</h3><ul>
<li>检索内存：对某段内存遍历搜索。</li>
<li>内存分配：<ul>
<li>从静态区域分配，内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在(全局变量，static静态变量)。</li>
<li>在栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集，效率很高，但容量有限。</li>
<li>从堆上分配，动态分配内存。用malloc或new申请指定大小的内存，在程序中free或delete释放申请的内存。动态内存的生存周期由程序员决定，所以非常灵活，但是必须要注意回收内存，否则会导致内存泄漏，频繁分配和释放不同大小的堆空间会产生堆内碎块。</li>
</ul>
</li>
</ul>
<h3 id="函数参数压栈顺序，关于-stdcall和-cdecl调用方式的理解"><a href="#函数参数压栈顺序，关于-stdcall和-cdecl调用方式的理解" class="headerlink" title="函数参数压栈顺序，关于__stdcall和__cdecl调用方式的理解"></a>函数参数压栈顺序，关于<code>__stdcall</code>和<code>__cdecl</code>调用方式的理解</h3><ul>
<li><code>__stdcall</code>和<code>__cdecl</code>都是函数调用约定关键字。</li>
<li>__stdcall：StandardCall的缩写，是C++的标准调用方式，参数由右向左压入堆栈，由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容。</li>
<li>__cdecl：C Declaration的缩写，表明C语言默认的函数调用方式，参数也是由右向左压入堆栈，由调用者负责把参数压入栈，最后也由调用者负责清除栈的内容。且支持多输入不同数量的参数(printf)。<ul>
<li>因为被调用者不知道有多少参入被压入堆栈，所以无法清楚栈中的内容。</li>
</ul>
</li>
</ul>
<h3 id="重写memcpy函数"><a href="#重写memcpy函数" class="headerlink" title="重写memcpy函数"></a>重写memcpy函数</h3><ul>
<li>重写memcpy()需要考虑地址重叠的情况。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// memcpy(des, source, bytes)</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">2</span>], <span class="number">12</span>);   <span class="comment">// 由低地址向高地址，从前往后拷贝。</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">2</span>], &amp;b[<span class="number">0</span>], <span class="number">12</span>);   <span class="comment">// 由高地址向低地址，从后往前拷贝。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;case 1: &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;case 2: &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; b[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, size_t1 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *psrc;  <span class="comment">// 源地址</span></span><br><span class="line">    <span class="type">char</span> *pdst;  <span class="comment">// 目标地址</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 源地址在前，且会出现地址重叠。对应上述情况2，需要自后向前拷贝</span></span><br><span class="line">    <span class="keyword">if</span>((src &lt; dst) &amp;&amp; (<span class="type">char</span> *)src + size &gt; (<span class="type">char</span> *)dst)  </span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 源地址在后，且会出现地址重叠情况，对应上述第一种情况，直接逐个拷贝*pdst++ = *psrc++即可</span></span><br><span class="line">    <span class="comment">// 当然也包括无地址重叠的情况。</span></span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组存放"><a href="#数组存放" class="headerlink" title="数组存放"></a>数组存放</h3><ul>
<li>固定数组在函数体内分配(非静态)是存放在栈中。</li>
<li>固定数组是全局变量或静态局部数组存放在全局数据中。</li>
<li>固定数组在类中分配是存放在堆中。</li>
<li>动态数组(malloc、new)一定是存放在堆中。</li>
</ul>
<h3 id="static的用法"><a href="#static的用法" class="headerlink" title="static的用法"></a>static的用法</h3><ul>
<li>在C语言中，static的作用是改变变量的生命周期或者改变变量的作用域。</li>
<li>static局部变量：<ul>
<li>局部变量为动态存储，即指令执行到定义处才进行内存分配，将一个变量声明为函数的局部变量，使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。</li>
</ul>
</li>
<li>static全局变量<ul>
<li>对变量的链接方式产生影响。在编译时就分配内存，只在本文件内部有效，而其他文件不可链接或引用该变量。</li>
</ul>
</li>
<li>static函数(静态函数)<ul>
<li>对函数的链接方式产生影响。使得函数只在本文件内部有效，对其他文件是不可见的，即不会受到其他文件的同名函数产生的干扰，另外也是对函数本身一种保护机制。如果其他文件想要引用本地函数，则要在函数定义时用关键字<code>extern</code>，表示该函数时外部函数，可供其他文件调用，而不是用<code>static</code>。</li>
</ul>
</li>
<li>类中的static<ul>
<li>static成员变量<ul>
<li>表示这个成员变量为全类所共有，对类的所有对象只有一份拷贝，可以借助类名直接访问。</li>
</ul>
</li>
<li>static成员函数<ul>
<li>表示这个函数为全类所共有，而且只能访问静态成员变量，因为这个函数不接收this指针。</li>
<li>静态成员函数属于类，独立于对象而存在，如果没有对象，那么静态成员函数不能访问非静态的成员变量和调用非静态的成员函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><ul>
<li>const是常量修饰符，const变量必须在声明的时候就进行初始化。</li>
<li>const修饰常量<ul>
<li>定义时就初始化，以后不能更改。</li>
</ul>
</li>
<li>const修饰形参<ul>
<li>形参在函数里不能被更改。</li>
</ul>
</li>
<li>const修饰类成员函数<ul>
<li>如果要声明一个const类型的类成员函数，只需要在成员函数列表后加上关键字const；在类体之外定义const成员函数时，还必须加上const关键字。</li>
<li>const修饰的不是形参a和b；const修饰的是属性this-&gt;a和this-&gt;b。与const所写的位置无关。本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。</li>
<li>该函数对成员变量只能进行只读操作，即不能修改成员变量的数值。(值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。)</li>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li>
<li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；但如果只有const成员函数，非const对象是可以调用const成员函数的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数。</li>
<li>作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。</li>
</ul>
</li>
</ul>
<h3 id="volatile的作用和用法"><a href="#volatile的作用和用法" class="headerlink" title="volatile的作用和用法"></a>volatile的作用和用法</h3><ul>
<li>volatile的本意是”易变的”。作用是影响编译器的编译结果。<ul>
<li>由于访问寄存器要比访问内存单元更快，所以编译器一般都会作减少存取内存的优化，但有可能会读到脏数据。当要求使用volatile声明变量值的时候，编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据，即使前面的指令刚从该处读取过数据。</li>
</ul>
</li>
<li>中断服务程序中修改的供其他程序检测的变量，需要加volatile：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序本意希望ISR_2中断产生时，在main函数中调用dosomething函数。</span></span><br><span class="line"><span class="comment"> * 但是由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，</span></span><br><span class="line"><span class="comment"> * 然后每次if判断都只使用该寄存器的&quot;i副本&quot;，导致dosomething函数永远不会被调用。</span></span><br><span class="line"><span class="comment"> * 如果将变量加上volatile修饰，则编译器保证对此变量的读写操作不会被优化。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i) </span><br><span class="line">            <span class="built_in">dosomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br><span class="line"><span class="comment">/* 中断服务程序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多任务环境下(多线程)各任务间共享的标志应该加volatile。</li>
<li>存储器映射的硬件寄存器通常要加volatile，因为每次读写都可能有不同意义。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</span></span><br><span class="line"><span class="comment"> * 经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给出编译的代码结果相当于只对端口进行了一次赋值为9的操作。</span></span><br><span class="line"><span class="comment"> * 如果对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span>  *output = (<span class="keyword">volatile</span> <span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>;<span class="comment">//定义一个IO端口；</span></span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        *output = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许代码对此地址的读操作只做了一次。</span></span><br><span class="line"><span class="comment"> * 然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h3></li>
<li>如果要在C++中使用C的已编译好的函数模块，为了避免<strong>C++ name mangling</strong>，需要用到<code>extern &quot;C&quot;</code>，主要用于动态链接库，使得在C++里到处函数名称与C语言规则一致，方便不同的编译器甚至不同的开发语言调用。</li>
<li>当然C++中编译的函数要在C中调用也需要使用extern “C”。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数func会被C++编译器改名为int_fun_int，即返回类型_函数名_参数类型。</span></span><br><span class="line"><span class="comment"> * 如果加上extern &quot;C&quot;修饰，则编译器会按照C语言编译器编译为_fun。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>C++调用一个C语言编写的.so库时，包含描述.so库中函数的头文件时，应该将对应头文件防止在extern “C”{}中。</li>
<li>C中引用C++中的全局函数时，C++的头文件需要加extern “C”，而C文件中不能用extern “C”，只能用extern关键字。</li>
<li>extern可以多次声明，但只有一个定义。(头文件最好只有声明，不要放变量定义，即对变量进行初始化操作等)</li>
<li>extern在编译的链接阶段起作用。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++面经</tag>
        <tag>C/C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C_C++基础知识 1</title>
    <url>/2022/03/12/C%E3%80%81C++/2022-03-12-C_C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%201/</url>
    <content><![CDATA[<h1 id="C-C-基础知识-1"><a href="#C-C-基础知识-1" class="headerlink" title="C_C++基础知识 1"></a>C_C++基础知识 1</h1><h2 id="C和C-中某些概念的异同"><a href="#C和C-中某些概念的异同" class="headerlink" title="C和C++中某些概念的异同"></a>C和C++中某些概念的异同</h2><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ul>
<li><code>new</code>、<code>delete</code>是C++独有的<strong>操作符</strong>，而<code>malloc</code>和<code>free</code>是C/C++中的标准库函数。<ul>
<li>使用new创建对象在分配内存的时候会调用对象的构造函数，同时完成对对象的初始化(delete在回收内存的时候也会调用对象的析构函数)。malloc和free是库函数，不在编译器控制范围之内(外部链接)，所以不能够自动调用构造函数和析构函数。<ul>
<li>malloc只是单纯为变量分配内存，free也只是释放变量内存。</li>
</ul>
</li>
<li>C++允许重载new/delete操作符，而malloc和delte是函数，不能重载。<blockquote>
<p>允许重载的是operator new和operator delete，通过malloc和free来实现的。只用来分配所要求的空间，不调用相关对象的构造函数。</p>
<p>当无法满足所要求分配的空间时，如果有new_handler，则调用new_handler，否则执行bad_alloc异常或者返回0。</p>
<p>重载时，返回类型必须时void*，第一个形参类型必须为分配空间的大小(字节)，类型size_t，后面可以带有其他形参。</p>
</blockquote>
</li>
</ul>
</li>
<li>new返回的是指定类型的指针，malloc返回的是<code>void*</code>类型(需要强行将其转换为实际类型的指针)。</li>
<li>malloc需要指定好要申请的内存的大小。</li>
<li>new内存分配失败的时候，会抛出<code>bad_alloc</code>异常，malloc分配内存失败返回NULL。</li>
<li>内存区域<ul>
<li>凡是通过new操作符进行内存申请得到的内存都属于自由存储区(C++基于new操作符的一个抽象概念)。new操作符从自由存储区上为对象动态分配内存空间。</li>
<li>堆是操作系统的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。malloc函数从堆上动态分配内存。</li>
</ul>
</li>
</ul>
<h4 id="malloc的底层实现"><a href="#malloc的底层实现" class="headerlink" title="malloc的底层实现"></a>malloc的底层实现</h4><blockquote>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Linux内核空间模型"></p>
<p>Linux维护着一个名为<code>program break</code>的指针，它指向堆空间的某个地址，从堆的起始地址到该指针之间的地址空间为映射好的，可供进程访问。</p>
<p>而从该指针往上，是未映射的地址空间，访问这段空间会导致程序报错。用malloc进行内存分配就是从该指针往上进行的。</p>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/%E5%A0%86%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.png?raw=true" alt="堆内部机制"></p>
<p>malloc函数的实质是有一个将可用内存块连接的空闲链表。调用malloc()函数的时候，沿着空闲链表寻找足以满足用户请求的内存块。然后，将该内存块一分为二：一块与用户申请大小相等，传给用户使用；另一块为剩余内存，返回连接到空闲链表。</p>
<p>如果用户申请一个大的内存片段，空闲链表上没有可以满足用户要求的片段的时候，malloc函数会请求延时，并开始将空闲链表上的内存片段进行整理合并，直到有符合用户要求的内存片段为止。</p>
</blockquote>
<h4 id="在1G内存的计算机中能否运行malloc-1-2G-？"><a href="#在1G内存的计算机中能否运行malloc-1-2G-？" class="headerlink" title="在1G内存的计算机中能否运行malloc(1.2G)？"></a>在1G内存的计算机中能否运行malloc(1.2G)？</h4><ul>
<li>有可能申请到1.2G内存。</li>
<li>应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。</li>
<li>当前Windows环境可申请的最大空间超过1.9G，具体数值会受到操作系统版本、程序本身的大小、用到的动态/共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的结果都可能存在差异(有些操作系统使用了随即地址分布技术，使进程的堆空间变小)。</li>
<li>$1.2=1.2*2^{30}$Byte，数值在malloc函数参数类型的范围内。因此是可能能申请到的。</li>
<li>即malloc函数调用申请超过机器物理内存大小的内存块是有可能成功的(存储时以硬盘空间作为虚拟内存)。</li>
</ul>
<h3 id="指针和引用的异同"><a href="#指针和引用的异同" class="headerlink" title="指针和引用的异同"></a>指针和引用的异同</h3><h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><ul>
<li>指针和引用都是地址概念。</li>
<li>从内存分配上看，指针和引用都占用内存。<ul>
<li>程序为指针变量分配内存区域(32位系统即地址可能为32位的值，指针变量存储的是指向某变量的地址，大约要32位的空间，即4个字节)</li>
<li>引用本质是指针常量，所以占用的大小也是4个字节(除非编译器进行优化)所指向的对象是不能改变的，但指向对象的值是可以改变的。‘</li>
</ul>
</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>指针是一个实体，引用只是别名。</li>
<li>指针的自增是指向内存地址的增加，引用的自增是引用的值的增加。</li>
<li>引用使用时不需要解引用(*)，指针使用时需要。</li>
<li>引用只能在定义时被初始化一次，之后不可变。指针可变。</li>
<li>引用不能为空，指针可以为空。</li>
<li>引用没有const，指针有const<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cost修饰的是指针变量a，即指针指向的整型值可以改变，但是指针指向地址不能变。指针常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a;   <span class="comment">//从后往前看，const修饰的是p，所以指针p本身不可变</span></span><br><span class="line"><span class="comment">//cost修饰的是整型数*a，即指针可以改变指向地址，但不能改变指向位置的对应值。常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a;   <span class="comment">//从后往前看，const修饰的是*p，所以指针p指向的数值不可变</span></span><br><span class="line"><span class="comment">// 没有int&amp; const a</span></span><br><span class="line"><span class="type">double</span> r;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = r; <span class="comment">//正确 性质1：不可通过常量引用a来改变r</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">10</span>;<span class="comment">//正确 性质2：常量引用可以直接引用具体数值</span></span><br></pre></td></tr></table></figure></li>
<li>没有指向引用的指针，但是有指针的引用<ul>
<li>没有指向引用的指针，因为指针是本质上是指向某一块内存空间的，而引用只是一个变量的别名，本身是没有地址的，如果要创建一个指针指向某个引用，那么其实指向的是这个引用所引用的对象<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指向引用的指针实际指向引用所引用的对象</span></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;ri = v; <span class="comment">//整型变量v的引用</span></span><br><span class="line"><span class="type">int</span> *p = &amp;ri; <span class="comment">//指针p其实指向的是变量v</span></span><br><span class="line"><span class="comment">// 指针的引用</span></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;v;</span><br><span class="line"><span class="type">int</span> *&amp;rp = p;  <span class="comment">// 定义了一个指向指针p的引用rp，即rp作为指针p的别名。</span></span><br><span class="line">cout &lt;&lt; *rp &lt;&lt; endl; <span class="comment">// 即相当于输出*p。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>sizeof()</code>得到的引用的大小是所指向变量(对象)的大小，而得到的指针的大小是其本身大小(32位4字节)。</li>
</ul>
<h4 id="指针与引用相互转换"><a href="#指针与引用相互转换" class="headerlink" title="指针与引用相互转换"></a>指针与引用相互转换</h4><ul>
<li>指针转引用<ul>
<li>指针用解引用<code>*</code>可转换成对象，可以用在引用参数当中。</li>
</ul>
</li>
<li>引用转指针<ul>
<li>引用类型的对象用取地址<code>&amp;</code>就能获得指针。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;va)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2022</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line">	<span class="type">int</span> *pA = &amp;b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*pA: &quot;</span> &lt;&lt; *pA &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>(*pA);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;va: &quot;</span> &lt;&lt; va &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul>
<li>在C++中struct和class意义基本是一样的。</li>
<li>struct里面默认的访问控制是public，而class中的默认访问控制是private。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">// 必须加public，不然默认是private</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; a1.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="const常量和-define的区别"><a href="#const常量和-define的区别" class="headerlink" title="const常量和#define的区别"></a>const常量和#define的区别</h3><ul>
<li>从定义常量是否有类型来看<ul>
<li><h1 id="define定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量名字联系起来。-define定义的宏变量在预处理阶段就进行替换，在程序中使用到该常量的地方都要进行拷贝替换。所以如果不进行类型安全检查，可能会产生意想不到的错误。"><a href="#define定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量名字联系起来。-define定义的宏变量在预处理阶段就进行替换，在程序中使用到该常量的地方都要进行拷贝替换。所以如果不进行类型安全检查，可能会产生意想不到的错误。" class="headerlink" title="define定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量名字联系起来。#define定义的宏变量在预处理阶段就进行替换，在程序中使用到该常量的地方都要进行拷贝替换。所以如果不进行类型安全检查，可能会产生意想不到的错误。"></a>define定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量名字联系起来。#define定义的宏变量在预处理阶段就进行替换，在程序中使用到该常量的地方都要进行拷贝替换。所以如果不进行类型安全检查，可能会产生意想不到的错误。</h1></li>
<li>const定义的常量是有类型的，编译时会进行类型检查，存放在内存的静态区域中，在编译时确定其值。在程序运行过程中，</li>
</ul>
</li>
<li>从消耗的内存大小来看<ul>
<li>const变量只有一个拷贝，而#define所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const大得多。</li>
</ul>
</li>
<li>从是否可以用指针变量去指向来看<ul>
<li>用#define定义的常量是不可以用指针变量去指向的</li>
<li>用const定义的常量是可以用指针去指向常量地址的。</li>
</ul>
</li>
<li>从是否可以定义函数来看<ul>
<li>用#define可以定义一些简单的函数(宏替换只是替换，不做计算和表达式求解)</li>
<li>用const是不可以定义函数的。</li>
</ul>
</li>
<li>从作用范围来看<ul>
<li><h1 id="define宏定义的作用范围仅限于当前文件。"><a href="#define宏定义的作用范围仅限于当前文件。" class="headerlink" title="define宏定义的作用范围仅限于当前文件。"></a>define宏定义的作用范围仅限于当前文件。</h1></li>
<li>默认状态下，const常量只在文件内有效，当多个文件中出现同名的const变量时，等同于在不同文件中分别定义了独立的变量。<ul>
<li>如果想在多个文件之间共享const常量，必须在变量定义之前添加extern关键字。(在声明和定义时都要加)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++面经</tag>
        <tag>C/C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C_C++基础知识 3</title>
    <url>/2022/03/13/C%E3%80%81C++/2022-03-13-C_C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%203/</url>
    <content><![CDATA[<h1 id="C-C-基础知识-3"><a href="#C-C-基础知识-3" class="headerlink" title="C_C++基础知识 3"></a>C_C++基础知识 3</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>从长字节数据类型转换为短字节数据类型，会产生截断。如果短字节数据类型是有符号类型，则最高位为符号位。</li>
<li>从短字节类型转换为长字节类型，会发生符号扩展(有符号)或零扩展。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total;</span><br><span class="line">total=(<span class="type">int</span>)<span class="number">10.9</span>+(<span class="type">int</span>)<span class="number">12.7</span>+(<span class="type">int</span>)<span class="number">11</span>;    <span class="comment">// 强制类型转换</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;total1: &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">total = <span class="number">10.9</span>+<span class="number">12.7</span>+<span class="number">11</span>;                 <span class="comment">// 自动类型转换，较短字节类型自动向较长字节类型转换</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;total2: &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  _tmain( <span class="type">int</span>  argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span>  fa = <span class="number">1.0f</span>;</span><br><span class="line">    cout&lt;&lt;&amp;fa&lt;&lt;endl; <span class="comment">//0x0012ff60</span></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>)fa&lt;&lt;endl;   <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;(<span class="type">float</span>&amp;)fa&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;*((<span class="type">float</span>*)(&amp;fa))&lt;&lt;endl; <span class="comment">// 1</span></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>&amp;)fa&lt;&lt;endl; <span class="comment">//1065353216，(int &amp;)fa=*(int*)(&amp;fa)</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3></li>
<li>static_cast是在编译期间转换，转换失败的话会抛出一个编译错误。只能用于良性转换，这样的转换风险较低，一般不会发生什么意外。<ul>
<li>原有的自动类型转换，例如<code>short</code>转<code>int</code>、<code>int</code>转<code>double</code>等。</li>
<li>void指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等</li>
<li>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 <code>double</code>转<code>Complex</code>(调用转换构造函数)、<code>Complex</code>转<code>double</code>(调用类型转换函数)。</li>
</ul>
</li>
<li>不能用于无关类型之间的转换，因为有风险。<ul>
<li>两个具体类型指针之间的转换，<code>int *</code>转<code>double *</code></li>
<li>不同类型的数据存储格式不一样，长度也不一样，用A类型的指针指向B类型的数据后，会按照A类型的方式来处理数据：<ul>
<li>如果是读取操作，可能会得到一堆没有意义的值；</li>
<li>如果是写入操作，可能会使B类型的数据遭到破坏，当再次以B类型的方式读取数据时会得到一堆没有意义的值。</li>
</ul>
</li>
</ul>
</li>
<li>static_cast也不能用来去掉表达式的const修饰和volatile修饰。换句话说，不能将const/volatile类型转换为非const/volatile类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real = <span class="number">0.0</span>, <span class="type">double</span> imag = <span class="number">0.0</span>): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;</span><br><span class="line">    <span class="type">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面是正确的用法</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line">    <span class="type">int</span> *p1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line">    <span class="type">void</span> *p2 = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line">    <span class="type">double</span> real= <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line">    <span class="comment">//下面的用法是错误的</span></span><br><span class="line">    <span class="type">float</span> *p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">    p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3></li>
<li>去常转换，编译时执行，不是运行时执行。</li>
<li>const_cast操作不能在不同的种类间转换。仅仅把作用的表达式转换成常量。</li>
<li>可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 </li>
<li>const_case只能转换指针或引用，不能转换变量。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> constant = <span class="number">26</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* const_p = &amp;constant;     <span class="comment">// 不能转换变量，所以要使用指针。也可以用const_cast&lt;int*&gt;(&amp;constant)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去掉const属性，因为不能把一个const变量直接赋值给一个非const变量。</span></span><br><span class="line"><span class="comment">        * 但是可以把一个非const变量直接赋给一个const变量。所以很少用来将非const变量转换成const变量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">int</span>* modifier = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(const_p);  </span><br><span class="line">    *modifier = <span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;constant:  &quot;</span>&lt;&lt;constant&lt;&lt;endl;  <span class="comment">//26 因为 C++对常量的处理更像是编译时期的#define，是一个值替换的过程，代码中所有使用constant的地方在编译期间就被替换成了26。</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*modifier:  &quot;</span>&lt;&lt;*modifier&lt;&lt;endl;   <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3></li>
<li>重解释类型转换。</li>
<li>可以转化任何的内置数据类型为其他的类型，同时也可以把任何类型的指针转化为其他的类型；</li>
<li>机理是对二进制进行重新的解释，不会改变原来的格式。</li>
<li>最好不要使用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将 char* 转换为 float*</span></span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">float</span> *p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(str);</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将 int 转换为 int*</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//将 A* 转换为 int*</span></span><br><span class="line">    p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">25</span>, <span class="number">96</span>));</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3></li>
<li>用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型(Downcasting)。用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型(Downcasting)。</li>
<li>向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测(要求基类必须包含虚函数)，所有只有一部分能成功。</li>
<li>dynamic_cast 的语法格式为：<code>dynamic_cast &lt;newType&gt; (expression)</code><ul>
<li><code>newType</code>和<code>expression</code>必须同时是指针类型或者引用类型。</li>
<li>换句话说，dynamic_cast只能转换指针类型和引用类型，其它类型(int、double、数组、类、结构体等)都不行。</li>
<li>对于指针，如果转换失败将返回<code>NULL</code>；对于引用，如果转换失败将抛出<code>std::bad_cast</code>异常。</li>
</ul>
</li>
<li>向上转型(Upcasting)<ul>
<li>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数(这些信息在编译期间就能确定)，就一定能转换成功。</li>
<li>因为向上转型始终是安全的，所以dynamic_cast不会进行任何运行期间的检查，这个时候的dynamic_cast和static_cast就没有什么区别了。但还是存在安全隐患的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a = <span class="number">0</span>): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> m_a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">Base</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_b</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//情况①：正确</span></span><br><span class="line">    Derived *pd1 = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">35</span>, <span class="number">78</span>);</span><br><span class="line">    Base *pb1 = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(pd1);    <span class="comment">// 子类转成基类</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd1 = &quot;</span>&lt;&lt;pd1&lt;&lt;<span class="string">&quot;, pb1 = &quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb1-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;</span><br><span class="line">    pb1-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//情况②：出错</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pd2指向的是整型变量n，并没有指向一个Derived类的对象，</span></span><br><span class="line"><span class="comment">     * 在使用dynamic_cast进行类型转换时也没有检查这一点，</span></span><br><span class="line"><span class="comment">     * 而是将pd2的值直接赋给了pb2(这里并不需要调整偏移量)，</span></span><br><span class="line"><span class="comment">     * 最终导致pb2也指向了n。因为pb2指向的不是一个对象，所以get_a()得不到 m_a的值(实际上得到的是一个垃圾值)，pb2-&gt;func()也得不到 func()函数的正确地址，因为pb2没有虚函数表，也没有虚函数表指针，而func()是虚函数，必须到虚函数表中才能找到地址。</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Derived *pd2 = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(&amp;n);</span><br><span class="line">    Base *pb2 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd2 = &quot;</span>&lt;&lt;pd2&lt;&lt;<span class="string">&quot;, pb2 = &quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb2-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;  <span class="comment">//输出一个垃圾值</span></span><br><span class="line">    pb2-&gt;<span class="built_in">func</span>();  <span class="comment">//内存错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>向下转型(Downcasting)<ul>
<li>向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码中类的继承顺序为：A --&gt; B --&gt; C --&gt; D。</span></span><br><span class="line"><span class="comment"> * pa 是A*类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为B*或C*类型。</span></span><br><span class="line"><span class="comment"> * 当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为B*或C*类型。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B *pb;</span><br><span class="line">    C *pc;    </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------&quot;</span>&lt;&lt;endl;   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheritance Chain），也就是如下图所示的样子：</p>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E9%93%BE.png?raw=true" alt="类的继承链"></p>
<p>当使用dynamic_cast对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类(指针指向的对象所属的类)的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p>
<p>对于代码中的情况①，pa指向A类对象，根据该对象找到的就是A的类型信息，当程序从这个节点开始向上遍历时，发现A的上方没有要转换的B类型或C类型(实际上 A 的上方没有任何类型了)，所以就转换败了。对于情况②，pa指向D 类对象，根据该对象找到的就是D的类型信息，程序从这个节点向上遍历的过程中，发现了C类型和B类型，所以就转换成功了。</p>
</blockquote>
</li>
</ul>
</li>
<li>总起来说，dynamic_cast会在程序运行过程中遍历继承链，<ul>
<li>如果途中遇到了要转换的目标类型，那么就能够转换成功，</li>
<li>如果直到继承链的顶点(最顶层的基类)还没有遇到要转换的目标类型，那么就转换失败。</li>
<li>对于同一个指针，它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</li>
</ul>
</li>
<li>从表面上看起来dynamic_cast确实能够向下转型，但是从本质上讲dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。<ul>
<li>造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。dynamic_cast只是让不同的基类指针指向同一个派生类对象罢了。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++面经</tag>
        <tag>C/C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象 2</title>
    <url>/2022/03/16/C%E3%80%81C++/2022-03-16-C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%202/</url>
    <content><![CDATA[<h1 id="C-面向对象-2"><a href="#C-面向对象-2" class="headerlink" title="C++面向对象 2"></a>C++面向对象 2</h1><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><h3 id="对拷贝构造函数、深浅拷贝的理解。拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？"><a href="#对拷贝构造函数、深浅拷贝的理解。拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？" class="headerlink" title="对拷贝构造函数、深浅拷贝的理解。拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？"></a>对拷贝构造函数、深浅拷贝的理解。拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？</h3><ul>
<li>浅拷贝是增加了一个指针，指向原来已经存在的内存。<ul>
<li>浅拷贝在多个对象指向同一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放，其他空间再次释放会出现错误。</li>
</ul>
</li>
<li>深拷贝是增加了一个指针，并新开辟了一块空间让指针指向这块新开辟的空间。</li>
<li>深拷贝和浅拷贝的不同之处，仅仅在于修改了拷贝构造函数，以及赋值运算符的重载。相同类型的类对象是通过拷贝构造函数来完成复制过程的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CopyDemo</span>(<span class="type">int</span> pa,<span class="type">char</span> *cstr)  <span class="comment">//构造函数，两个参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = pa;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span>]; <span class="comment">//指针数组，动态的用new在堆上分配存储空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,cstr);    <span class="comment">//拷贝过来</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没写，C++会自动帮忙写一个复制构造函数，这个默认拷贝构造函数执行的是浅拷贝。</span></span><br><span class="line"><span class="comment">// 浅拷贝只复制指针,如下注释部分</span></span><br><span class="line">  <span class="built_in">CopyDemo</span>(CopyDemo&amp; obj)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = obj.a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = obj.str; <span class="comment">// 这里是浅复制会出问题，要深复制</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  CopyDemo(CopyDemo&amp; obj)  //一般数据成员有指针要自己写复制构造函数，如下</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    this-&gt;a = obj.a;</span></span><br><span class="line"><span class="comment">    this-&gt;str = new char[1024];// 深复制</span></span><br><span class="line"><span class="comment">    if(str != 0)</span></span><br><span class="line"><span class="comment">      strcpy(this-&gt;str,obj.str); // 如果成功，把内容复制过来</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  ~<span class="built_in">CopyDemo</span>()  <span class="comment">//析构函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;  <span class="comment">//定义一个整型的数据成员</span></span><br><span class="line">  <span class="type">char</span> *str; <span class="comment">//字符串指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">CopyDemo <span class="title">A</span><span class="params">(<span class="number">100</span>,<span class="string">&quot;hello!!!&quot;</span>)</span></span>;</span><br><span class="line">  CopyDemo B = A;  <span class="comment">//复制构造函数，把A的10和hello!!!复制给B</span></span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;A:&quot;</span>&lt;&lt; A.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;A.str &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//输出A:100，hello!!!</span></span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt; B.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;B.str &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//输出B:100，hello!!!</span></span><br><span class="line">  <span class="comment">//修改后,发现A,B都被改变，原因就是浅复制，A,B指针指向同一地方，修改后都改变</span></span><br><span class="line">  B.a = <span class="number">80</span>;</span><br><span class="line">  B.str[<span class="number">0</span>] = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;A:&quot;</span>&lt;&lt; A.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;A.str &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//输出A:100，kello!!!</span></span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt; B.a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt;B.str &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//输出B:80，kello!!!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于凡是包含动态分配成员或包含指针成员(如字符串)的类都应该提供拷贝构造函数；在提供拷贝构造函数的同时，还应该考虑重载”=”赋值操作符号。</li>
</ul>
<h3 id="调用拷贝构造函数的三种情况"><a href="#调用拷贝构造函数的三种情况" class="headerlink" title="调用拷贝构造函数的三种情况"></a>调用拷贝构造函数的三种情况</h3><ul>
<li>一个对象以值传递的方式传入函数体(形参)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数，传入的是对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;test&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//传入对象</span></span><br><span class="line">    <span class="built_in">g_Fun</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用g_Fun()时，会产生以下几个重要步骤：</span></span><br><span class="line"><span class="comment">  * (1)test对象传入形参时，会先会产生一个临时变量，就叫tmp_test吧。</span></span><br><span class="line"><span class="comment">  * (2)然后调用拷贝构造函数把test的值给tmp_test。整个这两个步骤有点像：</span></span><br><span class="line"><span class="comment">  *    CExample tmp_test(test);</span></span><br><span class="line"><span class="comment">  * (3)等g_Fun()执行完后,析构掉tmp_test对象。</span></span><br><span class="line"><span class="comment">  * */</span></span><br></pre></td></tr></table></figure></li>
<li>一个对象以值传递的方式返回(返回值)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function">CExample <span class="title">g_Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g_Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当g_Fun()函数执行到return时，会产生以下几个重要步骤：</span></span><br><span class="line"><span class="comment"> * (1)先会产生一个临时变量，就叫XXXX吧。</span></span><br><span class="line"><span class="comment"> * (2)然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);</span></span><br><span class="line"><span class="comment"> * (3)在函数执行到最后先析构temp局部变量。</span></span><br><span class="line"><span class="comment"> * (4)等g_Fun()执行完后再析构掉XXXX对象.</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></li>
<li>一个对象需要通过另外一个对象进行初始化(初始化)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">CExample B = A; <span class="comment">//这句和下句都会调用拷贝构造函数。</span></span><br><span class="line"><span class="comment">// CExample B(A);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数为什么一般不定义为虚函数"><a href="#构造函数为什么一般不定义为虚函数" class="headerlink" title="构造函数为什么一般不定义为虚函数"></a>构造函数为什么一般不定义为虚函数</h3><ul>
<li>从存储空间角度</li>
<li>从使用角度</li>
<li>从实现角度</li>
<li>构造函数不需要是虚函数，</li>
<li>当一个构造函数被调用的时候</li>
</ul>
<h3 id="析构函数可以抛出异常吗？为什么？除了资源泄露，还会造成怎样的影响？"><a href="#析构函数可以抛出异常吗？为什么？除了资源泄露，还会造成怎样的影响？" class="headerlink" title="析构函数可以抛出异常吗？为什么？除了资源泄露，还会造成怎样的影响？"></a>析构函数可以抛出异常吗？为什么？除了资源泄露，还会造成怎样的影响？</h3><ul>
<li>C++标准指明析构函数不能、也不应该抛出异常。<ul>
<li>如果对象在运行期间出现了异常，C++异常处理模型有责任清楚由于异常导致失效的对象(对象超出了原来的作用域)，并释放对象原来所分配的资源。而释放资源的任务是由对象的析构函数完成的。所以，某种意义上说，析构函数已经变成了异常处理的一部分。</li>
</ul>
</li>
<li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作，比如释放资源，则这些动作不会执行，没有释放的资源便造成了资源泄露问题。</li>
<li>通常在异常发生时，C++的机制会调用已经构造对象的析构函数释放资源，此时若析构函数本身也抛出异常，则会出现程序崩溃问题。例如在析构函数里delete this指针，该操作会调用析构函数，那么就会陷入死循环造成程序崩溃。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++面经</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象 1</title>
    <url>/2022/03/15/C%E3%80%81C++/2022-03-15-C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%201/</url>
    <content><![CDATA[<h1 id="C-面向对象-1"><a href="#C-面向对象-1" class="headerlink" title="C++面向对象 1"></a>C++面向对象 1</h1><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul>
<li>C++支持多重继承，所以会出现重复作为基类的情况。例如:<br><img src="https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png?raw=true" alt="菱形继承"></li>
<li>为了节省内存空间，可以将DeriverdA、DeriverdB对Base的继承定义为虚拟继承，而A就成了虚拟基类。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriverdA</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Base; <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriverdB</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Base; <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> DeriverdA,DeriverdB;  <span class="comment">//普通继承</span></span><br></pre></td></tr></table></figure></li>
<li>虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</li>
<li>不要轻易使用虚拟继承，更不要在虚继承的基础上进行类型转换。<ul>
<li>因为虚拟继承会破坏继承体系，不能按照平常的继承体系进行类型转换。</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>基本概念<ul>
<li>指为不同数据类型的实体提供统一的接口。多态类型可以将自身所支持的操作套用到其它类型的值上。</li>
<li>简单的说: 就是用基类的引用指向子类的对象。</li>
<li>可分为<ul>
<li>变量多态和函数多态<ul>
<li>变量多态: 基类型的变量(对于C++是引用或指针)可以对基类型对象赋值，也可以对派生类型的对象赋值。</li>
<li>函数多态: 相同的函数调用界面(函数名与实参表)，传送给一个对象变量，可以有不同的行为，这视该对象变量所指向的对象类型而定。</li>
<li>变量多态是函数多态的基础。</li>
</ul>
</li>
<li>动态多态和静态多态<ul>
<li>动态多态<ul>
<li>通过类继承机制和虚函数机制生效于运行期。</li>
<li>只要共同的基类定义了虚函数的接口，就可以优雅地处理异质对象集合。</li>
<li>也被称为子类型多态或包含多态。在面向对象程序设计中，这被直接称为多态。</li>
</ul>
</li>
<li>静态多态<ul>
<li>模板也允许将不同的特殊行为和单个泛化记号相关联，由于这种关联处理于编译期而非运行期，因此被称为”静态”。</li>
<li>可以用来实现类型安全、运行高效的同质对象集合操作。</li>
<li>包括<ul>
<li>函数重载</li>
<li>运算符重载</li>
<li>带变量的宏多态</li>
<li>非参数化多态或译作特设多态</li>
<li>参数化多态: 把类型作为参数的多态。在面向对象程序设计中，被称作泛型编程。</li>
</ul>
</li>
</ul>
</li>
<li>运行时多态和编译时多态<ul>
<li>运行时多态: 重写(override)</li>
<li>编译时多态：重载(overload)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>多态除了代码的复用性外，还可以解决项目中紧偶合的问题,提高程序的可扩展性。<ul>
<li>耦合度即模块模块之间，代码代码之间的关联度。通过对系统的分析把他分解成一个一个子模块，子模块提供稳定的接口，达到降低系统耦合度的的目的，模块模块之间尽量使用模块接口访问，而不是随意引用其他模块的成员变量。</li>
</ul>
</li>
<li>应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。</li>
<li>派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。</li>
</ul>
</li>
</ul>
<h3 id="多态的类，内存布局是怎么样的"><a href="#多态的类，内存布局是怎么样的" class="headerlink" title="多态的类，内存布局是怎么样的"></a>多态的类，内存布局是怎么样的</h3><ul>
<li>虚继承<ul>
<li>如果是虚继承，那么就会为这个类创建一个虚表指针，占用4个字节。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">&#125;; <span class="comment">//sizeof(A)=4，因为a是整形，占用4字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> b;  </span><br><span class="line">&#125;;<span class="comment">//sizeof(B)=4(A副本)+4(虚表指针占用4字节)+4(变量b占用4字节)=12  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;       </span><br><span class="line">&#125;;<span class="comment">//sizeof(c)= 12(B副本)+4(虚表指针) = 16，如果这里改为直接继承，那么sizeof(c)=12，因为此时就没有虚表指针了</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多重继承(菱形继承)<ul>
<li>如果是以虚继承实现多重继承，需要减掉基类的副本。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">&#125;;<span class="comment">//sizeof(A) = 4  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;  </span><br><span class="line">&#125;;<span class="comment">// sizeof(B) =4+4=8  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;          </span><br><span class="line">&#125;;<span class="comment">//sizeof(C) =4+4=8  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;         </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//sizeof(D)=8+8-4=12这里需要注意要减去4，因为B和C同时继承A，只需要保存一个A的副本就好了，sizeof(D)=4(A的副本)+4(B的虚表)+4(C的虚表)=12，也可以是8（B的副本）+8（c的副本）-4（A的副本）=12</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>普通继承(空类和虚函数)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>      </span><br><span class="line">&#123;     </span><br><span class="line">&#125;;    <span class="comment">//result=1  空类所占空间的大小为1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>     </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;   </span><br><span class="line">&#125;;   <span class="comment">//result=8  1+4   字节对齐后为 8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>    </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> ch1;  </span><br><span class="line">    <span class="type">char</span> ch2;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;    <span class="comment">//也只有一个虚指针</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;  &#125;    <span class="comment">//也只有一个虚指针</span></span><br><span class="line">&#125;;  <span class="comment">//result=8  1+1+4 字节对齐后为 8，没有继承的，此时类里即使出现多个虚函数，也只有一个虚指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> C  </span><br><span class="line">&#123;     </span><br><span class="line">    <span class="type">int</span> d;     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;   <span class="comment">//继承了C，C里已经有一个虚指针，此时D自己有虚函数，</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; <span class="comment">//也不会创建另一个虚指针，所以D本身就变量d需要4字节</span></span><br><span class="line">&#125;;     <span class="comment">//result=12  8（C的副本）+4（整形变量d占用4字节）=12  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C  </span><br><span class="line">&#123;     </span><br><span class="line">    <span class="type">int</span> e;     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;   <span class="comment">//同理，E不会创建另一个虚指针，所以E本身就变量e需</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125;  <span class="comment">//要4字节</span></span><br><span class="line">&#125;;  <span class="comment">//result=20   8（ B的副本）+8（C的副本）+4（E本身）=20</span></span><br></pre></td></tr></table></figure></li>
<li>基类派生子类拥有虚函数的菱形继承<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommonBase</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> co;  </span><br><span class="line">&#125;;<span class="comment">// size = 4  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> CommonBase            </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> b1;  </span><br><span class="line">&#125;;<span class="comment">//4（父类副本）+4（自己有虚函数，加1个虚指针空间）+4（自身变量b1）+4(虚继承再加1个虚指针空间)=16  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> CommonBase          </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dump1</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dump2</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> b2;  </span><br><span class="line">&#125;;<span class="comment">//同理16  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2       </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dump2</span><span class="params">()</span> </span>&#123;  &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> d;  </span><br><span class="line">&#125;;<span class="comment">//16+16-4+4=32  </span></span><br></pre></td></tr></table></figure></li>
<li>总结<ul>
<li>如果不是虚继承的类，即使有虚函数也不会因此增加存储空间。</li>
<li>如果是虚继承的类，没有虚函数就添加一个虚指针空间，有虚函数(不管多少个)，就添加两个虚指针空间。</li>
<li>继承的类的存储空间大小包括：<ul>
<li>父类副本大小。有多重继承时，若父类的父类有重合(菱形继承)，则需要减去该基类的大小。</li>
<li>如果是虚继承，增加一个虚拟指针空间(通常4字节)。</li>
<li>自身变量大小(要进行字节地址对齐，通常是4个字节为单位)</li>
<li>如果本身还有虚函数，增加一个指向虚函数表的指针(通常4字节)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-如何实现多态-多态实现的三个条件、实现的原理"><a href="#C-如何实现多态-多态实现的三个条件、实现的原理" class="headerlink" title="C++如何实现多态(多态实现的三个条件、实现的原理)"></a>C++如何实现多态(多态实现的三个条件、实现的原理)</h3><ul>
<li>多态实现的三个条件<ul>
<li>有继承;</li>
<li>有虚函数重写;</li>
<li>有父类指针(父类引用)指向子类对象。</li>
</ul>
</li>
<li>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表<code>vtable</code>。<ul>
<li>虚函数表的各表项为指向类里面的虚函数的指针。</li>
</ul>
</li>
<li>编译器还会在此类中隐含插入一个指针<code>vptr</code>(对vc编译器来说，它插在类的内存地址的第一个位置上)指向虚函数表。</li>
<li>调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，即将vptr指向对应的vtable，将类与此类的虚函数表联系了起来。</li>
<li>另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的this指针，这样依靠此this指针即可得到正确的vtable，如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Face</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Father&#x27;s face&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Father say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐式类型转换。</span></span><br><span class="line"><span class="comment">     * 指向基础类的pFather指针已经变成指向具体的类son的this指针。</span></span><br><span class="line"><span class="comment">     * 调用pFather指针，就相当于调用子类son的this指针。</span></span><br><span class="line"><span class="comment">     * this指针所能调用的函数，自然就是子类son本身的函数。</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    Father *pFather=&amp;son; </span><br><span class="line">    pFather-&gt;<span class="built_in">Say</span>(); <span class="comment">// 调用的是子类的Say()函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多态的广义解释：<ul>
<li>一段程序能够处理多种类型对象的能力。</li>
<li>那么实现多态的方式：<ul>
<li>重载多态(函数重载和运算符重载)</li>
<li>类型强制转换</li>
<li>类型参数化多态(函数模板、类模板)</li>
<li>包含多态(继承与虚函数)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量"><a href="#被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量" class="headerlink" title="被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量"></a>被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量</h3><ul>
<li>C++有两种方法可以调用被隐藏的函数：<ul>
<li>用<code>using</code>关键字<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">using</span> Parent::add;    <span class="comment">// 让Parent类中的add函数对Child可见。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">void</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>用域操作符<code>::</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Child *c;</span><br><span class="line">c-&gt;Parent::<span class="built_in">add</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>其实还可以有其他方法<ul>
<li>使用父类指针指向子类对象<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Child *c;</span><br><span class="line">Parent* p = <span class="keyword">new</span> Child;</span><br></pre></td></tr></table></figure></li>
<li>调用父类函数时，使用强制类型转换<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Child *c;</span><br><span class="line">((p*)c)-&gt;<span class="built_in">add</span>();</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++面经</tag>
        <tag>面向对象，继承和多态</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核的I2C子系统详解 - I2C驱动开发总览</title>
    <url>/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20I2C%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h1 id="1-Linux内核里I2C子系统软件架构"><a href="#1-Linux内核里I2C子系统软件架构" class="headerlink" title="1. Linux内核里I2C子系统软件架构"></a>1. Linux内核里I2C子系统软件架构</h1><p>下图展示了Linux I2C子系统的基本软件架构，大体可以分为用户空间、内核空间和硬件三个部分。</p>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/Linux%E5%86%85%E6%A0%B8%E9%87%8CI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6%E5%9B%BE.png?raw=true" alt="Linux I2C子系统软件架构图"></p>
<p>用户空间中的应用层是系统中应用程序的集合，它们通过调用内核空间封装好的API访问底层硬件设备。</p>
<p>对于驱动开发而言，只需关注架构的内核空间部分。在《Linux设备驱动开发详解》一书第15章《Linux I2C核心、总线与设备驱动》中，将Linux内核里的I2C子系统分为核心、总线驱动和设备驱动三部分。</p>
<h2 id="1-1-I2C核心"><a href="#1-1-I2C核心" class="headerlink" title="1.1. I2C核心"></a>1.1. I2C核心</h2><p>I2C核心提供了I2C总线驱动和I2C设备驱动注册和注销的方法，I2C通信接口，与具体适配器无关的代码，以及探测设备、检测设备地址的上层代码。</p>
<h2 id="1-2-I2C总线驱动"><a href="#1-2-I2C总线驱动" class="headerlink" title="1.2. I2C总线驱动"></a>1.2. I2C总线驱动</h2><p>I2C总线驱动是对soc中I2C控制器的软件实现。提供I2C控制器与从设备间完成数据通信的能力。对应软件架构图中硬件抽象层部分(i2c_algorithm)和硬件实现控制层(i2c_adapter)。</p>
<h2 id="1-3-I2C设备驱动"><a href="#1-3-I2C设备驱动" class="headerlink" title="1.3. I2C设备驱动"></a>1.3. I2C设备驱动</h2><p>I2C设备驱动(客户驱动)是对I2C从设备的软件实现。对应软件架构图中的驱动层。</p>
<h1 id="2-Linux内核里I2C子系统代码总览"><a href="#2-Linux内核里I2C子系统代码总览" class="headerlink" title="2. Linux内核里I2C子系统代码总览"></a>2. Linux内核里I2C子系统代码总览</h1><h2 id="2-1-关键文件路径"><a href="#2-1-关键文件路径" class="headerlink" title="2.1. 关键文件路径"></a>2.1. 关键文件路径</h2><h3 id="2-1-1-核心层和总线驱动"><a href="#2-1-1-核心层和总线驱动" class="headerlink" title="2.1.1. 核心层和总线驱动"></a>2.1.1. 核心层和总线驱动</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux<span class="number">-5.10</span>/drivers/i2c/</span><br><span class="line">├── algos               <span class="comment">// i2c_algorithm相关，通信算法</span></span><br><span class="line">├── busses              <span class="comment">// i2c_adapter相关，已经编写好的各种向i2c核心层注册的适配器</span></span><br><span class="line">├── muxes               <span class="comment">// i2c切换芯片，不重点讨论</span></span><br><span class="line">├── i2c-boardinfo.c     <span class="comment">// i2c静态声明i2c设备的文件</span></span><br><span class="line">├── i2c-core-acpi.c     <span class="comment">// 以下i2c-core-*.c对应老版本的i2c-core.c，由内核开发者实现的，与硬件无关的代码。主要为其他各部分提供操作接口，在其内部通过结构体里面的函数指针调用硬件相关信息，即结构体里面函数指针的函数在设备加载的时候初始化</span></span><br><span class="line">├── i2c-core-base.c</span><br><span class="line">├── i2c-core.h</span><br><span class="line">├── i2c-core-of.c</span><br><span class="line">├── i2c-core-slave.c</span><br><span class="line">├── i2c-core-smbus.c</span><br><span class="line">├── i2c-dev.c</span><br><span class="line">├── i2c-mux.c</span><br><span class="line">├── i2c-slave-eeprom.c</span><br><span class="line">├── i2c-slave-testunit.c</span><br><span class="line">├── i2c-smbus.c         <span class="comment">// 实现smbus协议的扩展文件</span></span><br><span class="line">├── i2c-stub.c</span><br><span class="line">├── Kconfig</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-设备驱动-以gt1x触摸屏为例"><a href="#2-1-2-设备驱动-以gt1x触摸屏为例" class="headerlink" title="2.1.2. 设备驱动(以gt1x触摸屏为例)"></a>2.1.2. 设备驱动(以gt1x触摸屏为例)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux<span class="number">-5.10</span>/drivers/input/touchscreen/gt1x/</span><br><span class="line">├── gt1x.c          <span class="comment">// 设备驱动主要代码位置</span></span><br><span class="line">├── gt1x_cfg.h</span><br><span class="line">├── gt1x_extents.c</span><br><span class="line">├── gt1x_firmware.h</span><br><span class="line">├── gt1x_generic.c</span><br><span class="line">├── gt1x_generic.h</span><br><span class="line">├── gt1x.h</span><br><span class="line">├── gt1x_tools.c</span><br><span class="line">├── gt1x_update.c</span><br><span class="line">├── GT5688_Config_20170713_1080_1920.cfg</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-设备树文件"><a href="#2-1-3-设备树文件" class="headerlink" title="2.1.3. 设备树文件"></a>2.1.3. 设备树文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux<span class="number">-5.10</span>/arch/arm64/boot/dts/rockchip/</span><br><span class="line">├── ...</span><br><span class="line">├── rk3568.dtsi</span><br><span class="line">├── rk3568-linux.dtsi</span><br><span class="line">├── rk3568-toybrick-mipi-tx0-beiqicloud.dtsi</span><br><span class="line">├── rk3568-toybrick-x0-linux.dts</span><br><span class="line">├── ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-重要的库"><a href="#2-1-4-重要的库" class="headerlink" title="2.1.4. 重要的库"></a>2.1.4. 重要的库</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux<span class="number">-5.10</span>/include/linux/</span><br><span class="line">├── ...</span><br><span class="line">├── device.h</span><br><span class="line">├── ...</span><br><span class="line">├── i2c.h</span><br><span class="line">├── of.h</span><br><span class="line">├── of_device.h</span><br><span class="line">├── ...</span><br></pre></td></tr></table></figure>
<h2 id="2-2-关键数据结构定义"><a href="#2-2-关键数据结构定义" class="headerlink" title="2.2. 关键数据结构定义"></a>2.2. 关键数据结构定义</h2><h3 id="2-2-1-I2C适配器定义"><a href="#2-2-1-I2C适配器定义" class="headerlink" title="2.2.1. I2C适配器定义"></a>2.2.1. I2C适配器定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;               <span class="comment">/* 模块拥有者 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="keyword">class</span>;                 <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> *algo; 	<span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    <span class="type">void</span> *algo_data;                    <span class="comment">/* i2c_algorithm的私有数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices, 同步机制	*/</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> timeout;                        <span class="comment">/* in jiffies 超过该事件无法重发*/</span></span><br><span class="line">    <span class="type">int</span> retries;                        <span class="comment">/* I2C发送失败重发次数 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device</span> dev;                  <span class="comment">/* the adapter device */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_flags;	        <span class="comment">/* owned by the I2C core */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_IS_SUSPENDED		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_SUSPEND_REPORTED	1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nr;                             <span class="comment">/* 适配器编号，在创建i2c_client的时候会根据编号分类，若置为-1，则代表动态分配 */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">48</span>];                      <span class="comment">/* 适配器的名字 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-I2C通信方法定义"><a href="#2-2-2-I2C通信方法定义" class="headerlink" title="2.2.2. I2C通信方法定义"></a>2.2.2. I2C通信方法定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/i2c.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: Issue a set of i2c transactions to the given I2C adapter</span></span><br><span class="line"><span class="comment"> *   defined by the msgs array, with num messages available to transfer via</span></span><br><span class="line"><span class="comment"> *   the adapter specified by adap.</span></span><br><span class="line"><span class="comment"> * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this</span></span><br><span class="line"><span class="comment"> *   is not present, then the bus layer will try and convert the SMBus calls</span></span><br><span class="line"><span class="comment"> *   into I2C transfers instead.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the ``I2C_FUNC_*`` flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the ``master_xfer&#123;_atomic&#125;`` fields should indicate the</span></span><br><span class="line"><span class="comment"> * type of error code that occurred during the transfer, as documented in the</span></span><br><span class="line"><span class="comment"> * Kernel Documentation file Documentation/i2c/fault-codes.rst.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 普通I2C数据通讯协议</span></span><br><span class="line">	<span class="built_in">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可选的函数，功能与master_xfer相同，不过是在atomic context环境下使用。</span></span><br><span class="line"><span class="comment">	 * 比如在关机之前，所有中断都关闭的情况下，可用这个函数来访问电源管理芯片。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SMBus协议，SMBus协议大部分基于I2C总线规范，并在I2C基础上扩展，在访问时序上有一些差异</span></span><br><span class="line">	<span class="built_in">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可选的函数，功能与smbus_xfer相同，不过是在atomic context环境下使用。</span></span><br><span class="line"><span class="comment">	 * 比如在关机之前，所有中断都关闭的情况下，可用这个函数来访问电源管理芯片。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	<span class="comment">// 指向返回适配器支持功能的函数的指针，查看适配的能力。这些功能都是以宏定义的方式表示，定义在include/linux/i2c.h中，以I2C_FUNC开头</span></span><br><span class="line">	<span class="built_in">u32</span> (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="built_in">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);        <span class="comment">//  有些i2c_adapter也可工作于Slave模式，用来实现或模拟一个I2C设备</span></span><br><span class="line">	<span class="built_in">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);        <span class="comment">// 反注册</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /usr/include/linux/i2c.h */</span></span><br><span class="line"><span class="comment">// i2c_algorithm中通信函数的基本单位</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_msg - an I2C transaction segment beginning with START</span></span><br><span class="line"><span class="comment"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span></span><br><span class="line"><span class="comment"> *	bit address, I2C_M_TEN must be set in @flags and the adapter</span></span><br><span class="line"><span class="comment"> *	must support I2C_FUNC_10BIT_ADDR.</span></span><br><span class="line"><span class="comment"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span></span><br><span class="line"><span class="comment"> *	provided unless the adapter exported the relevant I2C_FUNC_*</span></span><br><span class="line"><span class="comment"> *	flags through i2c_check_functionality().</span></span><br><span class="line"><span class="comment"> * @len: Number of data bytes in @buf being read from or written to the</span></span><br><span class="line"><span class="comment"> *	I2C slave address.  For read transactions where I2C_M_RECV_LEN</span></span><br><span class="line"><span class="comment"> *	is set, the caller guarantees that this buffer can hold up to</span></span><br><span class="line"><span class="comment"> *	32 bytes in addition to the initial length byte sent by the</span></span><br><span class="line"><span class="comment"> *	slave (plus, if used, the SMBus PEC); and this value will be</span></span><br><span class="line"><span class="comment"> *	incremented by the number of block data bytes received.</span></span><br><span class="line"><span class="comment"> * @buf: The buffer into which data is read, or from which it&#x27;s written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_msg is the low level representation of one segment of an I2C</span></span><br><span class="line"><span class="comment"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span></span><br><span class="line"><span class="comment"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span></span><br><span class="line"><span class="comment"> * @i2c_adapter.@master_xfer() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span></span><br><span class="line"><span class="comment"> * the standard rules for I2C transactions.  Each transaction begins with a</span></span><br><span class="line"><span class="comment"> * START.  That is followed by the slave address, and a bit encoding read</span></span><br><span class="line"><span class="comment"> * versus write.  Then follow all the data bytes, possibly including a byte</span></span><br><span class="line"><span class="comment"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span></span><br><span class="line"><span class="comment"> * bytes have been transferred and ACKed.  If this is the last message in a</span></span><br><span class="line"><span class="comment"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span></span><br><span class="line"><span class="comment"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span></span><br><span class="line"><span class="comment"> * passing certain @flags may have changed those standard protocol behaviors.</span></span><br><span class="line"><span class="comment"> * Those flags are only for use with broken/nonconforming slaves, and with</span></span><br><span class="line"><span class="comment"> * adapters which are known to support the specific mangling options they</span></span><br><span class="line"><span class="comment"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_msg</span> &#123;</span><br><span class="line"></span><br><span class="line">	__u16 addr;	                <span class="comment">/* slave address, 从机在I2C总线上的地址  */</span></span><br><span class="line">	__u16 flags;                        <span class="comment">/* 消息特征标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_DMA_SAFE		0x0200	<span class="comment">/* the buffer of this message is DMA safe */</span></span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* makes only sense in kernelspace */</span></span><br><span class="line">					<span class="comment">/* userspace buffers are copied anyway */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length					*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-I2C-从机-设备驱动定义"><a href="#2-2-3-I2C-从机-设备驱动定义" class="headerlink" title="2.2.3. I2C(从机)设备驱动定义"></a>2.2.3. I2C(从机)设备驱动定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/i2c.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_driver - represent an I2C device driver</span></span><br><span class="line"><span class="comment"> * @class: What kind of i2c device we instantiate (for detect)</span></span><br><span class="line"><span class="comment"> * @probe: Callback for device binding - soon to be deprecated</span></span><br><span class="line"><span class="comment"> * @probe_new: New callback for device binding</span></span><br><span class="line"><span class="comment"> * @remove: Callback for device unbinding</span></span><br><span class="line"><span class="comment"> * @shutdown: Callback for device shutdown</span></span><br><span class="line"><span class="comment"> * @alert: Alert callback, for example for the SMBus alert protocol</span></span><br><span class="line"><span class="comment"> * @command: Callback for bus-wide signaling (optional)</span></span><br><span class="line"><span class="comment"> * @driver: Device driver model driver</span></span><br><span class="line"><span class="comment"> * @id_table: List of I2C devices supported by this driver</span></span><br><span class="line"><span class="comment"> * @detect: Callback for device detection</span></span><br><span class="line"><span class="comment"> * @address_list: The I2C addresses to probe (for detect)</span></span><br><span class="line"><span class="comment"> * @clients: List of detected clients we created (for i2c-core use only)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver.owner field should be set to the module owner of this driver.</span></span><br><span class="line"><span class="comment"> * The driver.name field should be set to the name of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For automatic device detection, both @detect and @address_list must</span></span><br><span class="line"><span class="comment"> * be defined. @class should also be set, otherwise only devices forced</span></span><br><span class="line"><span class="comment"> * with module parameters will be created. The detect function must</span></span><br><span class="line"><span class="comment"> * fill at least the name field of the i2c_board_info structure it is</span></span><br><span class="line"><span class="comment"> * handed upon successful detection, and possibly also the flags field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @detect is missing, the driver will still work fine for enumerated</span></span><br><span class="line"><span class="comment"> * devices. Detected devices simply won&#x27;t be supported. This is expected</span></span><br><span class="line"><span class="comment"> * for the many I2C/SMBus devices which can&#x27;t be detected reliably, and</span></span><br><span class="line"><span class="comment"> * the ones which can always be enumerated in practice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The i2c_client structure which is handed to the @detect callback is</span></span><br><span class="line"><span class="comment"> * not a real i2c_client. It is initialized just enough so that you can</span></span><br><span class="line"><span class="comment"> * call i2c_smbus_read_byte_data and friends on it. Don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * else with it. In particular, calling dev_dbg and friends on it is</span></span><br><span class="line"><span class="comment"> * not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_driver</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">    <span class="comment">// probe和remove必须实现</span></span><br><span class="line">	<span class="built_in">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id);</span><br><span class="line">	<span class="built_in">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="built_in">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *client);    <span class="comment">// 关机</span></span><br><span class="line">    <span class="built_in">int</span> (*suspend)(<span class="keyword">struct</span> i2c_client *, <span class="type">pm_message_t</span> mesg);   <span class="comment">// 挂起    </span></span><br><span class="line">    <span class="built_in">int</span> (*resume)(<span class="keyword">struct</span> i2c_client *);     <span class="comment">// 恢复</span></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_driver</span> driver; <span class="comment">// 在注册i2c_driver对象时，i2c_driver-&gt;driver的总线类型被指定为i2c_bus_type</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_device_id</span> *id_table;           <span class="comment">// 存放该驱动支持的设备列表，驱动和设备匹配时会用到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="built_in">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> i2c_board_info *info);  <span class="comment">// 基于设备探测机制实现的 12C 设备驱动：设备探测的回调函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;     <span class="comment">// 设备探测的地址范围</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> clients;   <span class="comment">// 探测到的设备列表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_i2c_driver(d) container_of(d, struct i2c_driver, driver)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-4-I2C-从机-设备信息定义"><a href="#2-2-4-I2C-从机-设备信息定义" class="headerlink" title="2.2.4. I2C(从机)设备信息定义"></a>2.2.4. I2C(从机)设备信息定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/i2c.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_client - represent an I2C slave device</span></span><br><span class="line"><span class="comment"> * @flags: see I2C_CLIENT_* for possible flags</span></span><br><span class="line"><span class="comment"> * @addr: Address used on the I2C bus connected to the parent adapter.</span></span><br><span class="line"><span class="comment"> * @name: Indicates the type of the device, usually a chip name that&#x27;s</span></span><br><span class="line"><span class="comment"> *	generic enough to hide second-sourcing and compatible revisions.</span></span><br><span class="line"><span class="comment"> * @adapter: manages the bus segment hosting this I2C device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model device node for the slave.</span></span><br><span class="line"><span class="comment"> * @init_irq: IRQ that was set at initialization</span></span><br><span class="line"><span class="comment"> * @irq: indicates the IRQ generated by this device (if any)</span></span><br><span class="line"><span class="comment"> * @detected: member of an i2c_driver.clients list or i2c-core&#x27;s</span></span><br><span class="line"><span class="comment"> *	userspace_devices list</span></span><br><span class="line"><span class="comment"> * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter</span></span><br><span class="line"><span class="comment"> *	calls it to pass on slave events to the slave driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_client identifies a single device (i.e. chip) connected to an</span></span><br><span class="line"><span class="comment"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span></span><br><span class="line"><span class="comment"> * managing the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_client</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_PEC		0x04	<span class="comment">/* Use Packet Error Checking 设备使用SMBus包错误检查 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_TEN		0x10	<span class="comment">/* we have a ten bit chip address 设备使用10bit地址 */</span></span></span><br><span class="line">					<span class="comment">/* Must equal I2C_M_TEN below */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SLAVE	0x20	<span class="comment">/* we are the slave */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_HOST_NOTIFY	0x40	<span class="comment">/* We want to use I2C host notify */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_WAKE		0x80	<span class="comment">/* for board_info; true iff can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SCCB		0x9000	<span class="comment">/* Use Omnivision SCCB protocol */</span></span></span><br><span class="line">					<span class="comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit	*/</span></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line">	<span class="type">char</span> name[I2C_NAME_SIZE];       <span class="comment">// 设备的名称</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> *adapter;	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌的device结构体，在注册i2c_client对象时，</span></span><br><span class="line"><span class="comment">     * i2c_client-&gt;dev的总线类型被指定为i2c_bus_type，</span></span><br><span class="line"><span class="comment">     * 其type成员被指定为i2c_client_type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> dev;		<span class="comment">/* the device structure		*/</span></span><br><span class="line">	<span class="type">int</span> init_irq;			<span class="comment">/* irq set at initialization	*/</span></span><br><span class="line">	<span class="type">int</span> irq;			<span class="comment">/* irq issued by device		*/</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> detected;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">i2c_slave_cb_t</span> slave_cb;	<span class="comment">/* callback for slave mode	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_i2c_client(d) container_of(d, struct i2c_client, dev)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-适配器要支持的I2C设备信息-不使用设备树时使用"><a href="#2-2-5-适配器要支持的I2C设备信息-不使用设备树时使用" class="headerlink" title="2.2.5. 适配器要支持的I2C设备信息(不使用设备树时使用)"></a>2.2.5. 适配器要支持的I2C设备信息(不使用设备树时使用)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/i2c.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_board_info - template for device creation</span></span><br><span class="line"><span class="comment"> * @type: chip type, to initialize i2c_client.name</span></span><br><span class="line"><span class="comment"> * @flags: to initialize i2c_client.flags</span></span><br><span class="line"><span class="comment"> * @addr: stored in i2c_client.addr</span></span><br><span class="line"><span class="comment"> * @dev_name: Overrides the default &lt;busnr&gt;-&lt;addr&gt; dev_name if set</span></span><br><span class="line"><span class="comment"> * @platform_data: stored in i2c_client.dev.platform_data</span></span><br><span class="line"><span class="comment"> * @of_node: pointer to OpenFirmware device node</span></span><br><span class="line"><span class="comment"> * @fwnode: device node supplied by the platform firmware</span></span><br><span class="line"><span class="comment"> * @properties: additional device properties for the device</span></span><br><span class="line"><span class="comment"> * @resources: resources associated with the device</span></span><br><span class="line"><span class="comment"> * @num_resources: number of resources in the @resources array</span></span><br><span class="line"><span class="comment"> * @irq: stored in i2c_client.irq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I2C doesn&#x27;t actually support hardware probing, although controllers and</span></span><br><span class="line"><span class="comment"> * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there&#x27;s</span></span><br><span class="line"><span class="comment"> * a device at a given address.  Drivers commonly need more information than</span></span><br><span class="line"><span class="comment"> * that, such as chip type, configuration, associated IRQ, and so on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i2c_board_info is used to build tables of information listing I2C devices</span></span><br><span class="line"><span class="comment"> * that are present.  This information is used to grow the driver model tree.</span></span><br><span class="line"><span class="comment"> * For mainboards this is done statically using i2c_register_board_info();</span></span><br><span class="line"><span class="comment"> * bus numbers identify adapters that aren&#x27;t yet available.  For add-on boards,</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device() does this dynamically with the adapter already known.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_board_info</span> &#123;</span><br><span class="line">	<span class="type">char</span>		type[I2C_NAME_SIZE];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	addr;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*dev_name;</span><br><span class="line">	<span class="type">void</span>		*platform_data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *of_node;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fwnode_handle</span> *fwnode;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">property_entry</span> *properties;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">resource</span> *resources;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	num_resources;</span><br><span class="line">	<span class="type">int</span>		irq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构i2c_board_info的基本字段，声明在特定板上提供的内容</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I2C_BOARD_INFO - macro used to list an i2c device and its address</span></span><br><span class="line"><span class="comment"> * @dev_type: identifies the device type</span></span><br><span class="line"><span class="comment"> * @dev_addr: the device&#x27;s address on the bus.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro initializes essential fields of a struct i2c_board_info,</span></span><br><span class="line"><span class="comment"> * declaring what has been provided on a particular board.  Optional</span></span><br><span class="line"><span class="comment"> * fields (such as associated irq, or device-specific platform_data)</span></span><br><span class="line"><span class="comment"> * are provided using conventional syntax.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span></span><br><span class="line"><span class="meta">	.type = dev_type, .addr = (dev_addr)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-关键结构体之间的关联"><a href="#2-2-6-关键结构体之间的关联" class="headerlink" title="2.2.6. 关键结构体之间的关联"></a>2.2.6. 关键结构体之间的关联</h3><p>下图解释了上述关键结构体之间的关联。在I2C设备驱动注册的过程中，会调用驱动的匹配函数<code>match()</code>与i2c_client(在i2c_adapter注册过程中解析设备树信息生成)进行匹配，匹配成功则调用<code>probe()</code>函数完成驱动注册的收尾工作。设备驱动可通过i2c_adapter中提供的i2c_algorithm，自行构造i2c_msg实现对I2C设备的控制操作。</p>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E5%85%B3%E8%81%94.png?raw=true" alt="关键数据结构之间关联"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>I2C</category>
        <category>设备驱动开发</category>
      </categories>
      <tags>
        <tag>Linux设备驱动开发</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核的I2C子系统详解 - 前言导引</title>
    <url>/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E5%89%8D%E8%A8%80%E5%AF%BC%E5%BC%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
        <category>I2C</category>
        <category>设备驱动开发</category>
      </categories>
      <tags>
        <tag>Linux设备驱动开发</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核的I2C子系统详解 - 通信原理</title>
    <url>/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
        <category>I2C</category>
        <category>设备驱动开发</category>
      </categories>
      <tags>
        <tag>Linux设备驱动开发</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例)</title>
    <url>/2022/08/18/Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/2022-08-18-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%20-%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BB%A5RK3568%E4%B8%BA%E4%BE%8B)/</url>
    <content><![CDATA[<h1 id="1-Linux内核里的I2C驱动框架"><a href="#1-Linux内核里的I2C驱动框架" class="headerlink" title="1. Linux内核里的I2C驱动框架"></a>1. Linux内核里的I2C驱动框架</h1><p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%9B%BE%E7%89%872.png?raw=true" alt="Linux内核里I2C驱动框架"></p>
<p>每一个i2c_adapter对应一条实际的I2C总线。在总线上挂载着I2C设备实物，每个I2C设备对应一个i2c_client，一个i2c_client只能挂载在一个i2c_driver。一般来说，一个i2c_driver可以匹配多个i2c_client，会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如<code>write/read/ioctl</code>。通过调用i2c_adapter提供的通信方法，完成对I2C设备的操作。</p>
<p>根据上图展示的Linux内核里的I2C驱动框架，可以总结出I2C驱动框架的构建流程如下：</p>
<h2 id="1-1-注册I2C子系统核心层-主要是注册I2C总线"><a href="#1-1-注册I2C子系统核心层-主要是注册I2C总线" class="headerlink" title="1.1. 注册I2C子系统核心层(主要是注册I2C总线)"></a>1.1. 注册I2C子系统核心层(主要是注册I2C总线)</h2><p>I2C作为物理总线，通过调用<code>postcore_initcall()</code>函数将<code>i2c_init()</code>函数注册到系统中，使得在内核启动过程中便会调用初始化函数<code>i2c_init()</code>完成I2C总线注册(SPI同理)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">i2c_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = <span class="built_in">of_alias_get_highest_id</span>(<span class="string">&quot;i2c&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">down_write</span>(&amp;__i2c_board_lock);</span><br><span class="line">	<span class="keyword">if</span> (retval &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">		__i2c_first_dynamic_bus_num = retval + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">up_write</span>(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">	retval = <span class="built_in">bus_register</span>(&amp;i2c_bus_type);       <span class="comment">// 注册I2C总线</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	is_registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	i2c_adapter_compat_class = <span class="built_in">class_compat_register</span>(<span class="string">&quot;i2c-adapter&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_err;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	retval = <span class="built_in">i2c_add_driver</span>(&amp;dummy_driver);         <span class="comment">// 注册一个空驱动</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ENABLED</span>(CONFIG_OF_DYNAMIC))</span><br><span class="line">		<span class="built_in">WARN_ON</span>(<span class="built_in">of_reconfig_notifier_register</span>(&amp;i2c_of_notifier));</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ENABLED</span>(CONFIG_ACPI))</span><br><span class="line">		<span class="built_in">WARN_ON</span>(<span class="built_in">acpi_reconfig_notifier_register</span>(&amp;i2c_acpi_notifier));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	<span class="built_in">class_compat_unregister</span>(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	is_registered = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">bus_unregister</span>(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I2C总线上分别存储了i2c_driver链和i2c_client链。当任何一个i2c_driver或者i2c_client去注册时，I2C总线都会调用<code>i2c_device_match()</code>函数对<code>i2c_client.name</code>和<code>i2c_driver.id_table[].name</code>进行循环匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bus_type</span> i2c_bus_type = &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,         <span class="comment">// 负责总线上的device和driver匹配</span></span><br><span class="line">	.probe		= i2c_device_probe,         <span class="comment">// 在匹配成功后会执行以完成注册的收尾工作</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(i2c_bus_type);        <span class="comment">// 模块导出，可供其他模块使用</span></span><br><span class="line"><span class="comment">// 负责总线上的device和driver匹配的函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client = <span class="built_in">i2c_verify_client</span>(dev);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_driver</span>	*driver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">i2c_of_match_device</span>(drv-&gt;of_match_table, client))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">acpi_driver_match_device</span>(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	driver = <span class="built_in">to_i2c_driver</span>(drv);                    <span class="comment">// 找到i2c_driver</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finally an I2C match */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">i2c_match_id</span>(driver-&gt;id_table, client))     <span class="comment">// 用i2c_driver的id_table和device匹配。驱动名多个，但设备名只有一个，说明一个驱动可以对应多个设备(尤其是同一类型)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>i2c_device_match()</code>函数的源码可知：如果<code>i2c_driver.id_table[]</code>中没有能够和<code>client</code>匹配的，函数将直接返回。如果能够匹配，则返回1。并且I2C总线在后续会调用<code>probe()</code>函数完成注册的收尾工作。</p>
<p>但是要搞清楚<code>match()</code>和<code>probe()</code>函数是何时被何者所调用的，则还需进行深入了解。根据描述知道<code>probe()</code>函数执行于<code>match()</code>函数之后，且匹配触发的前提是要有i2c_driver或者i2c_client注册。所以尝试从i2c_driver的注册代码中寻找答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span></span><br><span class="line"><span class="comment"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">module</span> *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;driver-&gt;clients);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment">	 * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = <span class="built_in">driver_register</span>(&amp;driver-&gt;driver);     <span class="comment">// 实际注册位置</span></span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_register_driver);</span><br></pre></td></tr></table></figure>
<p>注意到<code>i2c_register_driver</code>函数中实际是调用了<code>driver_register()</code>函数完成注册，继续寻找函数中有关总线的调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/driver.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_register - register driver with bus</span></span><br><span class="line"><span class="comment"> * @drv: driver to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We pass off most of the work to the bus_add_driver() call,</span></span><br><span class="line"><span class="comment"> * since most of the things we have to do deal with the bus</span></span><br><span class="line"><span class="comment"> * structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	ret = <span class="built_in">bus_add_driver</span>(drv);              <span class="comment">// 在总线上添加传递的驱动(将驱动添加到总线的驱动链表中)</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(driver_register);</span><br></pre></td></tr></table></figure>
<p><code>driver_register()</code>函数中调用了<code>bus_add_driver()</code>函数，将驱动添加到总线上，持续跟踪直到找到有关<code>match</code>和<code>probe</code>的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_add_driver - Add a driver to the bus.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bus_add_driver</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe)     <span class="comment">// 提到probe</span></span><br><span class="line">    &#123;</span><br><span class="line">		error = <span class="built_in">driver_attach</span>(drv);         <span class="comment">// 跟踪driver_attach();</span></span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_attach - try to bind driver to devices.</span></span><br><span class="line"><span class="comment"> * @drv: driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Walk the list of devices that the bus has on it and try to</span></span><br><span class="line"><span class="comment"> * match the driver with each one.  If driver_probe_device()</span></span><br><span class="line"><span class="comment"> * returns 0 and the @dev-&gt;driver is set, we&#x27;ve found a</span></span><br><span class="line"><span class="comment"> * compatible pair.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bus_for_each_dev</span>(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);  <span class="comment">// 继续跟踪发现实际是在调用__driver_attach();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(driver_attach);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_for_each_dev - device iterator.</span></span><br><span class="line"><span class="comment"> * @bus: bus type.</span></span><br><span class="line"><span class="comment"> * @start: device to start iterating from.</span></span><br><span class="line"><span class="comment"> * @data: data for the callback.</span></span><br><span class="line"><span class="comment"> * @fn: function to be called for each device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over @bus&#x27;s list of devices, and call @fn for each,</span></span><br><span class="line"><span class="comment"> * passing it @data. If @start is not NULL, we use that device to</span></span><br><span class="line"><span class="comment"> * begin iterating from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We check the return of @fn each time. If it returns anything</span></span><br><span class="line"><span class="comment"> * other than 0, we break out and return that value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> The device that returns a non-zero value is not retained</span></span><br><span class="line"><span class="comment"> * in any way, nor is its refcount incremented. If the caller needs</span></span><br><span class="line"><span class="comment"> * to retain this data, it should do so, and increment the reference</span></span><br><span class="line"><span class="comment"> * count in the supplied callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bus_for_each_dev</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">struct</span> device *start,</span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="type">void</span> *data, <span class="type">int</span> (*fn)(<span class="keyword">struct</span> device *, <span class="type">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">klist_iter</span> i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bus || !bus-&gt;p)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">klist_iter_init_node</span>(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,</span><br><span class="line">			     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class="literal">NULL</span>));	<span class="comment">// 	链表头开始遍历连接在总线上的设备链表</span></span><br><span class="line">	<span class="keyword">while</span> (!error &amp;&amp; (dev = <span class="built_in">next_device</span>(&amp;i)))</span><br><span class="line">		error = <span class="built_in">fn</span>(dev, data);</span><br><span class="line">	<span class="built_in">klist_iter_exit</span>(&amp;i);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(bus_for_each_dev);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __driver_attach(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_driver</span> *drv = data;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock device and try to bind to it. We drop the error</span></span><br><span class="line"><span class="comment">	 * here and always return 0, because we need to keep trying</span></span><br><span class="line"><span class="comment">	 * to bind to devices and some drivers will return an error</span></span><br><span class="line"><span class="comment">	 * simply if it didn&#x27;t support the device.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * driver_probe_device() will spit a warning if there</span></span><br><span class="line"><span class="comment">	 * is an error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">driver_match_device</span>(drv, dev);        <span class="comment">// 驱动和设备匹配</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* no match */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Device match requests probe deferral\n&quot;</span>);</span><br><span class="line">		<span class="built_in">driver_deferred_probe_add</span>(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Bus failed to match device: %d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="comment">/* ret &gt; 0 means positive match */</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">device_driver_attach</span>(drv, dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * device_driver_attach - attach a specific driver to a specific device</span></span><br><span class="line"><span class="comment"> * @drv: Driver to attach</span></span><br><span class="line"><span class="comment"> * @dev: Device to attach it to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Manually attach driver to a device. Will acquire both @dev lock and</span></span><br><span class="line"><span class="comment"> * @dev-&gt;parent lock if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">device_driver_attach</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	__device_driver_lock(dev, dev-&gt;parent);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If device has been removed or someone has already successfully</span></span><br><span class="line"><span class="comment">	 * bound a driver before us just skip the driver probe call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)</span><br><span class="line">		ret = <span class="built_in">driver_probe_device</span>(drv, dev);</span><br><span class="line">	__device_driver_unlock(dev, dev-&gt;parent);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * driver_probe_device - attempt to bind device &amp; driver together</span></span><br><span class="line"><span class="comment"> * @drv: driver to bind a device to</span></span><br><span class="line"><span class="comment"> * @dev: device to try to bind to the driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns -ENODEV if the device is not registered,</span></span><br><span class="line"><span class="comment"> * 1 if the device is bound successfully and 0 otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be called with @dev lock held.  When called for a</span></span><br><span class="line"><span class="comment"> * USB interface, @dev-&gt;parent lock must be held as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the device has a parent, runtime-resume the parent before driver probing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">driver_probe_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">pm_runtime_barrier</span>(dev);</span><br><span class="line">	<span class="keyword">if</span> (initcall_debug)</span><br><span class="line">		ret = <span class="built_in">really_probe_debug</span>(dev, drv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = <span class="built_in">really_probe</span>(dev, drv);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/base.h */</span> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">driver_match_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;<span class="built_in">match</span>(dev, drv) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，可知是<code>driver_match_device</code>函数调用了I2C总线的<code>match()</code>函数完成对驱动和设备的匹配工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">really_probe</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;<span class="built_in">probe</span>(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;<span class="built_in">probe</span>(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client = <span class="built_in">i2c_verify_client</span>(dev);   <span class="comment">// 设备</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_driver</span>	*driver;                            <span class="comment">// 驱动</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)           <span class="comment">// 找不到设备，失败，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	client-&gt;irq = client-&gt;init_irq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">		<span class="type">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY) &#123;</span><br><span class="line">			<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;Using Host Notify IRQ\n&quot;</span>);</span><br><span class="line">			<span class="comment">/* Keep adapter active when Host Notify is required */</span></span><br><span class="line">			<span class="built_in">pm_runtime_get_sync</span>(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line">			irq = <span class="built_in">i2c_smbus_host_notify_to_irq</span>(client);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">			irq = <span class="built_in">of_irq_get_byname</span>(dev-&gt;of_node, <span class="string">&quot;irq&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (irq == -EINVAL || irq == -ENODATA)</span><br><span class="line">				irq = <span class="built_in">of_irq_get</span>(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ACPI_COMPANION</span>(dev)) &#123;</span><br><span class="line">			irq = <span class="built_in">i2c_acpi_get_irq</span>(client);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = irq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">			irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		client-&gt;irq = irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	driver = <span class="built_in">to_i2c_driver</span>(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * An I2C ID table is not mandatory, if and only if, a suitable OF</span></span><br><span class="line"><span class="comment">	 * or ACPI ID table is supplied for the probing device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;id_table &amp;&amp;</span><br><span class="line">	    !<span class="built_in">acpi_driver_match_device</span>(dev, dev-&gt;driver) &amp;&amp;</span><br><span class="line">	    !<span class="built_in">i2c_of_match_device</span>(dev-&gt;driver-&gt;of_match_table, client)) &#123;</span><br><span class="line">		status = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line">		<span class="type">int</span> wakeirq;</span><br><span class="line"></span><br><span class="line">		wakeirq = <span class="built_in">of_irq_get_byname</span>(dev-&gt;of_node, <span class="string">&quot;wakeup&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (wakeirq == -EPROBE_DEFER) &#123;</span><br><span class="line">			status = wakeirq;</span><br><span class="line">			<span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">device_init_wakeup</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span> &amp;&amp; wakeirq != client-&gt;irq)</span><br><span class="line">			status = <span class="built_in">dev_pm_set_dedicated_wake_irq</span>(dev, wakeirq);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">			status = <span class="built_in">dev_pm_set_wake_irq</span>(dev, client-&gt;irq);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">			<span class="built_in">dev_warn</span>(&amp;client-&gt;dev, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">of_clk_set_defaults</span>(dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">dev_pm_domain_attach</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过函数指针的方式调用了i2c_driver的probe函数。即当一个device和一个driver匹配上以后还会去执行driver里面的probe函数完成i2c_driver注册的收尾工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * When there are no more users of probe(),</span></span><br><span class="line"><span class="comment">	 * rename probe_new to probe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;probe_new)</span><br><span class="line">		status = driver-&gt;<span class="built_in">probe_new</span>(client);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (driver-&gt;probe)</span><br><span class="line">		status = driver-&gt;<span class="built_in">probe</span>(client,</span><br><span class="line">				       <span class="built_in">i2c_match_id</span>(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		status = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">	<span class="built_in">dev_pm_domain_detach</span>(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">	<span class="built_in">dev_pm_clear_wake_irq</span>(&amp;client-&gt;dev);</span><br><span class="line">	<span class="built_in">device_init_wakeup</span>(&amp;client-&gt;dev, <span class="literal">false</span>);</span><br><span class="line">put_sync_adapter:</span><br><span class="line">	<span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY)</span><br><span class="line">		<span class="built_in">pm_runtime_put_sync</span>(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合<code>really_probe()</code>函数和I2C总线的<code>i2c_device_probe()</code>函数，可以知道是i2c_driver在注册的过程中调用了<code>really_probe()</code>函数从而调用I2C总线的<code>i2c_device_probe()</code>函数，进而调用i2c_driver自己的<code>probe()</code>函数，从而完成硬件初始化等后续工作。</p>
<h2 id="1-2-注册i2c-adapter并将其添加到I2C总线"><a href="#1-2-注册i2c-adapter并将其添加到I2C总线" class="headerlink" title="1.2. 注册i2c_adapter并将其添加到I2C总线"></a>1.2. 注册i2c_adapter并将其添加到I2C总线</h2><p><code>i2c_adapter</code>在硬件上对应Soc的I2C控制器，在内核中被认为是一个设备，而其对应驱动即是总线驱动。它向接在I2C控制器上的I2C设备提供在I2C总线上通信的基础方法，通过操作Soc的I2C控制器相关的寄存器实现数据收发。<code>i2c_adapter</code>一般通过两种方法注册：</p>
<ul>
<li>一种做法是为I2C适配器创建一个platform设备注册到<code>platform_bus_type</code>总线上与I2C适配器的platform驱动匹配，在驱动的probe函数中向I2C总线添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
<li>另一种做法是I2C适配器作为pci设备注册到PCI总线上与I2C适配器的pci驱动匹配，在驱动的probe函数中向i2c_bus_type添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
</ul>
<p>RK平台采用的是第一种方法。总线驱动的文件存储在路径<code>/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses</code>中，RK平台的总线驱动文件为<code>i2c-rk3x.c</code>。</p>
<h3 id="1-2-1-关键数据结构定义"><a href="#1-2-1-关键数据结构定义" class="headerlink" title="1.2.1. 关键数据结构定义"></a>1.2.1. 关键数据结构定义</h3><ul>
<li>总线驱动定义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> rk3x_i2c_driver = &#123;</span><br><span class="line">    <span class="comment">/** .probe()：</span></span><br><span class="line"><span class="comment">     * 当驱动注册完毕，并且匹配成功，则会自动调用该方法对硬件进行初始化操作：</span></span><br><span class="line"><span class="comment">     * a. 注册设备号，并且注册fops(为用户提供设备标示，同时提供文件操作io接口)</span></span><br><span class="line"><span class="comment">     * b. 创建设备节点</span></span><br><span class="line"><span class="comment">     * c. 初始化硬件的各项信息，如ioremap(io地址映射虚拟地址)</span></span><br><span class="line"><span class="comment">     * d. 实现各种io功能接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    .probe   = rk3x_i2c_probe,      </span><br><span class="line">    .remove  = rk3x_i2c_remove,</span><br><span class="line">    .driver  = &#123;</span><br><span class="line">        .name  = <span class="string">&quot;rk3x-i2c&quot;</span>,                <span class="comment">// 用于驱动和设备匹配，确保驱动和设备一致，否则无法匹配成功</span></span><br><span class="line">        .of_match_table = rk3x_i2c_match,   <span class="comment">// 匹配表</span></span><br><span class="line">        .pm = &amp;rk3x_i2c_pm_ops,	            <span class="comment">// dev_pm_ops类型的结构体，用来赋值设备完成运行时的电源管理</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>总线驱动通信方法定义<blockquote>
<p>因为每家芯片厂商SoC内部的I2C控制器是不一样的，所以 <code>i2c_algorithm</code> 中直接涉及硬件层面上的代码都是由芯片商提供。例如：对I2C控制器的寄存器操作。 <code>i2c_algorithm</code> 提供的通信函数控制适配器产生特定的访问信号，虽然不同的I2C总线控制器被抽象成不同的 <code>i2c_adapter</code> ，但是如果操作方式相同，则可以共享同一个 <code>i2c_algorithm</code> 。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 总线驱动通信方法定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> rk3x_i2c_algorithm = &#123;</span><br><span class="line">    .master_xfer		= rk3x_i2c_xfer,            <span class="comment">// 通信方法，如果不支持I2C访问，则为NULL</span></span><br><span class="line">    .master_xfer_atomic	= rk3x_i2c_xfer_polling,            <span class="comment">// 通信方法，仅使用于原子上下文</span></span><br><span class="line">    .functionality		= rk3x_i2c_func,            <span class="comment">// 检测通信方法支持的功能或协议，设备驱动一般会调用这个回调来确认适配器支持的协议类型</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-设备树信息"><a href="#1-2-2-设备树信息" class="headerlink" title="1.2.2. 设备树信息"></a>1.2.2. 设备树信息</h3><p>RK3568共有6个I2C控制器，分别为I2C0~I2C5，每个控制器对应不同的寄存器基地址(i2c0是0xfdd40000)， <code>.compatible</code> 属性都是 <code>rockchip, rk3399-i2c</code> ，即对应了同一个adapter驱动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi */</span></span><br><span class="line">    i2c0: i2c@fdd40000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd40000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;  <span class="comment">// 起始地址0xfdd40000, 长度0x10000</span></span><br><span class="line">        clocks = &lt;&amp;pmucru CLK_I2C0&gt;, &lt;&amp;pmucru PCLK_I2C0&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">46</span> IRQ_TYPE_LEVEL_HIGH&gt;;  <span class="comment">// 中断和触发方式</span></span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;   <span class="comment">//表示用一个32位的数来描述地址</span></span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;      <span class="comment">//表示用0个32位的数来描述该地址的大小</span></span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;    <span class="comment">// 目前状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">    i2c1: i2c@fe5a0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5a0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C1&gt;, &lt;&amp;cru PCLK_I2C1&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">47</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c1_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c2: i2c@fe5b0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5b0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C2&gt;, &lt;&amp;cru PCLK_I2C2&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">48</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c2m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c3: i2c@fe5c0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5c0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C3&gt;, &lt;&amp;cru PCLK_I2C3&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">49</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c3m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c4: i2c@fe5d0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5d0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C4&gt;, &lt;&amp;cru PCLK_I2C4&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">50</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c4m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i2c5: i2c@fe5e0000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5e0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru CLK_I2C5&gt;, &lt;&amp;cru PCLK_I2C5&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">51</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;i2c5m0_xfer&gt;;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 <code>rk3x_i2c_driver</code> 作为一个 <code>platform_driver</code> 注册到内核， <code>rk3x_i2c_match</code> 作为结构体中的参数实际是一个记录设备信息的结构体数组。系统启动后会比较DTS中的匹配属性与驱动匹配表中是否相符，如果相符则会进入 <code>rk3x_i2c_probe</code> 接口，完成驱动各项参数的初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// rk3x_i2c_driver结构体中.driver的匹配表参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> rk3x_i2c_match[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1108-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1108_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1126-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1126_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3066-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3066_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3188-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3188_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3228-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3228_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3288-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3288_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>, <span class="comment">// 符合DTS中描述的匹配字符串</span></span><br><span class="line">        .data = &amp;rk3399_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param usb               设备名</span></span><br><span class="line"><span class="comment"> * @param skel_table        该设备加入到模块中时对应产生的设备搜索符号</span></span><br><span class="line"><span class="comment"> * @return 生成一个名为__mod_pci_device_table局部变量，这个变量指向第二个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">MODULE_DEVICE_TABLE</span>(of, rk3x_i2c_match); <span class="comment">// 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-注册和卸载i2c-adapter"><a href="#1-2-3-注册和卸载i2c-adapter" class="headerlink" title="1.2.3. 注册和卸载i2c_adapter"></a>1.2.3. 注册和卸载i2c_adapter</h3><p>为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 <code>module_platform_driver</code> 替换 <code>module_init</code> 和 <code>module_exit</code> (实际还要调用一次宏定义函数 <code>module_driver</code> 才能完成替换)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/platform_device.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_platform_driver() - Helper macro for drivers that don&#x27;t do</span></span><br><span class="line"><span class="comment"> * anything special in module init/exit.  </span></span><br><span class="line"><span class="comment"> * This eliminates a lot of boilerplate.  </span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and</span></span><br><span class="line"><span class="comment"> * calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_platform_driver(__platform_driver) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="built_in">module_driver</span>(__platform_driver, platform_driver_register, \</span><br><span class="line">            platform_driver_unregister)</span><br><span class="line">			</span><br><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/device/driver.h */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in module init/exit. This eliminates a lot of boilerplate.</span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * module_init() and module_exit().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @__unregister: unregister function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register and __unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta"><span class="comment">// 注册方法，替代module_init()</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init __driver##_init(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_init</span>(__driver##_init); \</span><br><span class="line"><span class="comment">// 卸载方法，替代module_exit()</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __driver##_exit(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_exit</span>(__driver##_exit); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-i2c-adapter相关函数配置"><a href="#1-2-4-i2c-adapter相关函数配置" class="headerlink" title="1.2.4. i2c_adapter相关函数配置"></a>1.2.4. i2c_adapter相关函数配置</h3><ul>
<li>注册收尾函数probe()</li>
</ul>
<blockquote>
<p><code>platform_driver</code> 在注册时会遍历 <code>platform</code> 总线上的 <code>platform_device</code> ，当条件( <code>.compatible</code> 属性或 <code>id_table</code> )匹配(通过得分机制，得分最高的最终会匹配成功)时，便会调用 <code>rk3x_i2c_probe</code> 函数。如何调用参考上文总线部分的<code>i2c_driver</code>的<code>probe()</code>函数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> *match;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c;	<span class="comment">// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u32 value;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> clk_rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作</span></span><br><span class="line"><span class="comment">     * devm_kzalloc — Resource-managed kzalloc</span></span><br><span class="line"><span class="comment">     * @param pdev: 申请内存的目标设备</span></span><br><span class="line"><span class="comment">     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。</span></span><br><span class="line"><span class="comment">     * @return: 成功返回首地址，失败返回NULL</span></span><br><span class="line"><span class="comment">     * 为适配器结构体申请内存，为后续实例化完成基础工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> rk3x_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (!i2c)	<span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到rk3x_i2c_match数组里与之匹配的那个struct of_device_id</span></span><br><span class="line"><span class="comment">     * i2c_adapter驱动会兼容多个RK平台(如rk3188/rk3288/rk3399等)的i2c控制器，</span></span><br><span class="line"><span class="comment">     * 各个平台有些差异，差异性的信息可以通过.data这个成员指针保存起来，用到的时候再取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = <span class="built_in">of_match_node</span>(rk3x_i2c_match, np); </span><br><span class="line">    <span class="comment">// 取出所匹配的i2c控制器的配置信息</span></span><br><span class="line">    i2c-&gt;soc_data = match-&gt;data; </span><br><span class="line">    <span class="comment">/* use common interface to get I2C timing properties */</span></span><br><span class="line">    <span class="built_in">i2c_parse_fw_timings</span>(&amp;pdev-&gt;dev, &amp;i2c-&gt;t, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// i2c_adapter部分成员初始化</span></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">strlcpy</span>(i2c-&gt;adap.name, <span class="string">&quot;rk3x-i2c&quot;</span>, <span class="built_in">sizeof</span>(i2c-&gt;adap.name));</span><br><span class="line">    <span class="comment">// 拥有者</span></span><br><span class="line">    i2c-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">// 通信方法</span></span><br><span class="line">    i2c-&gt;adap.algo = &amp;rk3x_i2c_algorithm;</span><br><span class="line">    i2c-&gt;adap.retries = <span class="number">3</span>;</span><br><span class="line">    i2c-&gt;adap.dev.of_node = np;</span><br><span class="line">    i2c-&gt;adap.algo_data = i2c;</span><br><span class="line">    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">    i2c-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;i2c-&gt;lock);</span><br><span class="line">    <span class="comment">// 初始化等待队列头部，等待在进程调度中使用</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;i2c-&gt;wait);</span><br><span class="line">    <span class="comment">// 通知链机制，在内核重启之前会调用回调函数rk3x_i2c_restart_notify</span></span><br><span class="line">    i2c-&gt;i2c_restart_nb.notifier_call = rk3x_i2c_restart_notify;</span><br><span class="line">    i2c-&gt;i2c_restart_nb.priority = <span class="number">128</span>;</span><br><span class="line">    ret = <span class="built_in">register_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;failed to setup i2c restart handler.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从dts中获取设备的物理基址</span></span><br><span class="line">    i2c-&gt;regs = <span class="built_in">devm_platform_ioremap_resource</span>(pdev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;regs))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(i2c-&gt;regs);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Switch to new interface if the SoC also offers the old one.</span></span><br><span class="line"><span class="comment">	 * The control bit is located in the GRF register space.</span></span><br><span class="line"><span class="comment">	 * grf_offset: offset inside the grf regmap for setting the i2c type</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;grf_offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">regmap</span> *grf; </span><br><span class="line">        grf = <span class="built_in">syscon_regmap_lookup_by_phandle</span>(np, <span class="string">&quot;rockchip,grf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(grf)) &#123;</span><br><span class="line">            <span class="type">int</span> bus_nr;</span><br><span class="line">            <span class="comment">/* Try to set the I2C adapter number from dt */</span></span><br><span class="line">            bus_nr = <span class="built_in">of_alias_get_id</span>(np, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bus_nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;rk3x-i2c needs i2cX alias&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1108_soc_data &amp;&amp; bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1108 i2c2 set grf offset-0x408, bit-10 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">26</span>) | <span class="built_in">BIT</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1126_soc_data &amp;&amp;</span><br><span class="line">                    bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1126 i2c2 set pmugrf offset-0x118, bit-4 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">20</span>) | <span class="built_in">BIT</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* rk3xxx 27+i: write mask, 11+i: value */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">27</span> + bus_nr) | <span class="built_in">BIT</span>(<span class="number">11</span> + bus_nr);</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">regmap_write</span>(grf, i2c-&gt;soc_data-&gt;grf_offset,</span><br><span class="line">                        value);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;Could not write to GRF: %d\n&quot;</span>,</span><br><span class="line">                    ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* IRQ setup(中断设置) */</span></span><br><span class="line">    irq = <span class="built_in">platform_get_irq</span>(pdev, <span class="number">0</span>);	<span class="comment">// platform_device结构体中存储有所用到的中断号</span></span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> irq;</span><br><span class="line">    ret = <span class="built_in">devm_request_irq</span>(&amp;pdev-&gt;dev, irq, rk3x_i2c_irq,</span><br><span class="line">                    <span class="number">0</span>, <span class="built_in">dev_name</span>(&amp;pdev-&gt;dev), i2c);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;cannot request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储用户主动申请的内存区域指针防止丢失</span></span><br><span class="line">    <span class="built_in">platform_set_drvdata</span>(pdev, i2c);</span><br><span class="line">    <span class="comment">// 平台时钟设置</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;calc_timings == rk3x_i2c_v0_calc_timings) &#123;</span><br><span class="line">        <span class="comment">/* Only one clock to use for bus clock and peripheral clock */</span></span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">        i2c-&gt;pclk = i2c-&gt;clk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        i2c-&gt;pclk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;clk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;clk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get bus clk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;pclk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;pclk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get periph clk\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare bus clk: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare periph clock: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> err_clk;</span><br><span class="line">    &#125;</span><br><span class="line">    i2c-&gt;clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;</span><br><span class="line">    ret = <span class="built_in">clk_notifier_register</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to register clock notifier\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_pclk;</span><br><span class="line">    &#125;</span><br><span class="line">    clk_rate = <span class="built_in">clk_get_rate</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">rk3x_i2c_adapt_div</span>(i2c, clk_rate);</span><br><span class="line">    <span class="comment">// 向内核添加i2c_adapter</span></span><br><span class="line">    ret = <span class="built_in">i2c_add_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err_clk_notifier;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clk_notifier:</span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">err_pclk:</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">err_clk:</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放函数remove()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得rk3x_i2c_probe中存储的主动申请的内存区域指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = <span class="built_in">platform_get_drvdata</span>(pdev);</span><br><span class="line">    <span class="comment">// 卸载i2c_adapter</span></span><br><span class="line">    <span class="built_in">i2c_del_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销时钟</span></span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="built_in">unregister_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb); </span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>通信方法函数master_xfer()</li>
</ul>
<blockquote>
<p>实现总线上数据传输，rk3x_i2c提供了两种方式来处理阻塞进程唤醒。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 使用等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_polling</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num, <span class="type">bool</span> polling)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = (<span class="keyword">struct</span> rk3x_i2c *)adap-&gt;algo_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> timeout, flags;</span><br><span class="line">    u32 val;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;suspended)</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 使能时钟</span></span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">    i2c-&gt;is_last_msg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * Process msgs. We can handle more than one message at once (see</span></span><br><span class="line"><span class="comment">        * rk3x_i2c_setup()).</span></span><br><span class="line"><span class="comment">        * i+ret就是指一次循环处理多条msg</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i += ret) &#123;</span><br><span class="line">        ret = <span class="built_in">rk3x_i2c_setup</span>(i2c, msgs + i, num - i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i2c msg处理出错</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;rk3x_i2c_setup() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ret为本轮已处理的msgs数量，i为过去已处理的msgs数量，如果刚好等于msgs总数，则</span></span><br><span class="line">        <span class="keyword">if</span> (i + ret &gt;= num)</span><br><span class="line">            i2c-&gt;is_last_msg = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 启动i2c_adapter</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_start</span>(i2c);	</span><br><span class="line">        <span class="comment">// 释放自旋锁，并恢复标志寄存器的值为变量flags保存的值</span></span><br><span class="line">        <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区分调用的是rk3x_i2c_xfer还是rk3x_i2c_xfer_polling</span></span><br><span class="line">        <span class="keyword">if</span> (!polling) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                * 调用rk3x_i2c_xfer, 挂起等待队列头i2c-&gt;wait(wait_queue_head_t)。</span></span><br><span class="line"><span class="comment">                * 直到i2c_adapter不再繁忙或者等待超时，则调用wake_up(i2c-&gt;wait)会唤醒进程并继续往下执行</span></span><br><span class="line"><span class="comment">                * 如果未超时且i2c_adapter繁忙，则进程会被阻塞</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">            timeout = <span class="built_in">wait_event_timeout</span>(i2c-&gt;wait, !i2c-&gt;busy,</span><br><span class="line">                                <span class="built_in">msecs_to_jiffies</span>(WAIT_TIMEOUT));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">rk3x_i2c_wait_xfer_poll</span>(i2c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得自旋锁，并且备份本地中断和中断状态到flags变量</span></span><br><span class="line">        <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时了</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;timeout, ipd: 0x%02x, state: %d\n&quot;</span>,</span><br><span class="line">                <span class="built_in">i2c_readl</span>(i2c, REG_IPD), i2c-&gt;state);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Force a STOP condition without interrupt */</span></span><br><span class="line">            <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">            val = <span class="built_in">i2c_readl</span>(i2c, REG_CON) &amp; REG_CON_TUNING_MASK;</span><br><span class="line">            val |= REG_CON_EN | REG_CON_STOP;</span><br><span class="line">            <span class="built_in">i2c_writel</span>(i2c, val, REG_CON);</span><br><span class="line"></span><br><span class="line">            i2c-&gt;state = STATE_IDLE;</span><br><span class="line"></span><br><span class="line">            ret = -ETIMEDOUT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时，但是i2c_adapter运行中产生错误</span></span><br><span class="line">        <span class="keyword">if</span> (i2c-&gt;error) &#123;</span><br><span class="line">            ret = i2c-&gt;error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺利完成i2c通信？</span></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭i2c总线</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭时钟</span></span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;clk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出错返回ret，成功返回处理msgs的数量</span></span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_wait_xfer_poll</span><span class="params">(<span class="keyword">struct</span> rk3x_i2c *i2c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ktime_get()得到当前时间，ktime_add_ms来设置超时时间。</span></span><br><span class="line">    <span class="type">ktime_t</span> timeout = <span class="built_in">ktime_add_ms</span>(<span class="built_in">ktime_get</span>(), WAIT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * READ_ONCE是一个用来读取变量的宏，为了避免编译器优化导致多线程时读取出错而编写</span></span><br><span class="line"><span class="comment">        * ktime_compare用来确定是否超时</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">READ_ONCE</span>(i2c-&gt;busy) &amp;&amp;</span><br><span class="line">            <span class="built_in">ktime_compare</span>(<span class="built_in">ktime_get</span>(), timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没超时且i2c_adapter繁忙，则延时等待</span></span><br><span class="line">        <span class="built_in">udelay</span>(<span class="number">5</span>); </span><br><span class="line">        <span class="comment">// 设置中断</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_irq</span>(<span class="number">0</span>, i2c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回i2c_adapter的状态</span></span><br><span class="line">    <span class="keyword">return</span> !i2c-&gt;busy; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>功能检测函数func()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */</span></span><br><span class="line"><span class="comment">// 无格式i2c-level命令(Pure SMBus适配器不能用这些命令)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="comment">// 处理所有的能够被I2C adapter仿真的SMBus命令(RK平台的控制器兼容I2C与SMBus总线)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE | \</span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WORD_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PROC_CALL | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_I2C_BLOCK | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PEC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟知的有I2C_M_IGNORE_NAK, I2C_M_REV_DIR_ADDR, I2C_M_NOSTART, I2C_MNO_RD_ACK等flags(I2C寄存器状态？)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 <span class="comment">/* I2C_M_IGNORE_NAK etc. */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_quick命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="comment">//  处理SMBus read_byte &amp; write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data &amp; write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data &amp; write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus process_call命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="comment">// 处理SMBus wrtie_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data &amp; write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 <span class="comment">/* I2C-like block xfer  */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 <span class="comment">/* w/ 1-byte reg. addr. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出所支持的命令集(检测通信方法支持的功能或协议)</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">rk3x_i2c_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-添加到I2C总线"><a href="#1-2-5-添加到I2C总线" class="headerlink" title="1.2.5. 添加到I2C总线"></a>1.2.5. 添加到I2C总线</h3><p>I2C核心层为i2c_adapter开放了添加适配器的接口函数i2c_add_adapter()。在注册收尾工作<code>rk3x_i2c_probe()</code>函数的最后，调用<code>i2c_add_adapter()</code>函数向I2C总线添加i2c_adapter。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter - declare i2c adapter, use dynamic bus number</span></span><br><span class="line"><span class="comment"> * @adapter: the adapter to add</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine is used to declare an I2C adapter when its bus number</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t matter or when its bus number is specified by an dt alias.</span></span><br><span class="line"><span class="comment"> * Examples of bases when the bus number doesn&#x27;t matter: I2C adapters</span></span><br><span class="line"><span class="comment"> * dynamically added by USB links or PCI plugin cards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When this returns zero, a new bus number was allocated and stored</span></span><br><span class="line"><span class="comment"> * in adap-&gt;nr, and the specified adapter became available for clients.</span></span><br><span class="line"><span class="comment"> * Otherwise, a negative errno value is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev = &amp;adapter-&gt;dev;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在设备树节点(在rk3x_i2c_probe中赋值)</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">        <span class="comment">// 获得总线号，因为总线驱动可以兼容多个同一平台的I2C控制器。一般会在dts里指定，即静态分配ID号</span></span><br><span class="line">		id = <span class="built_in">of_alias_get_id</span>(dev-&gt;of_node, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果找到I2C总线号则直接注册</span></span><br><span class="line">		<span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			<span class="keyword">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 为i2c_adapter动态分配ID并绑定</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adapter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_add_adapter); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>i2c_add_adapter</code>()函数有两种添加到总线的方式。如果在遍历设备树过程中获得了I2C总线的总线号，那么调用<code>__i2c_add_numbered_adapter()</code>静态添加。如果找不到，则需要动态添加，调用<code>i2c_register_adapter()</code>注册到I2C总线。</p>
<p><code>of_alias_get_id()</code>函数遍历设备树的alias节点下的设备节点，通过传入的两个参数查找设备树中与adapter匹配的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_alias_get_id</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *stem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">alias_prop</span> *app;</span><br><span class="line">	<span class="type">int</span> id = -ENODEV;</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;of_mutex);</span><br><span class="line">    <span class="comment">// 遍历链表aliases_lookup(成员为alias_prop)，逐一对比字符串stem。</span></span><br><span class="line">	<span class="built_in">list_for_each_entry</span>(app, &amp;aliases_lookup, link) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉dtsi中aliases节点内的非I2C节点</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(app-&gt;stem, stem) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果字符串匹配且找到对应的设备树节点，则说明找到了adapter(I2C控制器)设备节点的ID号</span></span><br><span class="line">		<span class="keyword">if</span> (np == app-&gt;np) &#123;</span><br><span class="line">			id = app-&gt;id;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;of_mutex);</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__i2c_add_numbered_adapter()</code>函数将i2c_adapter静态添加到I2C总线，代码部分实际和动态添加非常相似(不过是调用函数时传入的形参不同)。最终也是调用<code>i2c_register_adapter()</code>注册到I2C总线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1</span></span><br><span class="line"><span class="comment"> * @adap: the adapter to register (with adap-&gt;nr initialized)</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See i2c_add_numbered_adapter() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __i2c_add_numbered_adapter(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 使id号和adapter结构体按照IDR机制关联起来(IDR用类基树结构构造稀疏数组，以ID为索引来找到对应数组元素，进而找到对应的数据结构指针)</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adap, adap-&gt;nr, adap-&gt;nr + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">    <span class="comment">// 注册i2c_adapter</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>i2c_adapter注册总线的核心函数<code>i2c_register_adapter()</code>，最重要的任务是将设备树中I2C总线节点下的I2C设备转化成<code>i2c_client</code>，以备后续使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can&#x27;t register until after driver model init 得先注册I2C总线才能注册adapter */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN_ON</span>(!is_registered)) &#123;</span><br><span class="line">		res = -EAGAIN;</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity checks 如果adapter没有name和algo算法，则直接返回，无法注册 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(!adap-&gt;name[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>))</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;</span>, adap-&gt;name);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;lock_ops)</span><br><span class="line">		adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">	adap-&gt;locked_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;bus_lock);</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;mux_lock);</span><br><span class="line">	<span class="built_in">mutex_init</span>(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">		adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register soft irqs for Host Notify */</span></span><br><span class="line">	res = <span class="built_in">i2c_setup_host_notify_irq_domain</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t create Host Notify IRQs (%d)\n&quot;</span>,</span><br><span class="line">		       adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_set_name</span>(&amp;adap-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 本来这里进去会有调用总线probe的机会，但是由于i2c bus</span></span><br><span class="line"><span class="comment">	 * 没有指定match回调，所以会在中途返回，而且返回的是0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = <span class="built_in">device_register</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;</span>, adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">of_i2c_setup_smbus_alert</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pm_runtime_no_callbacks</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">pm_suspend_ignore_children</span>(&amp;adap-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">pm_runtime_enable</span>(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">i2c_init_recovery</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;adapter [%s] registered\n&quot;</span>, adap-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	res = <span class="built_in">class_compat_create_link</span>(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="built_in">dev_warn</span>(&amp;adap-&gt;dev,</span><br><span class="line">			 <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    <span class="comment">// 构建从设备的软件抽象i2c_client，并与adapter建立联系</span></span><br><span class="line">	<span class="built_in">of_i2c_register_devices</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_install_space_handler</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_register_devices</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		<span class="built_in">i2c_scan_static_board_info</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify drivers */</span></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">bus_for_each_drv</span>(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);		<span class="comment">// 通知I2C总线上已经注册的I2C驱动与新注册的adap进行匹配</span></span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_reg:</span><br><span class="line">	<span class="built_in">init_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">	<span class="built_in">device_unregister</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">wait_for_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">out_list:</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/<em> /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c </em>/<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">of_i2c_register_devices</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *bus, *node;</span><br><span class="line">    <span class="comment">// 构建i2c_client</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only register child devices if the adapter has a node pointer set 设备树节点不为空 */</span></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;dev.of_node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找设备树节点中名称有直接描述I2C总线的节点，为了缩小查找范围</span></span><br><span class="line">	bus = <span class="built_in">of_get_child_by_name</span>(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>);</span><br><span class="line">    <span class="comment">// 没找到则从头开始遍历</span></span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		bus = <span class="built_in">of_node_get</span>(adap-&gt;dev.of_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个子节点，调用of_i2c_register_device解析设备树节点内容</span></span><br><span class="line">	for_each_available_child_of_node(bus, node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_test_and_set_flag</span>(node, OF_POPULATED))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		client = <span class="built_in">of_i2c_register_device</span>(adap, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client)) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;Failed to create I2C device for %pOF\n&quot;</span>,</span><br><span class="line">				 node);</span><br><span class="line">			<span class="built_in">of_node_clear_flag</span>(node, OF_POPULATED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">of_node_put</span>(bus);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/of/base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	of_get_child_by_name - Find the child node by name for a given parent</span></span><br><span class="line"><span class="comment"> *	@node:	parent node</span></span><br><span class="line"><span class="comment"> *	@name:	child name to look for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      This function looks for child node for given matching name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns a node pointer if found, with refcount incremented, use</span></span><br><span class="line"><span class="comment"> *	of_node_put() on it when done.</span></span><br><span class="line"><span class="comment"> *	Returns NULL if node is not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">device_node</span> *<span class="built_in">of_get_child_by_name</span>(<span class="type">const</span> <span class="keyword">struct</span> device_node *node,</span><br><span class="line">				<span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *child;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(node, child)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_name_eq</span>(child, name))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(of_get_child_by_name);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">i2c_client</span> *<span class="built_in">of_i2c_register_device</span>(<span class="keyword">struct</span> i2c_adapter *adap, </span><br><span class="line"></span><br><span class="line">						 <span class="keyword">struct</span> device_node *node)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_board_info</span> info;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_i2c_get_board_info</span>(&amp;adap-&gt;dev, node, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(ret);</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">i2c_new_client_device</span>(adap, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client))</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_i2c_get_board_info</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_node *node,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="keyword">struct</span> i2c_board_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 addr;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="built_in">sizeof</span>(*info));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_modalias_node</span>(node, info-&gt;type, <span class="built_in">sizeof</span>(info-&gt;type)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: modalias failure on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_property_read_u32</span>(node, <span class="string">&quot;reg&quot;</span>, &amp;addr);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: invalid reg on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_TEN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info-&gt;addr = addr;</span><br><span class="line">	info-&gt;of_node = node;</span><br><span class="line">	info-&gt;fwnode = <span class="built_in">of_fwnode_handle</span>(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_property_read_bool</span>(node, <span class="string">&quot;host-notify&quot;</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_HOST_NOTIFY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_get_property</span>(node, <span class="string">&quot;wakeup-source&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(of_i2c_get_board_info);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终<code>i2c_new_client_device()</code>函数将设备树中的I2C子节点转换为<code>i2c_client</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /home/zjn/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device - instantiate an i2c device</span></span><br><span class="line"><span class="comment"> * @adap: the adapter managing the device</span></span><br><span class="line"><span class="comment"> * @info: describes one I2C device; bus_num is ignored</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create an i2c device. Binding is handled through driver model</span></span><br><span class="line"><span class="comment"> * probe()/remove() methods.  A driver may be bound to this device when we</span></span><br><span class="line"><span class="comment"> * return from this function, or any later moment (e.g. maybe hotplugging will</span></span><br><span class="line"><span class="comment"> * load the driver module).  This call is not appropriate for use by mainboard</span></span><br><span class="line"><span class="comment"> * initialization logic, which usually runs during an arch_initcall() long</span></span><br><span class="line"><span class="comment"> * before any i2c_adapter could exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This returns the new i2c client, which may be saved for later use with</span></span><br><span class="line"><span class="comment"> * i2c_unregister_device(); or an ERR_PTR to describe the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_client</span> *</span><br><span class="line"><span class="built_in">i2c_new_client_device</span>(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client;</span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">kzalloc</span>(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line">	client-&gt;flags = info-&gt;flags;</span><br><span class="line">	client-&gt;addr = info-&gt;addr;</span><br><span class="line"></span><br><span class="line">	client-&gt;init_irq = info-&gt;irq;</span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;init_irq)</span><br><span class="line">		client-&gt;init_irq = <span class="built_in">i2c_dev_irq_from_resources</span>(info-&gt;resources,</span><br><span class="line">							 info-&gt;num_resources);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strlcpy</span>(client-&gt;name, info-&gt;type, <span class="built_in">sizeof</span>(client-&gt;name));</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_validity</span>(client-&gt;addr, client-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line">		<span class="keyword">goto</span> out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address business */</span></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_ex</span>(adap, <span class="built_in">i2c_encode_flags_to_addr</span>(client));</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">			<span class="string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,</span><br><span class="line">			status, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">	client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">	client-&gt;dev.of_node = <span class="built_in">of_node_get</span>(info-&gt;of_node);</span><br><span class="line">	client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">i2c_dev_set_name</span>(adap, client, info, status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties) &#123;</span><br><span class="line">		status = <span class="built_in">device_add_properties</span>(&amp;client-&gt;dev, info-&gt;properties);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,</span><br><span class="line">				client-&gt;name, status);</span><br><span class="line">			<span class="keyword">goto</span> out_err_put_of_node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">device_register</span>(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_free_props;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">		client-&gt;name, <span class="built_in">dev_name</span>(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_free_props:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties)</span><br><span class="line">		<span class="built_in">device_remove_properties</span>(&amp;client-&gt;dev);</span><br><span class="line"></span><br><span class="line">out_err_put_of_node:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">of_node_put</span>(info-&gt;of_node);</span><br><span class="line"></span><br><span class="line">out_err_silent:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kfree</span>(client);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(status);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(i2c_new_client_device); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-I2C设备驱动实现"><a href="#1-3-I2C设备驱动实现" class="headerlink" title="1.3. I2C设备驱动实现"></a>1.3. I2C设备驱动实现</h2><p>由本文最开始给出的框架图可知，实现I2C设备驱动通常有两条路径：</p>
<h3 id="1-3-1-将I2C控制器暴露给应用的方式"><a href="#1-3-1-将I2C控制器暴露给应用的方式" class="headerlink" title="1.3.1. 将I2C控制器暴露给应用的方式"></a>1.3.1. 将I2C控制器暴露给应用的方式</h3><p>该方式采用标准的 <code>file_operations</code> 字符设备的形式，将 <code>i2c_adapter</code> 设备化，在<code>/dev</code>目录下创建<code>i2c-n(n=0, 1, 2...)</code>设备节点。所实现的驱动可看作是一种” <code>i2c_driver</code> 成员函数 + 字符设备驱动”的虚拟驱动，需要由应用层通过 <code>read()</code> 、 <code>write()</code> 函数根据芯片手册直接对I2C控制器进行配置时序等操作，以实现对从设备的控制。这种方式是把对硬件的具体操作放在应用层去实现，适合用来快速测试一款I2C设备的功能，或者在 <code>i2c_driver</code> 工作不正常的时候排查具体是设备驱动工作问题还是主机驱动工作问题。并不能作为主流的开发方式。详细可见 <code>.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-dev.c</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_MAJOR	89		<span class="comment">/* Device major number		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_MINORS	MINORMASK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module load/unload record keeping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">i2c_dev_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;i2c /dev entries driver\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 申请设备号，I2C_MAJOR为89，次设备号为0，I2C_MINORS为1&lt;&lt;20-1，表示次设备号的数量。</span></span><br><span class="line">	<span class="comment">// 就是把这个主设备号对应的次设备号都申请了。</span></span><br><span class="line">	res = <span class="built_in">register_chrdev_region</span>(<span class="built_in">MKDEV</span>(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">// 创建一个同名类，在 /sys/class中可以看到</span></span><br><span class="line">	i2c_dev_class = <span class="built_in">class_create</span>(THIS_MODULE, <span class="string">&quot;i2c-dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c_dev_class)) &#123;</span><br><span class="line">		res = <span class="built_in">PTR_ERR</span>(i2c_dev_class);</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line">	i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">	<span class="comment">// 注册i2c总线的通知函数</span></span><br><span class="line">	<span class="comment">// 参数2详见下</span></span><br><span class="line">	res = <span class="built_in">bus_register_notifier</span>(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">	<span class="comment">// 遍历i2c总线上的所有设备，每次都执行第二个参数对应的函数</span></span><br><span class="line">	<span class="built_in">i2c_for_each_dev</span>(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">	<span class="built_in">class_destroy</span>(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">	<span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS);</span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;%s: Driver Initialisation failed\n&quot;</span>, __FILE__);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_notifier_call</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="type">unsigned</span> <span class="type">long</span> action,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev = data;</span><br><span class="line">	<span class="comment">// 发生的事件类型</span></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">	<span class="comment">// 此i2c总线下发生添加设备事件</span></span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		<span class="comment">// 创建设备文件之类的操作</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">i2cdev_attach_adapter</span>(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 此i2c总线下发生删除设备事件</span></span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">i2cdev_detach_adapter</span>(dev, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> *adap;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_dev</span> *i2c_dev;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若设备类型不是i2c适配器，直接返回</span></span><br><span class="line">	<span class="comment">// 也有可能是 i2c_client 设备</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从i2c设备结构体中获取i2c适配器结构体</span></span><br><span class="line">	adap = <span class="built_in">to_i2c_adapter</span>(dev);</span><br><span class="line">	<span class="comment">// 分配内存</span></span><br><span class="line">	i2c_dev = <span class="built_in">get_free_i2c_dev</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c_dev))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(i2c_dev);</span><br><span class="line">	<span class="comment">// 设置文件操作接口</span></span><br><span class="line">	<span class="built_in">cdev_init</span>(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class="line">	i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">device_initialize</span>(&amp;i2c_dev-&gt;dev);</span><br><span class="line">	i2c_dev-&gt;dev.devt = <span class="built_in">MKDEV</span>(I2C_MAJOR, adap-&gt;nr);</span><br><span class="line">	i2c_dev-&gt;dev.<span class="keyword">class</span> = i2c_dev_class;</span><br><span class="line">	i2c_dev-&gt;dev.parent = &amp;adap-&gt;dev;</span><br><span class="line">	i2c_dev-&gt;dev.release = i2cdev_dev_release;</span><br><span class="line">	<span class="built_in">dev_set_name</span>(&amp;i2c_dev-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	<span class="comment">// 注意次设备号为适配器对应的编号，可以自己指定，也可以有系统分配</span></span><br><span class="line">	<span class="comment">// 参数3为此设备哈的数量，此fops只对应此设备号的文件</span></span><br><span class="line">	res = <span class="built_in">cdev_device_add</span>(&amp;i2c_dev-&gt;cdev, &amp;i2c_dev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">put_i2c_dev</span>(i2c_dev, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;</span>,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> i2cdev_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read		= i2cdev_read,</span><br><span class="line">	.write		= i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	= i2cdev_ioctl,</span><br><span class="line">	.compat_ioctl	= compat_i2cdev_ioctl,</span><br><span class="line">	.open		= i2cdev_open,</span><br><span class="line">	.release	= i2cdev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2cdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 从inode获取次设备号，就是适配器的编号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minor = <span class="built_in">iminor</span>(inode);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> *adap;</span><br><span class="line">	<span class="comment">// 根据次设备号从i2c总线获取对应的适配器</span></span><br><span class="line">	adap = <span class="built_in">i2c_get_adapter</span>(minor);</span><br><span class="line">	<span class="keyword">if</span> (!adap)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This creates an anonymous i2c_client, which may later be</span></span><br><span class="line"><span class="comment">	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This client is ** NEVER REGISTERED ** with the driver model</span></span><br><span class="line"><span class="comment">	 * or I2C core code!!  It just holds private copies of addressing</span></span><br><span class="line"><span class="comment">	 * information and maybe a PEC flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// client表示某个具体的i2c设备，为其分配内存</span></span><br><span class="line">	client = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*client), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client) &#123;</span><br><span class="line">		<span class="built_in">i2c_put_adapter</span>(adap);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置具体的i2c设备的名字</span></span><br><span class="line">	<span class="built_in">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class="string">&quot;i2c-dev %d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	<span class="comment">// 设置具体的i2c设备归属的适配器</span></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line">	<span class="comment">// 以后可以通过file的此成员获取client指针</span></span><br><span class="line">	file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After opening an instance of this character special file, a file</span></span><br><span class="line"><span class="comment"> * descriptor starts out associated only with an i2c_adapter (and bus).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg</span></span><br><span class="line"><span class="comment"> * traffic to any devices on the bus used by that adapter.  That&#x27;s because</span></span><br><span class="line"><span class="comment"> * the i2c_msg vectors embed all the addressing information they need, and</span></span><br><span class="line"><span class="comment"> * are submitted directly to an i2c_adapter.  However, SMBus-only adapters</span></span><br><span class="line"><span class="comment"> * don&#x27;t support that interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To use read()/write() system calls on that file descriptor, or to use</span></span><br><span class="line"><span class="comment"> * SMBus interfaces (and work with SMBus-only hosts!), you must first issue</span></span><br><span class="line"><span class="comment"> * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous</span></span><br><span class="line"><span class="comment"> * (never registered) i2c_client so it holds the addressing information</span></span><br><span class="line"><span class="comment"> * needed by those system calls and by this SMBus interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">i2cdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 分配内存，用于接收消息</span></span><br><span class="line">	tmp = <span class="built_in">kzalloc</span>(count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: i2c-%d reading %zu bytes.\n&quot;</span>,</span><br><span class="line">		<span class="built_in">iminor</span>(<span class="built_in">file_inode</span>(file)), count);</span><br><span class="line">	<span class="comment">// 核心函数，接受一个i2c消息</span></span><br><span class="line">	ret = <span class="built_in">i2c_master_recv</span>(client, tmp, count);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, tmp, ret))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">	<span class="built_in">kfree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">i2cdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">size_t</span> count, <span class="type">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">// 把用户空间的buf拷贝内核空间的tmp</span></span><br><span class="line">	tmp = <span class="built_in">memdup_user</span>(buf, count);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(tmp))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(tmp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pr_debug</span>(<span class="string">&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;</span>,</span><br><span class="line">		<span class="built_in">iminor</span>(<span class="built_in">file_inode</span>(file)), count);</span><br><span class="line">	<span class="comment">// 核心函数，发送一个i2c消息</span></span><br><span class="line">	ret = <span class="built_in">i2c_master_send</span>(client, tmp, count);</span><br><span class="line">	<span class="built_in">kfree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_send - issue a single I2C message in master transmit mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Data that will be written to the slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_transfer_buffer_flags</span>(client, (<span class="type">char</span> *)buf, count, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_recv - issue a single I2C message in master receive mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where to store data read from slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_transfer_buffer_flags</span>(client, buf, count, I2C_M_RD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer - execute a single or combined I2C message</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *	terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that there is no requirement that each message be sent to</span></span><br><span class="line"><span class="comment"> * the same slave address, although that is the most common model.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line">		<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* REVISIT the fault reporting model here is weak:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get an error after receiving N bytes from a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When we get a NAK after transmitting N bytes to a slave,</span></span><br><span class="line"><span class="comment">	 *    there is no way to report &quot;N&quot; ... or to let the master</span></span><br><span class="line"><span class="comment">	 *    continue executing the rest of this combined message, if</span></span><br><span class="line"><span class="comment">	 *    that&#x27;s the appropriate response.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - When for example &quot;num&quot; is two and we successfully complete</span></span><br><span class="line"><span class="comment">	 *    the first message but get an error part way through the</span></span><br><span class="line"><span class="comment">	 *    second, it&#x27;s unclear whether that should be reported as</span></span><br><span class="line"><span class="comment">	 *    one (discarding status on the second message) or errno</span></span><br><span class="line"><span class="comment">	 *    (discarding status on the first one).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = __i2c_lock_bus_helper(adap);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">	<span class="built_in">i2c_unlock_bus</span>(adap, I2C_LOCK_SEGMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_transfer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer_buffer_flags - issue a single I2C message transferring data</span></span><br><span class="line"><span class="comment"> *			       to/from a buffer</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where the data is stored</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to transfer, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes transferred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_transfer_buffer_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">char</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">int</span> count, u16 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 传入参数构建消息结构体</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_msg</span> msg = &#123;</span><br><span class="line">		.addr = client-&gt;addr,</span><br><span class="line">		.flags = flags | (client-&gt;flags &amp; I2C_M_TEN),</span><br><span class="line">		.len = count,</span><br><span class="line">		.buf = buf,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">i2c_transfer</span>(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If everything went ok (i.e. 1 msg transferred), return #bytes</span></span><br><span class="line"><span class="comment">	 * transferred, else error code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_transfer_buffer_flags);</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-将I2C控制器抽象成公共驱动的方式"><a href="#1-3-2-将I2C控制器抽象成公共驱动的方式" class="headerlink" title="1.3.2. 将I2C控制器抽象成公共驱动的方式"></a>1.3.2. 将I2C控制器抽象成公共驱动的方式</h3><p>该方式是把所有代码都放在驱动层实现，直接向应用层提供最终结果，即应用层甚至可以不知道I2C的存在。例如电容式触摸屏驱动直接向应用层提供 <code>/dev/input/eventn</code> 的操作接口，接收上报到应用层的输入事件。而不需要直到具体是怎么上报的，甚至应用层不知道触摸屏是使用I2C总线和主机进行数据交互的。</p>
<p>rk开发板用的触摸屏是汇顶科技的gt1x型电容式触摸屏，驱动代码位于/driver/input/touchscreen/gt1x/gt1x.c，电容触摸屏通过IIC总线与SOC进行通信，利用其自带的触摸IC完成坐标计算后通过IIC将坐标信息传输给SOC，坐标的计算过程不需要SOC的参与，从这个角度上来说，电容触摸屏就是一个挂载到SOC上的IIC slave设备，与通常所说的Sensor是一样的性质。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_ts_init - Driver Install function.</span></span><br><span class="line"><span class="comment"> * Return   0---succeed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">gt1x_ts_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GTP_DEBUG_FUNC</span>();</span><br><span class="line">	<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP driver installing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_add_driver</span>(&amp;gt1x_ts_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_ts_probe -   I2c probe.</span></span><br><span class="line"><span class="comment"> * @client: i2c device struct.</span></span><br><span class="line"><span class="comment"> * @id: device id.</span></span><br><span class="line"><span class="comment"> * Return  0: succeed, -1: failed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gt1x_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s32 ret = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_AUTO_UPDATE</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*do NOT remove these logs*/</span></span><br><span class="line">	<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP Driver Version: %s&quot;</span>, GTP_DRIVER_VERSION);</span><br><span class="line">	<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP I2C Address: 0x%02x&quot;</span>, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	gt1x_i2c_client = client;</span><br><span class="line">	<span class="built_in">spin_lock_init</span>(&amp;irq_lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查i2c适配器的能力</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">i2c_check_functionality</span>(client-&gt;adapter, I2C_FUNC_I2C)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;I2C check functionality failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GTP_CONFIG_OF	<span class="comment">/* device tree support */</span></span></span><br><span class="line">	<span class="comment">// 解析设备树</span></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;dev.of_node) &#123;</span><br><span class="line">		ret = <span class="built_in">gt1x_parse_dt</span>(&amp;client-&gt;dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	<span class="comment">// 申请GPIO端口</span></span><br><span class="line">	ret = <span class="built_in">gt1x_request_io_port</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP request IO port failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 触摸IC初始化</span></span><br><span class="line">	ret = <span class="built_in">gt1x_init</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP init failed!!!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_wq = <span class="built_in">create_singlethread_workqueue</span>(<span class="string">&quot;gt1x_wq&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!gt1x_wq) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Creat workqueue failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">INIT_WORK</span>(&amp;gt1x_work, gt1x_ts_work_func);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">gt1x_request_input_dev</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;GTP request input dev failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">gt1x_request_irq</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP works in polling mode.&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">GTP_DEBUG</span>(<span class="string">&quot;GTP works in interrupt mode.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_GESTURE_WAKEUP</span></span><br><span class="line">	<span class="built_in">enable_irq_wake</span>(client-&gt;irq);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">gt1x_irq_enable</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_ESD_PROTECT</span></span><br><span class="line">	<span class="comment">/*must before auto update*/</span></span><br><span class="line">	<span class="built_in">gt1x_init_esd_protect</span>();</span><br><span class="line">	<span class="built_in">gt1x_esd_switch</span>(SWITCH_ON);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_AUTO_UPDATE</span></span><br><span class="line">	thread = <span class="built_in">kthread_run</span>(gt1x_auto_update_proc, (<span class="type">void</span> *)<span class="literal">NULL</span>, <span class="string">&quot;gt1x_auto_update&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(thread)) &#123;</span><br><span class="line">		ret = <span class="built_in">PTR_ERR</span>(thread);</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Failed to create auto-update thread: %d.&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">gt1x_register_powermanger</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gt1x_parse_dt - parse platform infomation form devices tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gt1x_parse_dt</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *np;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *tp_type;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *root;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *machine_compatible;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	np = dev-&gt;of_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">of_property_read_string</span>(np, <span class="string">&quot;goodix,ic_type&quot;</span>, &amp;tp_type)) &#123;</span><br><span class="line">		<span class="built_in">GTP_INFO</span>(<span class="string">&quot;GTP ic_type: %s&quot;</span>, tp_type);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(tp_type, <span class="string">&quot;gt5688&quot;</span>))</span><br><span class="line">			gt1x_gt5688 = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据NAME获取GPIO</span></span><br><span class="line">	gt1x_int_gpio = <span class="built_in">of_get_named_gpio</span>(np, <span class="string">&quot;goodix,irq-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//根据NAME获取GPIO</span></span><br><span class="line">	gt1x_rst_gpio = <span class="built_in">of_get_named_gpio</span>(np, <span class="string">&quot;goodix,rst-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 判断上述两个GPIO口是否可用</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gpio_is_valid</span>(gt1x_int_gpio) || !<span class="built_in">gpio_is_valid</span>(gt1x_rst_gpio)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Invalid GPIO, irq-gpio:%d, rst-gpio:%d&quot;</span>,</span><br><span class="line">				gt1x_int_gpio, gt1x_rst_gpio);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vdd_ana = <span class="built_in">devm_regulator_get_optional</span>(dev, <span class="string">&quot;vdd_ana&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">PTR_ERR</span>(vdd_ana) == -ENODEV) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;vdd_ana not specified, fallback to power-supply&quot;</span>);</span><br><span class="line">		vdd_ana = <span class="built_in">devm_regulator_get_optional</span>(dev, <span class="string">&quot;power&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">PTR_ERR</span>(vdd_ana) == -ENODEV) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;power not specified, ignore power ctrl&quot;</span>);</span><br><span class="line">			vdd_ana = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(vdd_ana)) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;regulator get of vdd_ana/power-supply failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(vdd_ana);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_ics_slot_report = <span class="built_in">of_property_read_bool</span>(dev-&gt;of_node, <span class="string">&quot;gtp_ics_slot_report&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	root = <span class="built_in">of_find_node_by_path</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (root) &#123;</span><br><span class="line">		machine_compatible = <span class="built_in">of_get_property</span>(root, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">of_node_put</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(machine_compatible, <span class="string">&quot;linux&quot;</span>))</span><br><span class="line">			dev-&gt;driver-&gt;pm = &amp;gt1x_ts_pm_ops;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">s32 <span class="title">gt1x_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s32 ret = <span class="number">-1</span>;</span><br><span class="line">	s32 retry = <span class="number">0</span>;</span><br><span class="line">	u8 reg_val[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* power on */</span></span><br><span class="line">	<span class="built_in">gt1x_power_switch</span>(SWITCH_ON);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (retry++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line">		gt1x_init_failed = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* reset ic */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_reset_guitar</span>();	<span class="comment">// reset IC</span></span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Reset guitar failed!&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check main system firmware */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_i2c_read_dbl_check</span>(GTP_REG_FW_CHK_MAINSYS, reg_val, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (reg_val[<span class="number">0</span>] != <span class="number">0xBE</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Check main system not pass[0x%2X].&quot;</span>, reg_val[<span class="number">0</span>]);</span><br><span class="line">			gt1x_init_failed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !GTP_AUTO_UPDATE</span></span><br><span class="line">		<span class="comment">/* debug info  */</span></span><br><span class="line">		ret = <span class="built_in">gt1x_i2c_read_dbl_check</span>(GTP_REG_FW_CHK_SUBSYS, reg_val, <span class="number">1</span>);	<span class="comment">// IIC读写测试，检查IC是否初始化成功</span></span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; reg_val[<span class="number">0</span>] == <span class="number">0xAA</span>) &#123;</span><br><span class="line">			<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Check subsystem not pass[0x%2X].&quot;</span>, reg_val[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if the initialization fails, set default setting */</span></span><br><span class="line">	ret |= gt1x_init_failed;	</span><br><span class="line">	<span class="comment">// 判断IC是否初始化成功，如果没有使用默认配置</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Init failed, use default setting&quot;</span>);</span><br><span class="line">		gt1x_abs_x_max = GTP_MAX_WIDTH;</span><br><span class="line">		gt1x_abs_y_max = GTP_MAX_HEIGHT;</span><br><span class="line">		gt1x_int_type = GTP_INT_TRIGGER;</span><br><span class="line">		gt1x_wakeup_level = GTP_WAKEUP_LEVEL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get chip type */</span></span><br><span class="line">	<span class="comment">// 获取触摸IC的芯片类型：GT1X 、GT2X，对于不同的芯片类型会有不同的同步方式</span></span><br><span class="line">	ret = <span class="built_in">gt1x_get_chip_type</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Get chip type failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read version information */</span></span><br><span class="line">	ret = <span class="built_in">gt1x_read_version</span>(&amp;gt1x_version);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Get verision failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init and send configs */</span></span><br><span class="line">	<span class="comment">// 配置驱动IC，初始化完成后不可以再调用该函数</span></span><br><span class="line">	ret = <span class="built_in">gt1x_init_panel</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Init panel failed.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gt1x_workqueue = <span class="built_in">create_singlethread_workqueue</span>(<span class="string">&quot;gt1x_workthread&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gt1x_workqueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">GTP_ERROR</span>(<span class="string">&quot;Create workqueue failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init auxiliary  node and functions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_DEBUG_NODE</span></span><br><span class="line">	<span class="built_in">gt1x_init_debug_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_CREATE_WR_NODE</span></span><br><span class="line">	<span class="built_in">gt1x_init_tool_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_GESTURE_WAKEUP || GTP_HOTKNOT</span></span><br><span class="line">	<span class="built_in">gt1x_init_node</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_PROXIMITY</span></span><br><span class="line">	<span class="built_in">gt1x_ps_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_CHARGER_SWITCH</span></span><br><span class="line">	<span class="built_in">gt1x_init_charger</span>();</span><br><span class="line">	<span class="built_in">gt1x_charger_config</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">gt1x_charger_switch</span>(SWITCH_ON);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_SMART_COVER</span></span><br><span class="line">	<span class="built_in">gt1x_smart_cover_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GTP_WITH_STYLUS</span></span><br><span class="line">	<span class="built_in">gt1x_pen_init</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gt1x_ts_probe 函数完成了触摸IC的初始化、以及中断事件的初始化，当中断发生时，调用中断处理函数（中断处理函数的上半部分，触摸中断事件需要处理的信息较多，不能全部放到中断处理函数当中去，这里通过工作队列实现了将中断处理分为上下两个部分，在中断处理函数的上半部分调用了queue_work 将中断需要处理的信息作为任务提交到了工作队列），显然这个工作队列也是在probe中完成的初始化以及创建一个专用的内核线程来执行提交到工作队列中的函数gt1x_ts_work_func。<br>分析到这里，我们可以完整的总结出一次input 事件上报的链路了：</p>
<p>触摸屏IC初始化完成-&gt;手指点击触摸屏-&gt;引发一次中断-&gt;gt1x_ts_irq_handler-&gt;queue_work(gt1x_wq, &gt;1x_work)-&gt;gt1x_ts_work_func-&gt;gt1x_touch_event_handler-&gt;gt1x_touch_down-&gt;input_report_abs-&gt;input_event-&gt;input_handle_event-&gt;input_pass_event-&gt;handler.event-&gt;evdev_event-&gt;evdev_events-&gt;evedv_pass_values</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>I2C</category>
        <category>设备驱动开发</category>
      </categories>
      <tags>
        <tag>Linux设备驱动开发</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备驱动概述</title>
    <url>/2022/08/08/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/2022-08-08-Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Linux设备驱动概述"><a href="#Linux设备驱动概述" class="headerlink" title="Linux设备驱动概述"></a>Linux设备驱动概述</h1><h2 id="设备驱动的概念和作用"><a href="#设备驱动的概念和作用" class="headerlink" title="设备驱动的概念和作用"></a>设备驱动的概念和作用</h2><p>任何一个计算机系统的运转都是系统中软硬件共同努力的结果，硬件是底层基础，是所有软件得以运行的平台。代码最终会落实为硬件上的组合逻辑与时序逻辑，软件则实现了具体应用。</p>
<p>为了尽可能快速地完成设计，软件和硬件不应该互相渗透。例如，应用软件在调用套接字发送和接收数据包的时候，不必关心网卡上的中断、寄存器、存储空间、I/O端口、片选以及其他任何硬件词汇。由设备驱动充当硬件和应用软件之间的纽带。对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。</p>
<h2 id="操作系统与设备驱动"><a href="#操作系统与设备驱动" class="headerlink" title="操作系统与设备驱动"></a>操作系统与设备驱动</h2><p>在系统没有操作系统的情况下，工程师可以根据硬件设备的特点自行定义接口；</p>
<p>而在由操作系统的情况下，驱动的架构则由相应的操作系统定义。</p>
<h3 id="无操作系统时的设备驱动"><a href="#无操作系统时的设备驱动" class="headerlink" title="无操作系统时的设备驱动"></a>无操作系统时的设备驱动</h3><p>对于功能比较单一(不需要多任务调度、文件系统、内存管理等功能)，控制并不复杂的系统，用单任务架构完全可以良好地支持工作。<strong>在一个无限循环中夹杂着对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构。</strong></p>
<p>一般情况下，无操作系统时的每一种设备驱动都会定义一个软件模块，包含.h文件和.c文件，前者定义该设备驱动的数据结构并声明外部函数，后者进行驱动的具体实现。</p>
<p>在没有操作系统的情况下，设备驱动的接口被直接提交给应用软件工程师，应用软件没有跨越任何层次就直接访问设备驱动的接口。驱动包含的接口函数也与硬件的功能直接吻合，没有任何附加功能。</p>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E6%97%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%A1%AC%E4%BB%B6%E3%80%81%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB.png?raw=true" alt="无操作系统时硬件、设备驱动和应用软件的关系"></p>
<h3 id="由操作系统时的设备驱动"><a href="#由操作系统时的设备驱动" class="headerlink" title="由操作系统时的设备驱动"></a>由操作系统时的设备驱动</h3><p>除了必要的硬件操作工作，还必须在所有设备的驱动中设计面向操作系统内核的接口，以确保将驱动融入操作系统内核。对外呈现为操作系统的API，不再直接提供接口。</p>
<p>虽然操作系统能够帮助一个复杂的软件系统处理多个并发的任务，还提供内存管理机制。但对于设备驱动来说，操作系统纯粹是为了给上层应用提供便利，使得应用程序可以使用统一的系统调用接口来访问各种设备。</p>
<h2 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h2><h3 id="设备的分类和特点"><a href="#设备的分类和特点" class="headerlink" title="设备的分类和特点"></a>设备的分类和特点</h3><p>驱动针对的对象不是CPU内核，而是存储器和外设(包括CPU内部集成的存储器和外设)。主要分为3个基础大类：</p>
<ul>
<li>字符设备<ul>
<li>必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标</li>
</ul>
</li>
<li>块设备<ul>
<li>可以按任意顺序进行访问的设备，以块为单位进行操作，如硬盘、eMMC</li>
</ul>
</li>
<li>网络设备<ul>
<li>面向数据包的接收和发送设计，内核与网络设备的通信主要依靠套接字接口。</li>
</ul>
</li>
</ul>
<h3 id="Linux设备驱动与整个软硬件系统的关系"><a href="#Linux设备驱动与整个软硬件系统的关系" class="headerlink" title="Linux设备驱动与整个软硬件系统的关系"></a>Linux设备驱动与整个软硬件系统的关系</h3><p>除网络设备外，字符设备和块设备都被映射到Linux文件系统的文件和目录。应用程序可以使用Linux的系统调用接口( <code>open()</code> 、 <code>write()</code> 、 <code>read()</code> 、 <code>close()</code> )或C语言的文件操作库函数( <code>fopen()</code> 、 <code>fwrite()</code> 、 <code>fread()</code> 、 <code>fclose()</code> )。</p>
<p>其中，块设备可以由两种访问方法：</p>
<ul>
<li>类似<code>dd</code>命令对应的原始块设备(<code>/dev/sdb1</code>)</li>
<li>在块设备上建立FAT、EXT4、BTRFS等文件系统，然后通过文件路径进行访问。</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%95%B4%E4%B8%AA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png?raw=true" alt="Linux设备驱动与整个软硬件系统的关系"></p>
<h3 id="Linux设备驱动的重点、难点"><a href="#Linux设备驱动的重点、难点" class="headerlink" title="Linux设备驱动的重点、难点"></a>Linux设备驱动的重点、难点</h3><ul>
<li>硬件基础<ul>
<li>懂得SRAM、Flash、SDRAM、磁盘的读写方式</li>
<li>UART、I2C、USB等设备的接口</li>
<li>轮询、中断、DMA的原理</li>
<li>PCI总线的工作方式</li>
<li>CPU内存管理单元MMU</li>
</ul>
</li>
<li>C语言基础<ul>
<li>结构体</li>
<li>指针</li>
<li>函数指针</li>
<li>内存动态申请和释放</li>
</ul>
</li>
<li>Linux内核基础<ul>
<li>驱动与内核的接口</li>
</ul>
</li>
<li>多任务并发控制和同步基础<ul>
<li>自旋锁</li>
<li>互斥</li>
<li>信号量</li>
<li>等待队列</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络基础(一)</title>
    <url>/2022/08/04/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2022-08-04-Linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Linux网络基础-一"><a href="#Linux网络基础-一" class="headerlink" title="Linux网络基础(一)"></a>Linux网络基础(一)</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket又称套接字，是一个通信链的句柄，位于应用层和传输层之间，用于唯一标识网络中某一台主机上的某一个进程。它通常由主机的IP地址和端口号拼接而成。</p>
<h2 id="Linux的socket相关函数"><a href="#Linux的socket相关函数" class="headerlink" title="Linux的socket相关函数"></a>Linux的socket相关函数</h2><h3 id="socket库"><a href="#socket库" class="headerlink" title="socket库"></a>socket库</h3><p>与Windows提供了 <code>&lt;winsock2.h&gt;</code>库方便开发者进行socket编程相同，Linux为开发者提供了 <code>&lt;sys/socket.h&gt;</code>库。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// Linux提供的socket库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// 保存不同协议的地址结构体，如socketaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// 地址格式转换函数</span></span></span><br></pre></td></tr></table></figure>
<h3 id="socket的创建"><a href="#socket的创建" class="headerlink" title="socket的创建"></a>socket的创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>domain: 用于确定通信的特性，包括地址的格式</code><ul>
<li><code>AF_INET</code> : IPV4因特网域</li>
<li><code>AF_INET6</code>: IPV6因特网域</li>
<li><code>AF_UNIX</code> : UNIX域</li>
<li><code>AF_UPSPEC</code>: 未指定</li>
</ul>
</li>
<li><code>type</code><ul>
<li><code>SOCK_DGRAM</code> : 固定长度的、无连接的、不可靠的报文传输(UDP)</li>
<li><code>SOCK_STREAM</code>: 有序的、可靠的、双向的、面向连接的字节流(TCP)</li>
<li><code>SOCK_SEQPACKET</code>: 固定长度的、有序的、可靠的、面向连接的报文传递</li>
<li><code>SOCK_RAW</code>: IP协议的数据报接口</li>
</ul>
</li>
<li><code>protocol</code><ul>
<li>通常为0，表示为给定的 <code>domain</code>和 <code>type</code>选择默认协议。</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>创建成功，返回文件描述符(套接字)</li>
<li>创建失败，返回-1</li>
</ul>
</li>
</ul>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>不同的通信协议会有不同的套接字地址结构。为使不同格式地址能够传入套接字函数，地址会被强制转换成一个通用的地址结构<code>sockaddr</code></p>
<p><code>sockaddr_in</code>是Internet环境下的套接字地址形式，主要用于socket定义和赋值；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sockaddr_in for IPV4 16 bytes */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">sa_family_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">  <span class="type">sa_family_t</span> sin_family; <span class="comment">/* 地址族 */</span>    <span class="comment">//2字节</span></span><br><span class="line">  in_port  sin_port; <span class="comment">/* 目的端口号 */</span>  <span class="comment">//2字节</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* IP地址*/</span>  <span class="comment">// 4 字节</span></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span>  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>];<span class="comment">/*填充字节*/</span> <span class="comment">//8 字节 需要清零</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义socket的各类地址形式最终转换成<code>sockaddr</code>类型作为函数参数传输。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sockaddr 16 bytes*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">sa_family_t</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line"> <span class="type">sa_family_t</span> sa_family;  <span class="comment">//地址族   AF_XXXX    2字节</span></span><br><span class="line"> <span class="type">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">//可变长度地址 包含IP地址、port 14 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="将socket与地址关联-服务器"><a href="#将socket与地址关联-服务器" class="headerlink" title="将socket与地址关联(服务器)"></a>将socket与地址关联(服务器)</h3><p>创建socket后还需将socket和地址进行关联，所以调用<code>bind()</code>函数将地址指向的<code>sockaddr</code>结构体中描述的一些属性与socket套接字绑定(也叫命名)。然后就可以通过socket读取和使用，当然也可通过该socket发送数据到指定目的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: socket的文件描述符</li>
<li><code>addr</code>: 填充了地址族、IP地址、port的sockaddr_in结构体，传参时被强制转换为sockaddr。</li>
<li><code>addrlen</code>: 地址的长度，因为sockaddr类型的参数中sa_data是可变长度地址</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<p>对于服务器，<code>bind</code>是必须要做的事情。服务器启动的时候需要绑定指定的端口来提供服务(以便客户向指定的端口发送请求)。一般来说，会将参数中的IP地址赋值为<code>INADDR_ANY</code>，即无论发送到系统中的哪个IP地址(多网卡情况)的请求都采用被绑定的socket处理，无需指定固定IP。</p>
<p>对于客户端来说，一般不需要主动进行<code>bind</code>，交给操作系统分配可用端口。</p>
<blockquote>
<p>公认端口:从0到1023。<br>小于256的端口作为保留端口。<br>注册端口:端口号从1024到49151。实际上，机器通常从1024起分配动态端口。<br>动态和/或私有端口:从49152到65535。理论上，不应为服务分配这些端口。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// IPV4 tcp socket</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;                              <span class="comment">// IPV4 需要与socket中的指定一致</span></span><br><span class="line">addr.sin_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.51.122&quot;</span>);            <span class="comment">// 点分十进制转三十二位字节序</span></span><br><span class="line">addr.sin_port = <span class="number">5050</span>;                                   <span class="comment">//大于1024</span></span><br><span class="line"><span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));   <span class="comment">// 关联绑定</span></span><br></pre></td></tr></table></figure>
<h3 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h3><p>面向连接的网络服务(TCP)在开始交换数据之前，需要在请求服务的进程套接字(客户端)和提供服务的套接字(服务器)之间建立一个连接(TCP是三次握手)。</p>
<h4 id="连接请求connect-客户端"><a href="#连接请求connect-客户端" class="headerlink" title="连接请求connect(客户端)"></a>连接请求connect(客户端)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: socket的文件描述符</li>
<li><code>addr</code>: 填充了地址族、服务器IP地址、服务器port的sockaddr_in结构体，传参时被强制转换为sockaddr。如果sockfd参数中无法获知服务器IP地址和服务器的端口号，则绑定一个默认地址，即客户端本机的IP。</li>
<li><code>addrlen</code>: 地址的长度，因为sockaddr类型的参数中sa_data是可变长度地址</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<p>在客户端尝试连接服务器的过程中，可能会出现连接失败的情况。这很可能是由一些瞬时错误引起的，如果一个服务器运行在一个负载很重的系统上，就很有可能发生这种错误。</p>
<p>通常采用指数补偿算法解决瞬时错误。当调用的connect失败后，进程会休眠一小段时间，然后进行第二次尝试。如果第二次的尝试依然失败，则休眠时间指数级增加，以此类推进行循环，直到最大休眠延时达到2分钟左右。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSLEEP 128  <span class="comment">// 最大休眠时间</span></span></span><br><span class="line"><span class="comment">/* 指数补偿算法 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_try</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> strcut sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num_sec;</span><br><span class="line">  <span class="keyword">for</span>(num_sec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>)  <span class="comment">// 休眠时间指数级增长</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, addr, addrlen) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 成功连接</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_sec &lt;= MAXSLEEP/<span class="number">2</span>)  <span class="comment">// 休眠，然后再次重连</span></span><br><span class="line">      <span class="built_in">sleep</span>(num_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//超时， 返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听连接请求listen-服务器"><a href="#监听连接请求listen-服务器" class="headerlink" title="监听连接请求listen(服务器)"></a>监听连接请求listen(服务器)</h4><p>服务器调用<code>listen</code>函数来宣告它正在接收连接请求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: socket的文件描述符</li>
<li><code>backlog</code>: accept应答之前，允许在进入队列中等待的连接数目，最大值128。连接队列缓存的容量</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<h4 id="处理客户端的连接请求accept-服务器"><a href="#处理客户端的连接请求accept-服务器" class="headerlink" title="处理客户端的连接请求accept(服务器)"></a>处理客户端的连接请求accept(服务器)</h4><p>服务器调用<code>accept</code>来建立套接字连接，处理单个连接请求。如果服务器调用accept后没有收到连接请求，则服务器会阻塞直到新的请求到来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: 正在监听端口的socket的文件描述符</li>
<li><code>addr</code>: 填充了地址族、客户端IP地址、客户端port的sockaddr_in结构体，传参时被强制转换为sockaddr。如果服务器不关心，可以设置为NULL</li>
<li><code>addrlen</code>: 地址的长度，因为sockaddr类型的参数中sa_data是可变长度地址</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回与客户端连接的套接字，该套接字域客户端连接</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<h3 id="网络连接的关闭和socket的关闭"><a href="#网络连接的关闭和socket的关闭" class="headerlink" title="网络连接的关闭和socket的关闭"></a>网络连接的关闭和socket的关闭</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: socket的文件描述符</li>
<li><code>how</code>: 关闭方式<ul>
<li><code>SHUT_RD</code>: 关闭读端</li>
<li><code>SHUT_WR</code>: 关闭写端</li>
<li><code>SHUT_RDWR</code>: 关闭读写</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closesocket</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li><code>sockfd</code>: socket的文件描述符</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1</li>
</ul>
</li>
</ul>
<blockquote>
<p>close和shutdown的区别<br>shutdown不管引用计数，关闭的是连接而不是套接字，调用后套接字依然存在，直到调用close将套接字清除。并且，它需要等待输出缓冲区中的数据传输完毕再发送FIN包关闭连接。<br>close是把socket描述符的引用计数-1，仅在引用计数为0时关闭套接字。使用后套接字描述符将从内存中清除，之后也不能再被使用。如果调用后会关闭套接字，它将不管输出缓冲区是否还有数据，直接将套接字描述符从内存清除。</p>
</blockquote>
<h3 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;  <span class="comment">//返回值：以网络字节序表示的32位整数</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>; <span class="comment">//返回值：以网络字节序表示的16位整数</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;   <span class="comment">//返回值：以主机字节序表示的32位整数</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;  <span class="comment">//返回值：以主机字节序表示的16位整数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl32</span><span class="params">(<span class="type">uint32_t</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> a = <span class="number">0</span>;</span><br><span class="line">  a |= ((number &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x000000FF</span>);</span><br><span class="line">  a |= ((number &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span>);</span><br><span class="line">  a |= ((number &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0x00FF0000</span>);</span><br><span class="line">  a |= ((number &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x0000FF00</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htonl16</span><span class="params">(<span class="type">uint16_t</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint16_t</span> a = <span class="number">0</span>;</span><br><span class="line">  a |= ((number &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>);</span><br><span class="line">  a |= ((number &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><h4 id="点分十进制转32位网络字节序"><a href="#点分十进制转32位网络字节序" class="headerlink" title="点分十进制转32位网络字节序"></a>点分十进制转32位网络字节序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;  <span class="comment">//cp 点分十进制地址</span></span><br><span class="line"><span class="comment">//返回网络字节序的32位地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧函数，只支持IPV4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span>; <span class="comment">// cp 点分十进制地址; inp 转换结果空间的首地址，即存放转换结果的变量的地址</span></span><br><span class="line"><span class="comment">//成功返回1 ，失败返回0， 出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新函数，支持IPV4和IPV6</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;  <span class="comment">/*  af IP地址类型AF_INET(IPV4)、AF_INET6(IPV6); </span></span><br><span class="line"><span class="comment">                                                        cp 点分十进制地址; </span></span><br><span class="line"><span class="comment">                                                        inp 存放转换结果的缓冲区, 如果是IPV4需要4字节, IPV6需要16字节</span></span><br><span class="line"><span class="comment">                                                    */</span></span><br><span class="line"><span class="comment">//成功返回1 ，失败返回0， 出错返回-1</span></span><br></pre></td></tr></table></figure>
<h4 id="32位网络字节序转点分十进制"><a href="#32位网络字节序转点分十进制" class="headerlink" title="32位网络字节序转点分十进制"></a>32位网络字节序转点分十进制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧函数，只支持IPV4</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br><span class="line"><span class="comment">//返回 点分十进制地址字符串的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新函数，支持IPV4和IPV6</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>; <span class="comment">/*  af IP地址类型AF_INET(IPV4)、AF_INET6(IPV6); </span></span><br><span class="line"><span class="comment">                                                      src 32位网络字节序的二进制IP地址;</span></span><br><span class="line"><span class="comment">                                                      dst 保存点分十进制字符串的缓冲区;</span></span><br><span class="line"><span class="comment">                                                      size dst缓冲区的大小，两个常量INET_ADDRSRTRLEN(IPV4)、INET6_ADDRSTRLEN(IPV6)</span></span><br><span class="line"><span class="comment">                                                    */</span></span><br><span class="line"><span class="comment">//返回值，成功，返回地址字符串指针，失败返回 NULL</span></span><br></pre></td></tr></table></figure>
<h2 id="基于TCP-IP协议网络编程模型"><a href="#基于TCP-IP协议网络编程模型" class="headerlink" title="基于TCP/IP协议网络编程模型"></a>基于TCP/IP协议网络编程模型</h2><p><img src="https://github.com/zjn-astonishe/image/blob/main/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.png?raw=true" alt="基于TCP/IP协议网络编程模型"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>TCP并发服务器的思想是每一个客户机的请求并不由服务器直接处理，二十由服务器创建一个子进程(子线程)来处理。</p>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/TCP%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B.png?raw=true" alt="TCP多进程/多线程服务器模型"></p>
<ul>
<li>TCP多进程服务器模型<ul>
<li>优点<ul>
<li>安全、进程之间相互隔离，一个进程崩溃不会导致整个服务器崩溃。</li>
</ul>
</li>
<li>缺点<ul>
<li>占用资源较大</li>
</ul>
</li>
</ul>
</li>
<li>TCP多线程服务器模型<ul>
<li>优点<ul>
<li>占用资源较少</li>
</ul>
</li>
<li>缺点<ul>
<li>不安全，因为线程之间是共享进程的资源，一个线程崩溃会导致服务器整个进程崩溃</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux网络编程</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程导引</title>
    <url>/2022/08/04/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2022-08-04-Linux%E7%BD%91%E7%BB%9C%E5%AF%BC%E5%BC%95/</url>
    <content><![CDATA[<h1 id="Linux网络编程导引"><a href="#Linux网络编程导引" class="headerlink" title="Linux网络编程导引"></a>Linux网络编程导引</h1>]]></content>
      <categories>
        <category>Linux</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动设计的硬件基础</title>
    <url>/2022/08/08/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/2022-08-08-%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="驱动设计的硬件基础"><a href="#驱动设计的硬件基础" class="headerlink" title="驱动设计的硬件基础"></a>驱动设计的硬件基础</h1>]]></content>
      <categories>
        <category>Linux</category>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Linux设备驱动</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>简单样例分析：LED驱动</title>
    <url>/2022/08/09/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/2022-08-09-%E7%AE%80%E5%8D%95%E6%A0%B7%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%9ALED%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="简单样例分析：LED驱动"><a href="#简单样例分析：LED驱动" class="headerlink" title="简单样例分析：LED驱动"></a>简单样例分析：LED驱动</h1><h2 id="裸机的LED驱动"><a href="#裸机的LED驱动" class="headerlink" title="裸机的LED驱动"></a>裸机的LED驱动</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> reg_gpio_ctrl *(volatile int *) (ToVirtual(GPIO_REG_CTRL))  <span class="comment">// ToVirtual(), 把物理地址映射为虚拟地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg_gpio_data *(volatile int *) (ToVirtual(GPIO_REG_DATA))</span></span><br><span class="line"><span class="comment">//初始化LED</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LightInit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    reg_gpio_ctrl |= (<span class="number">1</span> &lt;&lt; n); <span class="comment">/*设置GPIO为输出*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点亮LED</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LightOn</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    reg_gpio_data |= (<span class="number">1</span> &lt;&lt; n); <span class="comment">/*在GPIO上输出高电平*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//熄灭LED</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LightOff</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    reg_gpio_data &amp;= ~(<span class="number">1</span> &lt;&lt; n); <span class="comment">/*在GPIO上输出低电平*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linux下的LED驱动"><a href="#Linux下的LED驱动" class="headerlink" title="Linux下的LED驱动"></a>Linux下的LED驱动</h2>]]></content>
      <categories>
        <category>Linux</category>
        <category>设备驱动</category>
      </categories>
      <tags>
        <tag>Linux设备驱动</tag>
        <tag>硬件</tag>
        <tag>样例分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Calling, MCP and A2A</title>
    <url>/2025/04/14/MCP/2025-04-14-Function%20Calling,%20MCP%20and%20A2A/</url>
    <content><![CDATA[<h1 id="Function-Calling-MCP-and-A2A"><a href="#Function-Calling-MCP-and-A2A" class="headerlink" title="Function Calling, MCP and A2A"></a>Function Calling, MCP and A2A</h1><h2 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h2><p>Function Calling允许大语言模型与外部工具连接，将自然语言转换为API调用。这解决了大模型在训练结束，就知识更新停滞的问题。调用外部工具和服务能准确解决实时性问题。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="" alt="Function Calling 工作流程"></p>
<p>Function Calling的工作流程大致如下: </p>
<ol>
<li>识别需求<ul>
<li>识别问题类型，查找对应需要调用的API。</li>
</ul>
</li>
<li>选择函数<ul>
<li>选择可用的函数。</li>
</ul>
</li>
<li>准备参数<ul>
<li>例如要获得温度: {“location”: “Beijing”, “unit”: “celsius”} </li>
</ul>
</li>
<li>调用函数<ul>
<li>使用参数调用API。</li>
</ul>
</li>
<li>整合回答</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>对开发者来说，使用LLM的Function Calling起步相对容易，只需按照API要求定义函数规格(通常JSON模式)并将其随请求发送，模型就可能按照需要调用这些函数，逻辑较直观。适用于单一模型、少量功能的简单应用。</p>
<p>但局限在于缺乏跨模型的一致性: 每个LLM供应商的接口格式略有差异，开发者如果想支持多个模型，需要为不同的API进行适配或使用额外的框架进行处理。</p>
<h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p><a href="https://zjn-astonishe.github.io/2025/04/08/MCP/2025-04-08-MCP/">MCP 笔记</a></p>
<h2 id="Agent-to-Agent-A2A"><a href="#Agent-to-Agent-A2A" class="headerlink" title="Agent-to-Agent(A2A)"></a>Agent-to-Agent(A2A)</h2><p>A2A谷歌最新推出的开放协议，旨在实现不同Agent之间的通信和协同问题。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>Agent Card: 一个公共元数据文件，描述智能体的能力、技能、端点URL和认证需求等信息，类似AI智能体的”电子名片”。</li>
<li>A2A Server: 实现A2A协议的智能体服务器，接收请求并管理Task的执行。</li>
<li>A2A Client: 使用A2A服务的应用程序或智能体，向A2A Server发送请求。</li>
<li>Task: A2A协议的工作中心单元，客户端通过发送消息启动Task，具有不同状态以跟踪进度。</li>
<li>Message: 智能体客户端和智能体之间的通信载体，包含多种形式，多个部分。</li>
</ul>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="" alt="A2A协议工作流程"></p>
<p>首先，A2A Client（就像点餐的顾客）向A2A Server发送请求，启动一个任务。接着，服务器处理请求并返回响应，告知任务的状态。任务在执行过程中可能会经历多个状态，如已提交、处理中、需要输入等，最终完成或失败。</p>
<h2 id="三者的联系"><a href="#三者的联系" class="headerlink" title="三者的联系"></a>三者的联系</h2><h3 id="Function-Calling的局限性"><a href="#Function-Calling的局限性" class="headerlink" title="Function Calling的局限性"></a>Function Calling的局限性</h3><ul>
<li>Function Calling由于缺乏统一标准，不同LLM需要各自的函数定义格式：如果有M个不同LLM应用和N个不同工具/服务，理论上可能需要实现$M\times N$次重复的对接工作。</li>
<li>对于函数的链式调用，Function Calling本身并不直接支持多步调用组合，模型只能一次调用一个函数，获取结果后如果需调用下一个函数，需要由应用逻辑将结果反馈为模型下一轮对话的输入，再触发下一个函数调用。虽然在原理上可以实现函数输出作为输入形成链条，但这一切需要开发者在应用层精心编排，模型自身缺乏对跨调用流程的全局观。</li>
<li>MCP则通过统一的接口标准，将复杂的$M\times N$问题转化为$M+N$的问题：工具创建者只需为每个工具/系统实现一次MCP Server，应用开发者只需为每个应用实现一次MCP Client，各自遵循通用协议即可协同工作，扩展新功能的边际成本大幅降低。</li>
</ul>
<h3 id="MCP与A2A的互补关系"><a href="#MCP与A2A的互补关系" class="headerlink" title="MCP与A2A的互补关系"></a>MCP与A2A的互补关系</h3><ul>
<li>MCP让Agent能够使用工具，而A2A让Agent能够与其他Agent协作。一个解决”做什么”，一个解决”与谁合作”。</li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
        <tag>Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP</title>
    <url>/2025/04/08/MCP/2025-04-08-MCP/</url>
    <content><![CDATA[<h1 id="MCP笔记"><a href="#MCP笔记" class="headerlink" title="MCP笔记"></a>MCP笔记</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>当前的大型语言模型(LLM)和智能体在上下文获取和多模型协作上存在诸多限制——数据和上下文孤岛</p>
<p>多智能体协作与多模型配合的需求，但缺少统一的通信协议。行业需要一种通用机制来让不同模型、不同智能体共享上下文、协调行动。</p>
<h3 id="数据孤岛"><a href="#数据孤岛" class="headerlink" title="数据孤岛"></a>数据孤岛</h3><ul>
<li>再强大的模型如果与数据库、知识库等外部信息源隔绝，其能力都会大打折扣。</li>
<li>移植性差：每接入一个新数据源往往需要定制开发插件或接口。</li>
</ul>
<h3 id="上下文孤岛"><a href="#上下文孤岛" class="headerlink" title="上下文孤岛"></a>上下文孤岛</h3><ul>
<li>多轮推理和长程记忆机制缺乏标准支持，智能体难以在长任务过程中保持连贯的“记忆”。</li>
<li>用户在不同会话或不同工具间不得不重复提供相同信息。</li>
</ul>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Model Context Protocol(模型上下文协议, MCP)是由 Anthropic 公司于 2024 年底提出并开源发布的一种开放标准协议，旨在提供统一的方法来管理上下文和整合多源信息，从而打破AI与外部环境之间的壁垒。类似USB-C之于硬件连接，即插即用。定义了AI助手(大型模型)与外部数据源、工具或其它服务交换上下文信息的通用方式，目的是标准化AI与外部世界交互的接口。</p>
<p>目前，Anthropic的Claude系列，Open AI的GPT系列、Meta的Llama系列，deepseek、阿里的通义系列，Anysphere的Cursor，各种主流模型均已接入MCP生态。</p>
<ul>
<li>统一标准接口: 不同的工具和数据源都通过统一协议与模型交互，减少过去需要针对每个系统单独开发连接器的繁琐。</li>
<li>安全双向通信: 允许数据源向AI提供上下文，也允许AI请求执行操作，同时确保权限和隐私可控。引入身份认证和授权机制(OAuth2.1 标准)，保证模型与工具之间的数据交换是受保护的。</li>
<li>模块化与可插拔: 将现有系统封装成MCP服务端(数据源侧)对外提供数据/功能，也可以构建支持MCP的AI客户端(应用侧)来消费这些服务。</li>
<li>上下文保留与智能: 让 AI 拥有持续的上下文。AI助手能够在多轮对话中记住用户偏好并动态学习。<ul>
<li>有状态性(Statefulness): 支持会话级别和长期的上下文记忆。</li>
<li>互操作性(Interoperability): 可跨模型、工具和数据源协同。</li>
<li>以智能体为中心的设计(Agent-Centric Design): 在既定边界内自主决策</li>
</ul>
</li>
<li>模型间通信与协作<ul>
<li>不仅AI模型可以和传统数据源交互，模型与模型之间也可以通过 MCP 协议进行沟通与协作。<ul>
<li>跨模型兼容意味着不同厂商或架构的模型都能采用 MCP 接入相同的工具生态。开发者可以“拨动开关”切换底层模型，而无需重写集成代码，从而在不同LLM之间切换自如，实现模型的解耦和替代。</li>
<li>可以共享同一套上下文和工具：一种协作方式是由一个主代理协调，其他代理作为特定MCP服务器提供专长能力。</li>
</ul>
</li>
<li>所有代理共同访问某个共享的MCP资源(如一个知识库服务器)，从而在各自任务中保持信息同步。</li>
</ul>
</li>
</ul>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="" alt="MCP架构"></p>
<ul>
<li>MCP采用客户端-服务器(Client-Server)架构来组织 AI 与外部资源的交互。<ul>
<li>服务器: 由数据源或工具一侧实现，负责对外提供标准化的接口，相当于”工具箱”。封装了实际的数据或功能(数据库查询、调用第三方API、文件读取)。对外暴露为一组标准命令或资源访问点。<ul>
<li>轻量级程序</li>
<li>MCP的核心，连接AI模型与实际数据源。</li>
</ul>
</li>
<li>客户端: 运行在 AI 智能体一侧，负责向服务器发送请求并获取结果。部署在LLM应用(某个聊天机器人程序，或集成开发环境中的AI助手)。通过协议调用多个服务器以获取所需信息。客户端与每个目标服务器保持一对一的连接。<ul>
<li>处理通信细节，确保主机和服务器之间的数据传输顺畅。</li>
</ul>
</li>
<li>主机: 承载 AI 应用的环境。例如: Claude桌面应用、某IDE或Agent运行容器。运行着MCP客户端模块和LLM本身。负责管理客户端与服务器的连接和生命周期。<ul>
<li>需要访问数据的程序。</li>
<li>MCP生态系统的入口点，负责向用户提供AI功能。</li>
</ul>
</li>
<li>数据源<ul>
<li>本地数据源：<ul>
<li>用户计算机上的文件、数据库和服务，MCP服务器可以安全访问这些资源。</li>
</ul>
</li>
<li>远程服务:<ul>
<li>通过互联网可用的外部系统(如通过API)，MCP服务器可以连接这些系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传输设计"><a href="#传输设计" class="headerlink" title="传输设计"></a>传输设计</h3><ul>
<li>MCP本身与传输无关。常见实现包括本地标准输入输出管道(stdio)通信、HTTP 通信等都可以用于MCP。<ul>
<li>在本地部署时，Claude 桌面版通过标准IO管道与本地 MCP 服务器对接</li>
<li>在分布式环境下，也可以采用 HTTP/HTTPS 请求和长连接来通信</li>
<li>最新的规范版本进行了改进，用可双向流式传输的HTTP替代了早期的HTTP+SSE，实现实时响应和更好的兼容性。</li>
</ul>
</li>
<li>传输层之上采用JSON-RPC 2.0，便于解析。<ul>
<li>定义了请求(request)、结果(result)、错误(error)等消息类型 </li>
</ul>
</li>
</ul>
<h3 id="消息协议"><a href="#消息协议" class="headerlink" title="消息协议"></a>消息协议</h3><ul>
<li>规定了严格的消息格式和流程，以确保模型与工具之间通信的规范性和可靠性。</li>
<li>基于JSON-RPC协议，每条请求都包含方法名称、参数等，服务器处理后返回结果或错误码。使不同实现之间具有一致的语言，避免歧义。</li>
<li>最新规范增加了批量请求(batching)能力，允许客户端一次发送多个请求并行执行，减少交互往返，提高效率。</li>
<li>协议引入工具注解(Tool Annotations)机制，服务器可以用元数据描述其提供的功能(如功能名称、参数说明、可能的输出等)。客户端(模型)可以读取这些描述，从而“了解”每个工具会做什么。使得智能体能够更加自主地选择和组合工具。不必完全依赖开发者硬编码调用逻辑。</li>
</ul>
<h3 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h3><ul>
<li>引入了会话上下文的概念，让交互变得有状态。维护每个会话的状态，当 AI 再次调用时，无需重复提供已有的信息。<ul>
<li>支持多步工作流的状态管理：智能体可以记住已执行的动作，根据上下文调整策略，根据反馈自行纠错</li>
</ul>
</li>
<li>允许在多次请求-响应之间保存和传递上下文<ul>
<li>对话历史、用户偏好、环境信息等</li>
</ul>
</li>
<li>防止上下文无限增长导致信息过载，还实现了上下文压缩和嵌入等机制。<ul>
<li>非关键性的历史内容可以被压缩为向量嵌入或摘要，保留其语义表示而减少占用。<ul>
<li>浓缩成要点向量存储和明文结合</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="与现有AI系统的集成方式"><a href="#与现有AI系统的集成方式" class="headerlink" title="与现有AI系统的集成方式"></a>与现有AI系统的集成方式</h3><ul>
<li>主要通过客户端和服务器两端的SDK和开放接口来实现整合：<ul>
<li>客户端: 使用官方提供的SDK将模型包装，使其能够发送/接收MCP定义的JSON-RPC消息。自己的大模型需加入MCP客户端模块，赋予其连接MCP服务器的能力。</li>
<li>服务端: Anthropic提供了开源的MCP Server示例和模板，开发者可以根据自己的数据源实现对应的接口。任何具有API或可编程接口的系统理论上都能快速变成一个MCP插件。</li>
</ul>
</li>
<li>与代理型框架结合: 与现有的AI Agent框架(LangChain, Haystack)结合，作为统一的工具接入层。<ul>
<li>LangChain等框架不再需要针对每个新工具编写特定Wrapper，只需调用 MCP 接口即可获取结果，极大简化了扩展能力。</li>
</ul>
</li>
<li>跨平台和多语言支持: Anthropic维护了多种语言的官方SDK，微软则贡献了C#版本以方便在.NET平台集成。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="多智能体协作"><a href="#多智能体协作" class="headerlink" title="多智能体协作"></a>多智能体协作</h3><p>需要多个AI代理协同工作的场景下，MCP提供了标准机制让智能体彼此交流、共享信息。MCP支持多Agent无缝协同，不同Agent可以共享上下文和工具。能够让多个AI在研究分析、客户支持、自动化流程等任务中协同作战，如同一个多才多艺的团队。</p>
<ul>
<li>一个负责规划的智能体可以通过 MCP 将任务下达给另一个执行型智能体，并获取其结果；</li>
<li>多个领域专家型代理(如一个擅长医学，一个擅长法律)可以共同接入同一个知识库MCP服务器，各自贡献和提取所需信息，从而为用户提供综合解答。</li>
</ul>
<h3 id="自动化工作流"><a href="#自动化工作流" class="headerlink" title="自动化工作流"></a>自动化工作流</h3><p>通过MCP，AI智能体能够触发和协调多个步骤：每个步骤可能涉及不同的工具或服务。尤其适合那些需要横跨多个IT系统的流程自动化。当环境数据变化时，AI代理可以即使调整策略，而无需人工修改流程脚本。</p>
<ul>
<li>招聘流程中，一个AI助理可以通过MCP从招聘系统获取候选人资料，调用日历API安排面试日程，接着使用邮件服务发送通知，最后将结果记录到HR数据库—all in one go。AI助理根据上下文做判断(如候选人时区、本公司面试官空闲时间等)，而具体执行操作都由相应的MCP连接器完成。工作流的上下文(比如当前进行到哪一步、已有的信息)可以在MCP框架下持续传递，避免每个步骤的信息隔断。某一步失败或用户有反馈，AI还能根据全局上下文调整流程。</li>
<li>在供应链管理中，AI代理可通过 MCP 同时查询库存、物流、销售预测等多个系统的数据，综合决策后再调用下单和调度接口完成操作。</li>
</ul>
<h3 id="AI助手和个人智能体"><a href="#AI助手和个人智能体" class="headerlink" title="AI助手和个人智能体"></a>AI助手和个人智能体</h3><p>过去的AI助手大多局限在对话生成，无法执行动作或获取实时信息。</p>
<ul>
<li>信息查询类助手<ul>
<li>调用Web搜索MCP服务器获取实时网页信息，调用数据库MCP接口检索内部资料，调用第三方API获取专门数据，综合整理后反馈给用户。</li>
</ul>
</li>
<li>事务处理类助手</li>
<li>专业领域助手<ul>
<li>诸如Zed、Replit、Codeium等代码平台正利用 MCP，让AI能够检索项目代码、读取Git历史，在充分上下文下给出更准确的代码建议。</li>
<li>通过MCP将Figma设计文件连接给代码生成AI，实现设计到前端代码的自动化转换。</li>
</ul>
</li>
</ul>
<h2 id="对AI-Agent的增强"><a href="#对AI-Agent的增强" class="headerlink" title="对AI Agent的增强"></a>对AI Agent的增强</h2><h3 id="上下文感知能力显著增强"><a href="#上下文感知能力显著增强" class="headerlink" title="上下文感知能力显著增强"></a>上下文感知能力显著增强</h3><p>借助MCP，智能体获得了持久的”记忆”，可以跨会话、跨工具调用保持对用户和环境的了解。环境感知也同步提升——通过 MCP，智能体可以获知用户当前设备、位置等环境信息并做出相应调整。</p>
<h3 id="记忆协调与自主学习"><a href="#记忆协调与自主学习" class="headerlink" title="记忆协调与自主学习"></a>记忆协调与自主学习</h3><p>即时上下文存在对话窗口，长程记忆存储在MCP服务器（如外部知识库或日志）中，中程记忆则通过嵌入进行压缩保留。智能体能够主动在不同层次记忆间进行取舍——例如近期对话重点直接保留，久远内容压缩存档以供需要时参考。这种协调机制避免了模型因上下文超长而遗忘关键信息，也控制了噪音干扰。更重要的是，MCP 使智能体可以在任务过程中动态更新其知识。它可以将新获得的信息写回MCP上下文，实现持续的知识学习；也可以根据用户反馈，通过MCP接口调用纠错或优化模块来自我改进。具备了一定程度的自主适应能力——不仅是被动响应，还能总结经验、调整行为，在长期互动中变得更加智能。</p>
<h3 id="多模型协作与工具融合能力"><a href="#多模型协作与工具融合能力" class="headerlink" title="多模型协作与工具融合能力"></a>多模型协作与工具融合能力</h3><p>一个单一的大模型Agent，通过MCP可以调用其他模型或工具的能力，实质上形成了能力的扩展和组合。不需要内置所有能力，而是可以按需调用外部专长模型(视觉的、语音的、计算的等)，从而成为一个灵活的多才智能体。</p>
<p>可以无缝切换底层模型，根据任务需求或负载，在不改变智能体行为逻辑的情况下切换所使用的大模型(GPT系列、Claude系列、本地模型等)</p>
<h3 id="自主决策和智能体性能提升"><a href="#自主决策和智能体性能提升" class="headerlink" title="自主决策和智能体性能提升"></a>自主决策和智能体性能提升</h3><p>标准化的协议和丰富的元信息使智能体可以更加自主地规划和行动。工具注解提供的功能描述等信息，相当于给了智能体一份“操作指南”，使其能够自主发现可用工具并推断使用方法。</p>
<p>更加可监控和调试。每一步交互都是规范的请求/响应，开发者或运维可以轻易记录并审查智能体的决策过程，针对问题进行优化。</p>
<h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><h3 id="学习途径"><a href="#学习途径" class="headerlink" title="学习途径"></a>学习途径</h3><p><a href="https://modelcontextprotocol.io/introduction">开发文档</a></p>
<h3 id="选择兼容-MCP-的工具和平台"><a href="#选择兼容-MCP-的工具和平台" class="headerlink" title="选择兼容 MCP 的工具和平台"></a>选择兼容 MCP 的工具和平台</h3><p>优先选择那些已经提供 MCP 接口的模型服务或软件系统。目前 Anthropic Claude、OpenAI 的 Agents SDK 等都已兼容MCP。</p>
<h3 id="评估业务场景，制定集成路线图"><a href="#评估业务场景，制定集成路线图" class="headerlink" title="评估业务场景，制定集成路线图"></a>评估业务场景，制定集成路线图</h3><ul>
<li><p>出那些最能够从AI智能体和上下文整合中受益的场景。</p>
<ul>
<li>客服问答是否需要连接内部知识库，</li>
<li>业务决策是否需要综合多系统数据，</li>
<li>研发流程是否因上下文切换效率低下等。</li>
</ul>
</li>
<li><p>接着制定 MCP 集成的路线图：</p>
<ul>
<li>第一步可以选取一个痛点明显且技术可行性高的用例进行试点，实现AI代理通过MCP访问一两个关键系统；</li>
<li>在获得成果和经验后，再逐步扩展到更多系统和复杂流程。</li>
<li>这样的循序渐进有助于风险可控地引入MCP，同时向组织内部展示价值以获得更多支持。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
        <tag>Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 1</title>
    <url>/2022/02/28/OS/2022-02-28-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%201/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="进程线程的基本概念"><a href="#进程线程的基本概念" class="headerlink" title="进程线程的基本概念"></a>进程线程的基本概念</h2><h3 id="什么是进程、线程-彼此有什么区别"><a href="#什么是进程、线程-彼此有什么区别" class="headerlink" title="什么是进程、线程(彼此有什么区别)"></a>什么是进程、线程(彼此有什么区别)</h3><ul>
<li>进程是<strong>资源(CPU、内存等)分配</strong>的基本单位，线程是<strong>CPU调度</strong>的基本单位(<strong>程序执行的最小单位</strong>)。<ul>
<li>程序运行时，系统会给程序创建一个进程，并分配给予地址空间和其他资源，然后把进程加入到就绪队列中等待CPU执行。</li>
<li>线程是进程的一个执行流，实际上进程不能用来运行代码，真正运行代码的是进程里的线程。</li>
</ul>
</li>
<li>一个进程由<code>PCB</code>(进程控制块)、数据段、代码段组成<ul>
<li>进程一般会先创建出一个主线程，分配给主线程一定的系统资源，让主线程运行起来实现各种功能。主线程里可以创建出多个子线程，多个子线程在同一个进程里，利用进程所拥有的资源合作完成一系列更为复杂的功能。<blockquote>
<p>C程序中的main函数：</p>
<p>一方面作为程序入口，可以被认为是程序的主线程。</p>
<p>另一方面系统在执行main函数的时候，main函数又是一个独立的进程，程序员可以在main函数里编写插入创建子进程、子线程的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> g_cnt = <span class="number">0</span>;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">thread</span><span class="params">(<span class="type">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m_cnt = <span class="number">0</span>;</span><br><span class="line">    m_cnt = <span class="number">5</span>;</span><br><span class="line">    g_cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> m_cnt = <span class="number">0</span>;</span><br><span class="line">    err=<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);  <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != err)   <span class="comment">//检验是否创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can&#x27;t creat thread: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(err)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(g_cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);   <span class="comment">//延迟300毫秒，让子线程运行一会儿</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;g_cnt = &quot;</span> &lt;&lt;  g_cnt &lt;&lt; <span class="string">&quot;, m_cnt = &quot;</span> &lt;&lt; m_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数里创建的多个子线程中，每个线程都将有自己的堆栈和局部变量，多个子线程还可以共享同个进程下的所有共享资源(例如全局变量)，因此可以通过创建多个线程来实现并发操作，完成更复杂的任务。</p>
<p>在上述代码中，main函数是一个主线程，由它开始执行程序。</p>
<p>但同时，main函数也扮演了进程的角色，因为它通过pthread_create函数创建了一个额子线程，用来执行函数thread()。子线程拥有自己的堆栈和局部变量，与主线程共享同一进程下的所有共享资源，如全局变量g_cnt，</p>
<p>所以主线程要输出的变量中，</p>
<p>g_cnt是子线程与主线程共享的全局变量，输出结果为1</p>
<p>m_cnt是各线程独自拥有的局部变量，子线程m_cnt的改变无法影响要输出的主线程m_cnt的值，输出结果为0</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="多进程、多线程的优点"><a href="#多进程、多线程的优点" class="headerlink" title="多进程、多线程的优点"></a>多进程、多线程的优点</h3><ul>
<li>由运行的稳定性来说<ul>
<li>多进程更健壮，一个进程停止运行不会影响其他进程，紫禁城停止运行也不会影响主进程的运行，因为进程是资源分配的基本单位，即系统为每个进程分配独立的资源。</li>
<li>多线程更脆弱，一个线程崩溃很可能影响到整个程序，因为线程是CPU调度的基本单位，多个线程都是在一个进程里运行的，其中难免会有一些共享的资源空间。</li>
</ul>
</li>
<li>从运行的性能来看<ul>
<li>进程的性能大于线程，每个进程都有独立的地址空间和资源</li>
<li>而多个线程是一起共享同个进程的空间和资源，线程存在竞争资源空间的问题，所以在性能方面比不上进程。</li>
</ul>
</li>
<li>从系统花销来看<ul>
<li>由于进程需要独立的地址空间和资源，因此创建多进程的系统化小要远大于多线程</li>
</ul>
</li>
<li>从数据传送来看<ul>
<li>多进程通讯因为需要跨越进程边界，因此不适合大量数据的传送，更适合小数据或者密集数据传送</li>
<li>多线程在同一个进程里运行，不需要跨越进程边界，适合各线程间大量数据传送，甚至多线程可以共享同一进程里的共享内存和变量</li>
</ul>
</li>
<li>从逻辑控制来看<ul>
<li>多进程逻辑控制比多线程复杂，需要与主进程交互，用来合作”做大事”</li>
<li>而多线程通常用来各自”做小事”(虽然其逻辑控制比较简单，但是需要复杂的线程同步和加锁控制等机制实现同步互斥)</li>
</ul>
</li>
<li>从增加数量上限来看<ul>
<li>进程数量可以通过增加CPU数量的方式来增加</li>
<li>线程数量由进程的空间资源和线程本身栈大小确定，无法通过增加CPU数量增加</li>
</ul>
</li>
</ul>
<h3 id="进程和线程的取舍"><a href="#进程和线程的取舍" class="headerlink" title="进程和线程的取舍"></a>进程和线程的取舍</h3><ul>
<li>创建和销毁较频繁的情况使用线程，因为创建和销毁进程的花销较大</li>
<li>需要大量数据传送的情况使用线程，多线程切换速度快，且不需要跨进程边界</li>
<li>并行操作使用线程(为实现并行的手段)</li>
<li>安全稳定的需求使用进程，快速频繁的需求选用线程</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>有一类子进程是不需要复制父进程的内存和数据的，单纯为了方便调用外部程序而创建</li>
<li>一个播放器框架<blockquote>
<p>主线程main函数创建子进程player执行播放视频的代码——调用外部播放器播放视频，创建子线程check监测播放器按钮情况，而main函数执行while(1)死循环。当用户按下播放器的某些按钮如：上一部、下一部时，子线程check会通知主线程main函数，让其再次创建子进程player调用外部播放器播放视频</p>
</blockquote>
</li>
</ul>
<h3 id="多进程、多线程同步-通讯-的方法"><a href="#多进程、多线程同步-通讯-的方法" class="headerlink" title="多进程、多线程同步(通讯)的方法"></a>多进程、多线程同步(通讯)的方法</h3><ul>
<li>进程间的通讯<ul>
<li>管道/命名、无名管道：<ul>
<li>一个管道实际上就是个<strong>只存在于内存中</strong>的文件，对这个文件的操作要通过两个已经打开的文件进行(管道两端)。但是，管道是一个特殊的文件，即它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。两个进程结束的时候，管道也会自动消失。</li>
<li>无名管道主要用于父进程与子进程之间，或者两个兄弟进程之间。Linux系统中可以通过系统调用建立起一个单向的通信管道，且这种关系只能由父进程来建立。因此，每个管道都是单向的，当需要双向通信的时候就需要建立起两个管道。管道两端的进程都将该管道看作是一个文件，一个进程负责往管道中写内容，一个进程负责从管道中读取。这种传输遵循先入先出(FIFO)的规则。</li>
<li>命名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计。建立在实际的磁盘戒指或是文件系统中会有自己名字的文件(<strong>不是只在内存</strong>)。任何进程任何时间通过文件名或者路径名都可以与该文件建立联系。<ul>
<li>引入新的文件类型——FIFO文件(遵循先进先出的原则)。命名管道一旦建立，之后读写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅仅是节点，文件数据还是存在于内存缓冲页面，和无名管道相同。</li>
</ul>
</li>
</ul>
</li>
<li>信号 <ul>
<li>进程间传递的消息，软中断</li>
</ul>
</li>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量<ul>
<li>用于同步</li>
</ul>
</li>
<li>socket</li>
</ul>
</li>
<li>线程间的通信<ul>
<li>信号量<ul>
<li>用于同步，保证程序按照正确的顺序运行</li>
</ul>
</li>
<li>读写锁</li>
<li>条件变量</li>
<li>互斥锁<ul>
<li>用于互斥，即保证同一资源不能被同时访问</li>
</ul>
</li>
<li>自旋锁</li>
</ul>
</li>
<li>临界区指的是访问公共资源的程序片段，不是通信方式</li>
</ul>
<h3 id="进程的空间模型"><a href="#进程的空间模型" class="headerlink" title="进程的空间模型"></a>进程的空间模型</h3><ul>
<li>32位系统中，当系统运行一个程序，就会创建一个进程，系统会为其分配<strong>4G的虚拟地址空间</strong>，其中<strong>0-3G是用户空间</strong>，<strong>3-4G是内核空间</strong>，内核空间是受保护的，用户不能对该空间进行读写操作，否则可能出现段错误。其中栈空间的数据地址增加是往下的(新的数据地址值反而更小)，堆空间的地址增加是往上的。</li>
<li>空间模型分析<ul>
<li>栈区<ul>
<li>由编译器自动分配和释放，存放函数的参数值(形参)、局部变量等，其操作方式类似数据结构的栈，先进后出。</li>
<li>栈的空间有限，堆是很大的自由存储区，程序在编译期对变量和函数分配内存都在栈上进行，程序运行过程中函数调用参数的传递也是在栈上进行</li>
</ul>
</li>
<li>堆区<ul>
<li>一般由程序员分配和释放，若程序员不释放，可能会造成内存泄漏，程序结束的时候可能会被操作系统回收，分配方式类似链表，但不是数据结构中的堆。</li>
</ul>
</li>
<li>全局区(静态区)<ul>
<li>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在区域<code>.data</code>，未初始化的全局变量和未初始化的静态变量存储在相邻的区域<code>.bss</code>，程序结束后由系统释放。</li>
</ul>
</li>
<li>文字常量区<ul>
<li>常量字符串存储位置，程序结束后由系统释放。</li>
</ul>
</li>
<li>程序代码区(text)<ul>
<li>存放函数体的二进制代码。</li>
</ul>
</li>
<li>.rodata数据段用于<code>存放C中的字符串</code>和<code>#define定义的常量</code><br><img src="https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Linux内核空间模型"></li>
</ul>
</li>
<li>64位操作系统下的虚拟内存空间大小：<ul>
<li>地址空间一般是$2^{48}$(256TB)，因为$2^{64}$太大，过大的空间只会造成资源的浪费。<ul>
<li>40位标识物理地址(可以找到存储对应物理地址的位置)</li>
<li><code>0x0000000000000000</code>~<code>0x00007fffffffffff</code>表示用户空间<ul>
<li>内核功能模块运行在内核空间。</li>
<li>内核运行在最高权限级别的内核态，可以进行所有操作。</li>
</ul>
</li>
<li><code>0xFFFF800000000000</code>~<code>0xFFFFFFFFFFFFFFFF</code>表示内核空间<ul>
<li>应用程序运行在用户空间。</li>
<li>应用程序运行在较低级别的用户态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程创建线程数量的决定因素"><a href="#进程创建线程数量的决定因素" class="headerlink" title="进程创建线程数量的决定因素"></a>进程创建线程数量的决定因素</h3><ul>
<li>虚拟内存的大小</li>
<li>分配给线程的调用栈大小决定</li>
</ul>
<h3 id="进程、线程的状态转换图"><a href="#进程、线程的状态转换图" class="headerlink" title="进程、线程的状态转换图"></a>进程、线程的状态转换图</h3><ul>
<li>状态<ul>
<li>创建态(new)<ul>
<li>一个进程(线程)正在被创建，还没转换到就绪态之前的状态。</li>
</ul>
</li>
<li>就绪态(ready)<ul>
<li>一个进程(线程)获得了除CPU时间片之外的一切所需资源，一旦得到CPU时间片即可被CPU调度运行。</li>
</ul>
</li>
<li>运行/执行态(running)<ul>
<li>一个进程(线程)得到CPU调度正在处理机上运行时的状态。</li>
</ul>
</li>
<li>睡眠/挂起态(sleep)<ul>
<li>由于某些资源暂时不可得到而进入该状态，将进程(线程)挂起，等待唤醒。</li>
</ul>
</li>
<li>阻塞/暂停态(blocked)<ul>
<li>一个进程(线程)正在等待某一事件而暂停运行时，如等待某资源成为可用，或等待文件读取完成。</li>
</ul>
</li>
<li>结束/僵尸态(exit)<ul>
<li>一个进程(线程)正在从系统中消失时的状态，进程(线程)结束或其他原因导致。</li>
</ul>
</li>
<li>死亡态(die)<ul>
<li>进程(线程)生命周期结束，所占用资源归还。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E7%94%9F.png?raw=true" alt="进程(线程)的一生"></p>
<blockquote>
<p>父进程调用fork()函数创建子进程，此时子进程处于创建态，系统将为进程分配地址和资源，</p>
<p>然后将其加入就绪队列，子进程进入就绪态。</p>
<p>就绪态的进程得到CPU时间片调度正式运行，进入执行态。在执行态将可能有四种情况发生：</p>
<ol>
<li>时间片耗尽或者被其他进程抢占，将重新进入就绪态，等待下一次CPU时间片。</li>
<li>由于某些资源暂时不可得到(如访问文件冲突)进入睡眠态，等待资源可得后再被唤醒，进入就绪态。</li>
<li>收到<strong>SIGSTOP/SIGTSTP信号</strong>进入暂停态，指导收到<strong>SIGCONT信号</strong>进入就绪态。</li>
<li>进程执行结束，通过内核调用进入僵尸态，等待资源回收。当父进程调用<strong>wait()/waitpid()</strong>后接收结束子进程，该进程进入死亡态。</li>
</ol>
</blockquote>
<h3 id="父进程和子进程的关系"><a href="#父进程和子进程的关系" class="headerlink" title="父进程和子进程的关系"></a>父进程和子进程的关系</h3><ul>
<li>子进程继承父进程的：<ul>
<li>用户号<code>UIDs</code>和用户组号<code>GIDs</code></li>
<li>环境<code>Environment</code></li>
<li>堆栈</li>
<li>共享内存</li>
<li>打开文件的描述符</li>
<li>执行时关闭(<code>Close-on-exec</code>)标志</li>
<li>信号(<code>Signal</code>)控制设定</li>
<li>进程组号</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件方式创建屏蔽字</li>
<li>资源限制</li>
<li>控制终端</li>
</ul>
</li>
<li>子进程独有的：<ul>
<li>地址空间</li>
<li>进程号<code>PID</code></li>
<li>不同的父进程号</li>
<li>自己的文件描述符和目录流的拷贝</li>
<li>子进程不继承父进程的进程正文(text)，数据和其他锁定内存(memory locks)</li>
<li>不继承异步输入和输出</li>
</ul>
</li>
<li>父进程调用fork()后，会克隆出一个子进程。但其实是父进程只复制了自己的<code>PCB块</code>交给子进程，而代码段，数据段和用户堆栈内存空间是父进程与子进程共享的。只有当子进程在运行中出现写操作时，才会产生中断，为子进程分配内存空间。<ul>
<li>也就是说：父子进程肯定共享代码空间，但是数据空间通常是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置(两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的)。</li>
<li>fork()在创建子进程的时候，有两个返回值：<ul>
<li>父进程中的返回值是子进程的进程号(不成功则返回错误)。</li>
<li>子进程中的返回值是0。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 2</title>
    <url>/2022/03/02/OS/2022-03-02-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%202/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h2><h3 id="特权模式切换"><a href="#特权模式切换" class="headerlink" title="特权模式切换"></a>特权模式切换</h3><ul>
<li>用户态和内核态的划分，引出上下文的概念。</li>
<li>创建一个进程(如main函数)需要控制一个外部设备时(比如控制LED亮灭)，程序员编写在用户空间的代码通过<strong>系统调用</strong>(操作系统提供给用户空间的接口函数)进入内核空间，由内核继续代表进程运行于内核空间。</li>
<li>在系统调用的过程中发生上下文切换：<ol>
<li>CPU寄存器里面原来用户态的指令位置，需要先保存起来，接着运行内核态代码。</li>
<li>CPU寄存器需要更新为内核态指令的位置，执行内核态代码。</li>
</ol>
</li>
<li>系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后切换为用户空间。</li>
<li>所以一次系统调用的过程，会发生两次的CPU上下文切换</li>
<li>但是一般说系统调用是特权模式切换而不是上下文切换。因为没有涉及到虚拟内存等这些进程用户态的资源，也不会切换进程，属于进程之内的上下文切换。</li>
</ul>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><ul>
<li>进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以用户态和内核态的切换不属于进程上下文切换。</li>
<li>进程的上下文包含了虚拟内存、栈、全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间的状态，所以进程的上下文切换要比系统调用更多一步——保存该进程的虚拟内存、栈等用户空间的资源。</li>
<li>进程上下文切换一般需要几十纳秒到数微秒的CPU时间，当进程上下文切换次数比较多的情况下，将导致CPU耗费大量的时间在寄存器、内核栈即虚拟内存等资源的保存和恢复上。</li>
<li>另外，Linux通过TLB快表来管理虚拟内存到物理内存的映射关系，当虚拟内存更新之后，需要刷新缓存，在这多处理系统上是很复杂的，因为多个处理器共享一个缓存。</li>
<li>进程在被调度的时候需要切换上下文，可能是主动地，也有可能是被动的：<ol>
<li>系统进程正常调度算法导致进程上下文切换。例如目前使用的<strong>时间片轮转算法</strong>，当一个进程的时间片耗尽之后，CPU会将进程调度切换到其他进程。</li>
<li>进程在<strong>资源不足</strong>的时候，会被挂起。例如在等待IO或者内存不足的时候，会主动挂起，并且等待系统调度其他进程。</li>
<li>当进程通过一些睡眠函数<strong>sleep()主动</strong>挂起的时候，也会重新调度。</li>
<li>当有高优先级的进程运行时，当前进程也会被挂起。<strong>(抢占)</strong>。</li>
<li>当发生<strong>硬件中断</strong>时，CPU上的进程会被中断挂起。</li>
</ol>
</li>
</ul>
<h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><ul>
<li>线程上下文切换，分为两种情况：<ol>
<li>前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。</li>
<li>前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。所以同进程内的线程切换要比多进程内的线程切换消耗更少的资源。</li>
</ol>
</li>
</ul>
<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><ul>
<li>中断是为了快速响应硬件的事件——计算机停下当前的事情，去处理其他的事情，然后在回来继续执行之前的任务。</li>
<li>例如在调用print函数的时候，其实汇编的底层会调用一条<strong>int 0x80</strong>的指令，便是调用0x80号中断。</li>
<li>中断要先将当前进程的状态保存下来，这样中断结束后进程仍然可以从原来的状态恢复运行，中断上下文的切换并不涉及进程的用户态，所以当中断程序打断了正在处于用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，只需要保存和恢复这个进程的内核态中的资源包括CPU寄存器、内核堆栈等。</li>
<li>对于同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生，一般来说中断程序都执行比较快短小精悍，以便快速结束执行之前的任务。</li>
<li>当中断上下文切换次数比较多的时候，会耗费大量的CPU时间。所以运行在中断上下文的代码不能做以下几件事：<ol>
<li>睡眠或者放弃CPU，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉。</li>
<li>尝试获得信号量，如果或得不到信号量，代码就会睡眠，结果同上。</li>
<li>执行耗时的任务，中断处理应该尽可能快，因为内核要相应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。</li>
<li>访问用户空间的虚拟地址，中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在无法访问用户空间的虚拟地址。</li>
</ol>
</li>
</ul>
<h3 id="查看CPU上下文切换情况"><a href="#查看CPU上下文切换情况" class="headerlink" title="查看CPU上下文切换情况"></a>查看CPU上下文切换情况</h3><ul>
<li><code>vmstat</code>是一个Linux常用的系统性能分析工具，可以用来分析CPU上下文切换和中断的次数。<ul>
<li><code>vmstat</code>工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数。</li>
<li>输出参数<ul>
<li><code>cs</code>(context switch)：每秒上下文切换的次数。</li>
<li><code>in</code>(interrupt)：每秒中断的次数。<ul>
<li>可以使用<code>cat</code>命令查看<code>/proc/interrupts</code>读取中断详细情况。</li>
</ul>
</li>
<li><code>r</code>(Running or Runnable)：就绪队列的长度，也就是正在运行和等待CPU的进程。</li>
<li><code>b</code>(Blocked)：处于不可中断睡眠状态的进程数。</li>
</ul>
</li>
</ul>
</li>
<li>要想查看每个进程的详细情况就需要使用<code>pidstat</code>，加上<code>-w</code>选项就可以查看进程上下文切换的情况:<ul>
<li>输出参数<ul>
<li><code>cswch</code>(voluntary context switches)：表示每秒<strong>自愿上下文切换</strong>的次数。<ul>
<li>自愿上下文切换：进程无法获取所需的资源，导致的上下文切换，例如IO、内存等资源不足时，就会发生自愿上下文切换。</li>
</ul>
</li>
<li><code>nvcswch</code>(non voluntary context switches)：表示每秒<strong>非自愿上下文切换</strong>的次数。<ul>
<li>非自愿上下文切换：进程由于时间片已到等时间，被系统强制调度，进而发生的上下文切换，例如大量的进程都在争抢CPU时，就容易发生非自愿上下文切换。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CPU上下文切换次数与性能的关系"><a href="#CPU上下文切换次数与性能的关系" class="headerlink" title="CPU上下文切换次数与性能的关系"></a>CPU上下文切换次数与性能的关系</h3><ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU，说明CPU的确成了瓶颈；</li>
<li>中断次数变多了，说明CPU被中断处理程序占用，还需要通过查看/proc/interrupts文件查看中断调用详情再做判断。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 3</title>
    <url>/2022/03/02/OS/2022-03-02-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%203/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="并发、同步、异步、互斥、阻塞、非阻塞"><a href="#并发、同步、异步、互斥、阻塞、非阻塞" class="headerlink" title="并发、同步、异步、互斥、阻塞、非阻塞"></a>并发、同步、异步、互斥、阻塞、非阻塞</h2><h3 id="并发、同步、异步、互斥、阻塞、非阻塞的基本概念"><a href="#并发、同步、异步、互斥、阻塞、非阻塞的基本概念" class="headerlink" title="并发、同步、异步、互斥、阻塞、非阻塞的基本概念"></a>并发、同步、异步、互斥、阻塞、非阻塞的基本概念</h3><ul>
<li>并发<ul>
<li>在操作系统中，同个处理机上有多个程序同时运行。</li>
</ul>
</li>
<li>同步、异步<ul>
<li>同步：顺序执行，执行完一个再执行下一个，需要等待、协调运行。</li>
<li>异步：异步和同步是相对的，异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。<ul>
<li>线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需要等待子线程做完而是可以做其他事情。</li>
<li>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是实现异步的一种手段。</li>
</ul>
</li>
<li>同步和异步是对应的，是线程之间的关系。两个线程要么同步要么异步。</li>
</ul>
</li>
<li>阻塞、非阻塞<ul>
<li>当进程在访问数据时，根据IO操作的就绪状态不同而采取不同的处理方式。比如主程序调用一个函数要读取一个文件的内容：<ul>
<li>阻塞方式下主程序会等到函数读取完再继续往下执行。</li>
<li>非阻塞方式下读取函数会立刻返回一个状态值给主程序，主程序不等待文件读取完就继续往下执行。</li>
<li>要注意的是阻塞和非阻塞说明的是IO和CPU之间的关系，即CPU是否等待IO。</li>
</ul>
</li>
</ul>
</li>
<li>一般有以下4类IO模型，考虑发送方发出请求要接收方读取某文件内容为例：<ul>
<li>同步阻塞IO<ul>
<li>发送方发出请求后一直等待(同步)。接收方开始读取文件，如果不能马上得到读取结果就一直等待，直到获取读取结果再响应发送方，等待期间不可做其他操作(阻塞)。</li>
</ul>
</li>
<li>同步非阻塞IO<ul>
<li>发送方发出请求后一直等待(同步)。接收方开始读取文件，如果不能马上得到读取结果就一直等待，就立即返回，接受方继续去做其他事情。此时并未响应发送方，发送方一直等待。直到IO操作(读取文件)完成后，接收方获得读取结果响应发送方，接收方才可以进入下一次请求过程(非阻塞)。</li>
</ul>
</li>
<li>异步阻塞IO(理论存在，实际不用)<ul>
<li>发送方发出请求后，不等待响应，继续其他工作(异步)。接收方读取文件如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。</li>
</ul>
</li>
<li>异步非阻塞IO(效率最高)<ul>
<li>发送方发出请求后，不等待响应，继续其他工作(异步)。接收方读取文件如果不能马上得到结果，也不等待，而是马上返回去做其他事情。当IO操作(读取文件)完成以后，将完成状态和结果通知接收方，接收方再响应发送方。</li>
<li>阻塞和非阻塞是对同一个线程的某个时刻来说的。此时，线程要么阻塞，要么非阻塞。</li>
</ul>
</li>
</ul>
</li>
<li>阻塞是使用同步机制的结果，非阻塞是使用异步机制的结果。</li>
</ul>
<h3 id="线程的同步和互斥"><a href="#线程的同步和互斥" class="headerlink" title="线程的同步和互斥"></a>线程的同步和互斥</h3><ul>
<li>线程互斥<ul>
<li>当有若干个线程同时访问同一块资源时，规定同一时间只有一个线程可以得到访问权，其他线程需要等待占用资源者释放该资源才可以申请访问。</li>
<li>互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
</ul>
</li>
<li>线程同步：<ul>
<li>在互斥的基础上(大多数情况，除非允许同一时间多个访问者访问同一资源)，通过其它机制实现访问者对资源的有序访问，实现每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。</li>
</ul>
</li>
</ul>
<h3 id="线程同步与阻塞的关系"><a href="#线程同步与阻塞的关系" class="headerlink" title="线程同步与阻塞的关系"></a>线程同步与阻塞的关系</h3><ul>
<li>同步是过程，阻塞是状态<ul>
<li>当多个线程访问同一资源时，规定同一时间只有一个线程可进行访问，所以后访问的线程将被阻塞，等待先访问的线程访问完。</li>
</ul>
</li>
<li>线程同步不一定发生阻塞。只有当访问同一资源出现互相等待和互相唤醒才会发生阻塞。而阻塞了一定是同步，多线程用阻塞实现同步。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 4</title>
    <url>/2022/03/03/OS/2022-03-03-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%204/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="孤儿进程、僵尸进程、守护进程的概念"><a href="#孤儿进程、僵尸进程、守护进程的概念" class="headerlink" title="孤儿进程、僵尸进程、守护进程的概念"></a>孤儿进程、僵尸进程、守护进程的概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>孤儿进程<ul>
<li>当父进程退出后，子进程还在运行，那么这些子进程就是孤儿进程。</li>
<li>孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。</li>
</ul>
</li>
<li>僵尸进程<ul>
<li>当子进程推出后，父进程却并未接收到结束子进程的信息(调用waitpid获取子进程的状态信息)，那么子进程仍停留在系统中，即僵尸进程。</li>
</ul>
</li>
<li>守护进程<ul>
<li>在后台运行不受终端控制的进程(输入、输出)。网络服务大部分是守护进程。</li>
</ul>
</li>
</ul>
<h3 id="如何创建守护进程"><a href="#如何创建守护进程" class="headerlink" title="如何创建守护进程"></a>如何创建守护进程</h3><ul>
<li>创建子进程，父进程退出<ul>
<li>因为守护进程是在后台运行不受终端控制的进程。父进程退出后控制台就以为该程序结束了，就可以让子进程在后台进行自己的任务，同时用户仍然可以在控制台输入指令，从而在形式上做到与控制台脱离。</li>
</ul>
</li>
<li>在子进程中创建新的会话(脱离控制终端)<ul>
<li>使用系统函数<code>setsid()</code>创建一个新的会话，并担任该会话组的组长，摆脱原会话的控制，进而摆脱原进程的控制，最后达到摆脱控制台控制的目的。<ul>
<li><code>setsid()</code>函数参数缺省时为关闭根目录，关闭文件描述符。</li>
</ul>
</li>
</ul>
</li>
<li>改变当前目录为根目录<ul>
<li>子进程会继承父进程的目录信息，但进程运行时对当前目录下的文件系统不能卸载，会造成很多隐藏麻烦。</li>
</ul>
</li>
<li>重设文件权限掩码，关闭文件描述符<ul>
<li>子进程还会继承父进程的文件权限掩码，即屏蔽掉文件权限中的对应位。此时子进程需将其重置为0，即在此时要有大的权限，从而提高该守护进程的灵活程度。最后，关闭从父进程继承的已经打开的文件描述符，如不进行关闭，将造成浪费资源以及子进程所有文件系统无法卸载等错误。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 第一次fork的作用在shell终端里造成一个程序已经运行完毕的假象。</span></span><br><span class="line"><span class="comment">     * 同时创建新会话的进程不能是进程组组长，所以父进程是进程组组长是不能创建新会话的，需要子进程中执行。</span></span><br><span class="line"><span class="comment">     * 所以到这里子进程便成为了一个新会话组的组长。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    pid = fork();   <span class="comment">// 成功则父进程获得子进程PID，子进程获得0。</span></span><br><span class="line">    <span class="built_in">If</span>(pid &lt; <span class="number">0</span>)  <span class="comment">//创建子进程失败。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//父进程退出。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//进入子进程。</span></span><br><span class="line">        <span class="built_in">setsid</span>();  <span class="comment">//创建新会话。</span></span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">//重置文件权限掩码。</span></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 第二次fork可以保证不会因为错误操作重新打开终端。</span></span><br><span class="line"><span class="comment">         * 因为只有会话组组长可以打开一个终端，再第二次fork后的子进程就不是会话组组长，就不会无意中打开终端了。</span></span><br><span class="line"><span class="comment">         * 但此部分非必须。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);  <span class="comment">//设置当前目录为根目录。</span></span><br><span class="line">        <span class="type">int</span> maxfd = <span class="built_in">getdtablesize</span>();    <span class="comment">// 获得打开的文件描述符。</span></span><br><span class="line">        <span class="keyword">while</span>(maxfd--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(maxfd);  <span class="comment">//关闭文件描述符。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_INFO,<span class="string">&quot;im deamon\n&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确处理孤儿进程、僵尸进程的方法"><a href="#正确处理孤儿进程、僵尸进程的方法" class="headerlink" title="正确处理孤儿进程、僵尸进程的方法"></a>正确处理孤儿进程、僵尸进程的方法</h3><ul>
<li>孤儿进程的处理<ul>
<li>孤儿进程也就是没有父进程的进程，它由进程号为1的init进程负责处理。当有孤儿进程需要处理的时候，系统就把孤儿进程的父进程设置为init，而init进程会循环地运行<code>wait()</code>来获取它子进程的状态。</li>
</ul>
</li>
<li>僵尸进程的处理<ul>
<li>如果父进程一直调用<code>wait()/waitpid()</code>函数接收子进程，那么子进程就一直保存在系统里，占用系统资源。</li>
<li>如果僵尸进程太多，就会导致系统空间饱满，无法创建新的进程，严重影响系统工作。</li>
<li>系统规定，子进程退出后，父进程会自动收到<code>SIGCHLD</code>信号，在父进程里重置<code>signal</code>函数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler函数里不能使用wait（）函数，</span></span><br><span class="line"><span class="comment">     * 比如同一时间有5个子进程都要结束了，均向父进程发送SIGCHLD信号，但父进程此时就在处理其中一个，在处理结束前，收到的其他SIGCHLD信号会忽略，导致漏掉部分子进程没有处理结束。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is die\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, handler);   <span class="comment">// 设置函数handler来处理SIGCHLD信号。</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">//父进程循环等待。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;   <span class="comment">//子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD。</span></span><br><span class="line">                          <span class="comment">//信号调用handler函数接收结束子进程，打印child is die。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child, i die\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="waitpid-和wait-函数"><a href="#waitpid-和wait-函数" class="headerlink" title="waitpid()和wait()函数"></a>waitpid()和wait()函数</h3><ul>
<li><code>pid_t waitpid(pid_t pid,int *status,int options)</code>函数<ul>
<li>参数<ul>
<li><code>pid</code><ul>
<li>从参数的名字pid和类型pid_t中就可以看出，需要的是一个<strong>进程ID</strong>。但当pid取不同的值时，在这里有不同的意义。</li>
<li><strong>pid&gt;0</strong>时，指<strong>等待进程ID等于pid的子进程</strong>，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束,waitpid就会一直等下去。</li>
<li><strong>pid=-1</strong>时，<strong>等待任何一个子进程退出</strong>，没有任何限制，此时waitpid和wait的作用一模一样。 　　</li>
<li><strong>pid=0</strong>时，<strong>等待同一个进程组中的任何子进程</strong>，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li><strong>pid&lt;-1</strong>时，<strong>等待一个指定进程组中的任何子进程</strong>，这个<strong>进程组的ID等于pid的绝对值</strong>。 　　</li>
</ul>
</li>
<li><code>status</code><ul>
<li>用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉(绝大多数情况)，就可以<strong>设定这个参数为NULL</strong>。</li>
</ul>
</li>
<li><code>options</code><ul>
<li>提供了一些额外的选项来控制waitpid，目前在Linux中只支持<code>WNOHANG</code>和<code>WUNTRACED</code>两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用，不想使用则设置为0。<ul>
<li>如果使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去，即不需要阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>当正常返回的时候，waitpid返回收集到的<strong>子进程的进程ID</strong>；</li>
<li>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则<strong>返回0</strong>； 　　 　　</li>
<li>如果调用中出错，则<strong>返回-1</strong>，这时errno会被设置成相应的值以指示错误所在；当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD </li>
</ul>
</li>
</ul>
</li>
<li><code>pid_t wait(int *status)</code>函数<ul>
<li>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，<ul>
<li>如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；</li>
<li>如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</li>
</ul>
</li>
<li>参数<ul>
<li><code>status</code><ul>
<li>用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉(绝大多数情况)，就可以<strong>设定这个参数为NULL</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>如果成功，wait会返回被收集的<strong>子进程的进程ID</strong>。</li>
<li>如果调用进程没有子进程，调用就会失败，此时<strong>wait返回-1</strong>，同时<strong>errno被置为ECHILD</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>waitpid提供了wait函数不能实现的3个功能:<ol>
<li>waitpid等待<strong>特定</strong>的子进程, 而wait则返回<strong>任一</strong>终止状态的子进程;</li>
<li>waitpid提供了一个wait的<strong>非阻塞版本</strong>; </li>
<li>waitpid支持<strong>作业控制</strong>(以WUNTRACED选项). 用于检查wait和waitpid两个函数返回终止状态的宏: 这两个函数返回的子进程状态都保存在status指针中, 用以下3个宏可以检查该状态:<ul>
<li>WIFEXITED(status): 若为正常终止, 则为真，此时可执行WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位。</li>
<li>WIFSIGNALED(status): 若为异常终止, 则为真，此时可执行 WTERMSIG(status): 取使子进程终止的信号编号。</li>
<li>WIFSTOPPED(status): 若为当前暂停子进程, 则为真，此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号。</li>
</ul>
</li>
</ol>
</li>
<li>如果在父进程用wait()和waitpid()会使父进程挂起，解决的办法：<ul>
<li>可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</li>
<li>如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCLD, SIG_IGN)</code>或<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号。</li>
<li>fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做，子进程回收后父进程才挂起。 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核的I2C子系统详解</title>
    <url>/2022/08/09/RK3568%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/2022-08-09-Linux%E5%86%85%E6%A0%B8%E7%9A%84I2C%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>为了提高代码的重用性，解决驱动代码和设备信息耦合的问题，Linux提出了总线、设备、驱动模型。</p>
<p>总线上管理着两个链表，分别对应设备和驱动。每当要向系统注册一个驱动或设备时，总线负责对新插入的驱动或设备进行匹配，根据匹配结果将新插入的驱动或设备添加到所对应的管理链表中。每当要从系统移除一个驱动或设备时，总线负责将其从所对应的管理链表中删除。</p>
<p>由于并不是所有的设备都能够归属于常见的总线(USB、PCI、I2C、SPI)，Linux为了保持设备驱动的统一性，提出了一条虚拟的、抽象出来的总线 <code>platform</code> 。下图展示了Platform平台设备驱动框架的总线、设备、驱动模型。</p>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/platform%E6%80%BB%E7%BA%BF%E3%80%81%E9%A9%B1%E5%8A%A8%E3%80%81%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B.png?raw=true" alt="platform总线、驱动、设备模型"></p>
<h1 id="2-Linux内核里I2C驱动的体系结构"><a href="#2-Linux内核里I2C驱动的体系结构" class="headerlink" title="2. Linux内核里I2C驱动的体系结构"></a>2. Linux内核里I2C驱动的体系结构</h1><h2 id="2-1-组成部分"><a href="#2-1-组成部分" class="headerlink" title="2.1. 组成部分"></a>2.1. 组成部分</h2><p>《Linux设备驱动开发详解》一书第15章《Linux I2C核心、总线与设备驱动》将Linux的I2C体系结构分为核心、总线驱动和设备驱动三部分。</p>
<h3 id="2-1-1-I2C核心"><a href="#2-1-1-I2C核心" class="headerlink" title="2.1.1. I2C核心"></a>2.1.1. I2C核心</h3><p>I2C核心提供了I2C总线驱动和I2C设备驱动注册和注销的方法，I2C通信方法中上层与具体适配器无关的代码，以及探测设备、检测设备地址的上层代码。</p>
<h3 id="2-1-2-I2C总线驱动"><a href="#2-1-2-I2C总线驱动" class="headerlink" title="2.1.2. I2C总线驱动"></a>2.1.2. I2C总线驱动</h3><p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现。主要包含I2C适配器的数据结构 <code>i2c_adapter</code> 、I2C适配器的通信方法(与设备之间)数据结构 <code>i2c_algorithm</code> 和控制I2C适配器产生通信信号的函数。</p>
<h3 id="2-1-3-I2C设备驱动"><a href="#2-1-3-I2C设备驱动" class="headerlink" title="2.1.3. I2C设备驱动"></a>2.1.3. I2C设备驱动</h3><p>I2C设备驱动(客户驱动)是对I2C硬件体系结构中设备端的实现。一般挂载在I2C适配器上。主要包含数据结构 <code>i2c_driver</code> 和 <code>i2c_client</code> 。</p>
<h2 id="2-2-体系结构"><a href="#2-2-体系结构" class="headerlink" title="2.2. 体系结构"></a>2.2. 体系结构</h2><p>下图展示了Linux内核里I2C驱动的体系结构。CPU的每个I2C接口都配有一个I2C总线控制器(硬件)，负责控制所对应的一条I2C总线。I2C控制器可通过挂载在其他总线上被CPU控制，也可以直接集成在CPU内部。 <code>i2c_adapter</code> 是在软件上抽象出来的I2C总线控制器(适配器)，与硬件一一对应。</p>
<p>每个I2C设备( <code>i2c_device</code> )在软件上抽象成 <code>i2c_client</code> ，挂载到 <code>i2c_adapter</code> 控制的I2C总线上后与设备驱动( <code>i2c_driver</code> )匹配使用， <code>i2c_adapter</code> 则通过根据控制逻辑实现的 <code>i2c_algorithm</code> 与 <code>i2c_client</code> 进行通信。</p>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/Linux%E5%86%85%E6%A0%B8%E9%87%8CI2C%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png?raw=true" alt="Linux内核里I2C驱动的体系结构"></p>
<h1 id="3-RK3568-Linux的I2C驱动"><a href="#3-RK3568-Linux的I2C驱动" class="headerlink" title="3. RK3568 Linux的I2C驱动"></a>3. RK3568 Linux的I2C驱动</h1><h2 id="3-1-Rockchip-I2C总线的硬件连接方式"><a href="#3-1-Rockchip-I2C总线的硬件连接方式" class="headerlink" title="3.1. Rockchip I2C总线的硬件连接方式"></a>3.1. Rockchip I2C总线的硬件连接方式</h2><p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/Rockchip_I2C%E6%80%BB%E7%BA%BF%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png?raw=true" alt="Rockchip I2C总线的硬件连接方式"></p>
<h2 id="3-2-RK平台I2C驱动框架"><a href="#3-2-RK平台I2C驱动框架" class="headerlink" title="3.2. RK平台I2C驱动框架"></a>3.2. RK平台I2C驱动框架</h2><p>RK平台的I2C总线控制器并非直接集成在内部，而是挂载到platform总线上，所以可以将RK3568 Linux的I2C驱动划分为两个部分实现：</p>
<ul>
<li>采用platform驱动框架为I2C适配器设计驱动，以挂载到platform总线。</li>
<li>采用I2C驱动框架为设备设计驱动，以挂载到I2C总线。</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/I2C%E4%B8%BB%E6%9C%BA%E5%92%8C%E5%A4%96%E8%AE%BE%E7%9C%BC%E9%87%8C%E7%9A%84Linux%E4%B8%96%E7%95%8C.png?raw=true" alt="Linux内核里I2C驱动的设计框架"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>I2C</category>
        <category>设备驱动开发</category>
      </categories>
      <tags>
        <tag>Linux设备驱动开发</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>RK3568 Linux的I2C总线驱动分析</title>
    <url>/2022/08/15/RK3568%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/2022-08-15-RK3568%20Linux%E7%9A%84I2C%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-RK3568-I2C总线驱动概述"><a href="#1-RK3568-I2C总线驱动概述" class="headerlink" title="1. RK3568 I2C总线驱动概述"></a>1. RK3568 I2C总线驱动概述</h1><p>Linux的I2C接口围绕两种驱动和两种设备组织。适配器驱动(“Adapter Driver”, 总线驱动)用来抽象硬件上的I2C控制器，它挂载到其他总线上(PIC总线，platform总线)。它负责为系统中每一条I2C总线实现相应的读写方法，但本身并不进行任何通信，只是将通信方法提供给设备驱动使用，使得设备驱动可以忽略不同的I2C总线控制器的差异。</p>
<ul>
<li>文件路径<ul>
<li><code>.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c</code></li>
</ul>
</li>
<li>设备树文件<ul>
<li><code>.../OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi</code></li>
</ul>
</li>
<li>总线驱动：<code>rk3x_i2c_driver</code>：<ul>
<li>probe方法：<code>rk3x_i2c_probe</code></li>
<li>remove方法：<code>rk3x_i2c_remove</code></li>
<li>设备树匹配：<code>rk3x_i2c_match</code></li>
</ul>
</li>
<li>总线控制器：<code>i2c_adapter</code><ul>
<li>注册i2c_adapter：<code>i2c_add_adapter</code></li>
</ul>
</li>
<li>通信方法集合：<code>rk3x_i2c_algorithm</code><ul>
<li>通信方法：<code>rk3x_i2c_xfer</code></li>
<li>功能检测方法：<code>rk3x_i2c_func</code></li>
</ul>
</li>
<li>驱动注册和卸载方法<ul>
<li><code>module_platform_driver</code></li>
</ul>
</li>
</ul>
<p>它们的调用关系如下图：</p>
<h1 id="2-总线驱动定义"><a href="#2-总线驱动定义" class="headerlink" title="2. 总线驱动定义"></a>2. 总线驱动定义</h1><p>因为RK平台的I2C总线控制器挂载在platform总线上，总线驱动采用platform驱动框架实现，所以填充 <code>platform_driver</code> 结构体以定义I2C总线驱动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> rk3x_i2c_driver = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * 当驱动注册完毕，并且匹配成功，则会自动调用该方法对硬件进行操作：</span></span><br><span class="line"><span class="comment">        * a. 注册设备号，并且注册fops(为用户提供设备标示，同时提供文件操作io接口)</span></span><br><span class="line"><span class="comment">        * b. 创建设备结点</span></span><br><span class="line"><span class="comment">        * c. 初始化硬件的各项信息，如ioremap(io地址映射虚拟地址)</span></span><br><span class="line"><span class="comment">        * d. 实现各种io功能接口</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    .probe   = rk3x_i2c_probe,      </span><br><span class="line">    .remove  = rk3x_i2c_remove,</span><br><span class="line">    .driver  = &#123;</span><br><span class="line">        .name  = <span class="string">&quot;rk3x-i2c&quot;</span>,                <span class="comment">// 用于驱动和设备匹配，确保驱动和设备一致，否则无法匹配成功</span></span><br><span class="line">        .of_match_table = rk3x_i2c_match,   <span class="comment">// 匹配表</span></span><br><span class="line">        .pm = &amp;rk3x_i2c_pm_ops,	            <span class="comment">// dev_pm_ops类型的结构体，用来赋值设备完成运行时的电源管理</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-适配器定义"><a href="#3-适配器定义" class="headerlink" title="3. 适配器定义"></a>3. 适配器定义</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_adapter</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="keyword">class</span>;					<span class="comment">/* classes to allow probing for */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> *algo; 	<span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">    <span class="type">void</span> *algo_data;                    <span class="comment">/* i2c_algorithm的私有数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data fields that are valid for all devices, 同步机制	*/</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_lock_operations</span> *lock_ops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rt_mutex</span> bus_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rt_mutex</span> mux_lock;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">    <span class="type">int</span> retries;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device</span> dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_flags;	<span class="comment">/* owned by the I2C core */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_IS_SUSPENDED		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_SUSPEND_REPORTED	1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nr;                <span class="comment">/* 适配器编号，在创建i2c_client的时候会根据编号分类，若置为-1，则代表动态分配 */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">48</span>];          <span class="comment">/* 适配器的名字 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">completion</span> dev_released;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> userspace_clients_lock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> userspace_clients;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">i2c_bus_recovery_info</span> *bus_recovery_info;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_adapter_quirks</span> *quirks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">irq_domain</span> *host_notify_domain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-algorithm通信方法定义"><a href="#4-algorithm通信方法定义" class="headerlink" title="4. algorithm通信方法定义"></a>4. algorithm通信方法定义</h1><p>因为每家芯片厂商SoC内部的I2C控制器是不一样的，所以 <code>i2c_algorithm</code> 中直接涉及硬件层面上的代码都是由芯片商提供。例如：对I2C控制器的寄存器操作。 <code>i2c_algorithm</code> 提供的通信函数控制适配器产生特定的访问信号，虽然不同的I2C总线控制器被抽象成不同的 <code>i2c_adapter</code> ，但是如果操作方式相同，则可以共享同一个 <code>i2c_algorithm</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">i2c_algorithm</span> rk3x_i2c_algorithm = &#123;</span><br><span class="line"></span><br><span class="line">    .master_xfer		= rk3x_i2c_xfer,             <span class="comment">// 通信方法，如果不支持I2C访问，则为NULL</span></span><br><span class="line">    .master_xfer_atomic	= rk3x_i2c_xfer_polling,     <span class="comment">// 通信方法，仅使用于原子上下文</span></span><br><span class="line">    .functionality		= rk3x_i2c_func,             <span class="comment">// 检测通信方法支持的功能或协议，设备驱动一般会调用这个回调来确认适配器支持的协议类型</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// i2c_algorithm中通信函数的基本单位</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_msg</span> &#123;</span><br><span class="line"></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address, 从机地址(片选？)	*/</span></span><br><span class="line">	__u16 flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_DMA_SAFE		0x0200	<span class="comment">/* the buffer of this message is DMA safe */</span></span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/* makes only sense in kernelspace */</span></span><br><span class="line">					<span class="comment">/* userspace buffers are copied anyway */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="5-设备树的匹配方法"><a href="#5-设备树的匹配方法" class="headerlink" title="5. 设备树的匹配方法"></a>5. 设备树的匹配方法</h1><p>RK3568共有6个I2C控制器，分别为I2C0~I2C5，每个控制器对应不同的寄存器基地址(i2c0是0xfdd40000)， <code>.compatible</code> 属性都是 <code>rockchip, rk3399-i2c</code> ，即对应了同一个adapter驱动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">i2c0: i2c@fdd40000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfdd40000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;  <span class="comment">// 起始地址0xfdd40000, 长度0x10000</span></span><br><span class="line">    clocks = &lt;&amp;pmucru CLK_I2C0&gt;, &lt;&amp;pmucru PCLK_I2C0&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">46</span> IRQ_TYPE_LEVEL_HIGH&gt;;  <span class="comment">// 中断和触发方式</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c0_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;   <span class="comment">//表示用一个32位的数来描述地址</span></span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;  <span class="comment">//表示用0个32位的数来描述该地址的大小</span></span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i2c1: i2c@fe5a0000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5a0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_I2C1&gt;, &lt;&amp;cru PCLK_I2C1&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">47</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c1_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i2c2: i2c@fe5b0000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5b0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_I2C2&gt;, &lt;&amp;cru PCLK_I2C2&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">48</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c2m0_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i2c3: i2c@fe5c0000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5c0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_I2C3&gt;, &lt;&amp;cru PCLK_I2C3&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">49</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c3m0_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i2c4: i2c@fe5d0000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5d0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_I2C4&gt;, &lt;&amp;cru PCLK_I2C4&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">50</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c4m0_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i2c5: i2c@fe5e0000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x0</span> <span class="number">0xfe5e0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    clocks = &lt;&amp;cru CLK_I2C5&gt;, &lt;&amp;cru PCLK_I2C5&gt;;</span><br><span class="line">    clock-names = <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span>;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">51</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;i2c5m0_xfer&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 <code>rk3x_i2c_driver</code> 作为一个 <code>platform_driver</code> 注册到内核， <code>rk3x_i2c_match</code> 作为结构体中的参数实际是一个记录设备信息的结构体数组。系统启动后会比较DTS中的匹配属性与驱动匹配表中是否相符，如果相符则会进入 <code>rk3x_i2c_probe</code> 接口，完成驱动各项参数的初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rk3x_i2c_driver结构体中.driver的匹配表参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> rk3x_i2c_match[] = &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1108-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1108_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rv1126-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rv1126_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3066-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3066_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3188-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3188_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3228-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3228_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3288-i2c&quot;</span>,</span><br><span class="line">        .data = &amp;rk3288_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = <span class="string">&quot;rockchip,rk3399-i2c&quot;</span>, <span class="comment">// 符合DTS中描述的匹配字符串</span></span><br><span class="line">        .data = &amp;rk3399_soc_data</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param usb               设备名</span></span><br><span class="line"><span class="comment"> * @param skel_table        该设备加入到模块中时对应产生的设备搜索符号</span></span><br><span class="line"><span class="comment"> * @return 生成一个名为__mod_pci_device_table局部变量，这个变量指向第二个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">MODULE_DEVICE_TABLE</span>(of, rk3x_i2c_match); <span class="comment">// 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="6-总线驱动注册和卸载方法"><a href="#6-总线驱动注册和卸载方法" class="headerlink" title="6. 总线驱动注册和卸载方法"></a>6. 总线驱动注册和卸载方法</h1><p>为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 <code>module_platform_driver</code> 替换 <code>module_init</code> 和 <code>module_exit</code> (实际还要调用一次宏定义函数 <code>module_driver</code> 才能完成替换)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_platform_driver() - Helper macro for drivers that don&#x27;t do</span></span><br><span class="line"><span class="comment"> * anything special in module init/exit.  </span></span><br><span class="line"><span class="comment"> * This eliminates a lot of boilerplate.  </span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and</span></span><br><span class="line"><span class="comment"> * calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_platform_driver(__platform_driver) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="built_in">module_driver</span>(__platform_driver, platform_driver_register, \</span><br><span class="line">            platform_driver_unregister)</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in module init/exit. This eliminates a lot of boilerplate.</span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * module_init() and module_exit().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @__unregister: unregister function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register and __unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta"><span class="comment">// 注册方法，替代module_init</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init __driver##_init(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_init</span>(__driver##_init); \</span><br><span class="line"><span class="comment">// 卸载方法，替代module_exit</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __driver##_exit(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_exit</span>(__driver##_exit); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="7-总线驱动函数"><a href="#7-总线驱动函数" class="headerlink" title="7. 总线驱动函数"></a>7. 总线驱动函数</h1><h2 id="7-1-初始化函数probe"><a href="#7-1-初始化函数probe" class="headerlink" title="7.1. 初始化函数probe()"></a>7.1. 初始化函数probe()</h2><p><code>platform_driver</code> 在注册时会遍历 <code>platform</code> 总线上的 <code>platform_device</code> ，当条件( <code>.compatible</code> 属性或 <code>id_table</code> )匹配(通过得分机制，得分最高的最终会匹配成功)时，便会调用 <code>rk3x_i2c_probe</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> *match;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c;	<span class="comment">// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u32 value;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> clk_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作</span></span><br><span class="line"><span class="comment">     * devm_kzalloc — Resource-managed kzalloc</span></span><br><span class="line"><span class="comment">     * @param pdev: 申请内存的目标设备</span></span><br><span class="line"><span class="comment">     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。</span></span><br><span class="line"><span class="comment">     * @return: 成功返回首地址，失败返回NULL</span></span><br><span class="line"><span class="comment">     * 为适配器结构体申请内存，为后续实例化完成基础工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> rk3x_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (!i2c)	<span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到rk3x_i2c_match数组里与之匹配的那个struct of_device_id</span></span><br><span class="line"><span class="comment">     * i2c_adapter驱动会兼容多个RK平台(如rk3188/rk3288/rk3399等)的i2c控制器，</span></span><br><span class="line"><span class="comment">     * 各个平台有些差异，差异性的信息可以通过.data这个成员指针保存起来，用到的时候再取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = <span class="built_in">of_match_node</span>(rk3x_i2c_match, np);</span><br><span class="line">    <span class="comment">// 取出所匹配的i2c控制器的配置信息</span></span><br><span class="line">    i2c-&gt;soc_data = match-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use common interface to get I2C timing properties */</span></span><br><span class="line">    <span class="built_in">i2c_parse_fw_timings</span>(&amp;pdev-&gt;dev, &amp;i2c-&gt;t, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i2c_adapter部分成员初始化</span></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">strlcpy</span>(i2c-&gt;adap.name, <span class="string">&quot;rk3x-i2c&quot;</span>, <span class="built_in">sizeof</span>(i2c-&gt;adap.name));</span><br><span class="line">    <span class="comment">// 拥有者</span></span><br><span class="line">    i2c-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">// 通信方法</span></span><br><span class="line">    i2c-&gt;adap.algo = &amp;rk3x_i2c_algorithm;</span><br><span class="line">    i2c-&gt;adap.retries = <span class="number">3</span>;</span><br><span class="line">    i2c-&gt;adap.dev.of_node = np;</span><br><span class="line">    i2c-&gt;adap.algo_data = i2c;</span><br><span class="line">    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">    i2c-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;i2c-&gt;lock);</span><br><span class="line">    <span class="comment">// 初始化等待队列头部，等待在进程调度中使用</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;i2c-&gt;wait);</span><br><span class="line">    <span class="comment">// 通知链机制，在内核重启之前会调用回调函数rk3x_i2c_restart_notify</span></span><br><span class="line">    i2c-&gt;i2c_restart_nb.notifier_call = rk3x_i2c_restart_notify;</span><br><span class="line">    i2c-&gt;i2c_restart_nb.priority = <span class="number">128</span>;</span><br><span class="line">    ret = <span class="built_in">register_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#12变量指向第二个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">MODULE_DEVICE_TABLE</span>(of, rk3x_i2c_match); <span class="comment">// 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="6-总线驱动注册和卸载方法"><a href="#6-总线驱动注册和卸载方法" class="headerlink" title="6. 总线驱动注册和卸载方法"></a>6. 总线驱动注册和卸载方法</h1><p>为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 <code>module_platform_driver</code> 替换 <code>module_init</code> 和 <code>module_exit</code> (实际还要调用一次宏定义函数 <code>module_driver</code> 才能完成替换)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_platform_driver() - Helper macro for drivers that don&#x27;t do</span></span><br><span class="line"><span class="comment"> * anything special in module init/exit.  </span></span><br><span class="line"><span class="comment"> * This eliminates a lot of boilerplate.  </span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and</span></span><br><span class="line"><span class="comment"> * calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_platform_driver(__platform_driver) \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="built_in">module_driver</span>(__platform_driver, platform_driver_register, \</span><br><span class="line">            platform_driver_unregister)</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in module init/exit. This eliminates a lot of boilerplate.</span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * module_init() and module_exit().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @__unregister: unregister function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register and __unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta"><span class="comment">// 注册方法，替代module_init</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init __driver##_init(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_init</span>(__driver##_init); \</span><br><span class="line"><span class="comment">// 卸载方法，替代module_exit</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit __driver##_exit(<span class="type">void</span>) \</span><br><span class="line">&#123; \</span><br><span class="line"></span><br><span class="line">    __unregister(&amp;(__driver) , ##__VA_ARGS__); \</span><br><span class="line"></span><br><span class="line">&#125; \</span><br><span class="line"><span class="built_in">module_exit</span>(__driver##_exit); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="7-总线驱动函数"><a href="#7-总线驱动函数" class="headerlink" title="7. 总线驱动函数"></a>7. 总线驱动函数</h1><h2 id="7-1-初始化函数probe"><a href="#7-1-初始化函数probe" class="headerlink" title="7.1. 初始化函数probe()"></a>7.1. 初始化函数probe()</h2><p><code>platform_driver</code> 在注册时会遍历 <code>platform</code> 总线上的 <code>platform_device</code> ，当条件( <code>.compatible</code> 属性或 <code>id_table</code> )匹配(通过得分机制，得分最高的最终会匹配成功)时，便会调用 <code>rk3x_i2c_probe</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device_node</span> *np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> *match;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c;	<span class="comment">// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u32 value;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> clk_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作</span></span><br><span class="line"><span class="comment">     * devm_kzalloc — Resource-managed kzalloc</span></span><br><span class="line"><span class="comment">     * @param pdev: 申请内存的目标设备</span></span><br><span class="line"><span class="comment">     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。</span></span><br><span class="line"><span class="comment">     * @return: 成功返回首地址，失败返回NULL</span></span><br><span class="line"><span class="comment">     * 为适配器结构体申请内存，为后续实例化完成基础工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i2c = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> rk3x_i2c), GFP_KERNEL); </span><br><span class="line">    <span class="keyword">if</span> (!i2c)	<span class="comment">// 申请失败</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到rk3x_i2c_match数组里与之匹配的那个struct of_device_id</span></span><br><span class="line"><span class="comment">     * i2c_adapter驱动会兼容多个RK平台(如rk3188/rk3288/rk3399等)的i2c控制器，</span></span><br><span class="line"><span class="comment">     * 各个平台有些差异，差异性的信息可以通过.data这个成员指针保存起来，用到的时候再取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = <span class="built_in">of_match_node</span>(rk3x_i2c_match, np);</span><br><span class="line">    <span class="comment">// 取出所匹配的i2c控制器的配置信息</span></span><br><span class="line">    i2c-&gt;soc_data = match-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use common interface to get I2C timing properties */</span></span><br><span class="line">    <span class="built_in">i2c_parse_fw_timings</span>(&amp;pdev-&gt;dev, &amp;i2c-&gt;t, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i2c_adapter部分成员初始化</span></span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">strlcpy</span>(i2c-&gt;adap.name, <span class="string">&quot;rk3x-i2c&quot;</span>, <span class="built_in">sizeof</span>(i2c-&gt;adap.name));</span><br><span class="line">    <span class="comment">// 拥有者</span></span><br><span class="line">    i2c-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">// 通信方法</span></span><br><span class="line">    i2c-&gt;adap.algo = &amp;rk3x_i2c_algorithm;</span><br><span class="line">    i2c-&gt;adap.retries = <span class="number">3</span>;</span><br><span class="line">    i2c-&gt;adap.dev.of_node = np;</span><br><span class="line">    i2c-&gt;adap.algo_data = i2c;</span><br><span class="line">    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">    i2c-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;i2c-&gt;lock);</span><br><span class="line">    <span class="comment">// 初始化等待队列头部，等待在进程调度中使用</span></span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;i2c-&gt;wait);</span><br><span class="line">    <span class="comment">// 通知链机制，在内核重启之前会调用回调函数rk3x_i2c_restart_notify</span></span><br><span class="line">    i2c-&gt;i2c_restart_nb.notifier_call = rk3x_i2c_restart_notify;</span><br><span class="line">    i2c-&gt;i2c_restart_nb.priority = <span class="number">128</span>;</span><br><span class="line">    ret = <span class="built_in">register_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;failed to setup i2c restart handler.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从dts中获取设备的物理基址</span></span><br><span class="line">    i2c-&gt;regs = <span class="built_in">devm_platform_ioremap_resource</span>(pdev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;regs))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(i2c-&gt;regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * Switch to new interface if the SoC also offers the old one.</span></span><br><span class="line"><span class="comment">        * The control bit is located in the GRF register space.</span></span><br><span class="line"><span class="comment">        * grf_offset: offset inside the grf regmap for setting the i2c type</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;grf_offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">regmap</span> *grf; </span><br><span class="line"></span><br><span class="line">        grf = <span class="built_in">syscon_regmap_lookup_by_phandle</span>(np, <span class="string">&quot;rockchip,grf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(grf)) &#123;</span><br><span class="line">            <span class="type">int</span> bus_nr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Try to set the I2C adapter number from dt */</span></span><br><span class="line">            bus_nr = <span class="built_in">of_alias_get_id</span>(np, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bus_nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;rk3x-i2c needs i2cX alias&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1108_soc_data &amp;&amp; bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1108 i2c2 set grf offset-0x408, bit-10 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">26</span>) | <span class="built_in">BIT</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i2c-&gt;soc_data == &amp;rv1126_soc_data &amp;&amp;</span><br><span class="line">                    bus_nr == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* rv1126 i2c2 set pmugrf offset-0x118, bit-4 */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">20</span>) | <span class="built_in">BIT</span>(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* rk3xxx 27+i: write mask, 11+i: value */</span></span><br><span class="line">                value = <span class="built_in">BIT</span>(<span class="number">27</span> + bus_nr) | <span class="built_in">BIT</span>(<span class="number">11</span> + bus_nr);</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">regmap_write</span>(grf, i2c-&gt;soc_data-&gt;grf_offset,</span><br><span class="line">                        value);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;Could not write to GRF: %d\n&quot;</span>,</span><br><span class="line">                    ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IRQ setup(中断设置) */</span></span><br><span class="line">    irq = <span class="built_in">platform_get_irq</span>(pdev, <span class="number">0</span>);	<span class="comment">// platform_device结构体中存储有所用到的中断号</span></span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">devm_request_irq</span>(&amp;pdev-&gt;dev, irq, rk3x_i2c_irq,</span><br><span class="line">                    <span class="number">0</span>, <span class="built_in">dev_name</span>(&amp;pdev-&gt;dev), i2c);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;cannot request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储用户主动申请的内存区域指针防止丢失</span></span><br><span class="line">    <span class="built_in">platform_set_drvdata</span>(pdev, i2c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平台时钟设置</span></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;soc_data-&gt;calc_timings == rk3x_i2c_v0_calc_timings) &#123;</span><br><span class="line">        <span class="comment">/* Only one clock to use for bus clock and peripheral clock */</span></span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">        i2c-&gt;pclk = i2c-&gt;clk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i2c-&gt;clk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        i2c-&gt;pclk = <span class="built_in">devm_clk_get</span>(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;clk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;clk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get bus clk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(i2c-&gt;pclk))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dev_err_probe</span>(&amp;pdev-&gt;dev, <span class="built_in">PTR_ERR</span>(i2c-&gt;pclk),</span><br><span class="line">                        <span class="string">&quot;Can&#x27;t get periph clk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare bus clk: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">clk_prepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare periph clock: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> err_clk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i2c-&gt;clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;</span><br><span class="line">    ret = <span class="built_in">clk_notifier_register</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to register clock notifier\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_pclk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clk_rate = <span class="built_in">clk_get_rate</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">rk3x_i2c_adapt_div</span>(i2c, clk_rate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向内核添加i2c_adapter</span></span><br><span class="line">    ret = <span class="built_in">i2c_add_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err_clk_notifier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_clk_notifier:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line"></span><br><span class="line">err_pclk:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">err_clk:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-2-释放函数remove"><a href="#7-2-释放函数remove" class="headerlink" title="7.2. 释放函数remove()"></a>7.2. 释放函数remove()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得rk3x_i2c_probe中存储的主动申请的内存区域指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = <span class="built_in">platform_get_drvdata</span>(pdev);</span><br><span class="line">    <span class="comment">// 卸载i2c_adapter</span></span><br><span class="line">    <span class="built_in">i2c_del_adapter</span>(&amp;i2c-&gt;adap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销时钟</span></span><br><span class="line">    <span class="built_in">clk_notifier_unregister</span>(i2c-&gt;clk, &amp;i2c-&gt;clk_rate_nb);</span><br><span class="line">    <span class="built_in">unregister_pre_restart_handler</span>(&amp;i2c-&gt;i2c_restart_nb); </span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_unprepare</span>(i2c-&gt;clk); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-3-通信方法函数master-xfer"><a href="#7-3-通信方法函数master-xfer" class="headerlink" title="7.3. 通信方法函数master_xfer()"></a>7.3. 通信方法函数master_xfer()</h2><p>实现总线上数据传输，rk3x_i2c提供了两种方式来处理阻塞进程唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列实现阻塞进程唤醒</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_polling</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rk3x_i2c_xfer_common</span>(adap, msgs, num, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num, <span class="type">bool</span> polling)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rk3x_i2c</span> *i2c = (<span class="keyword">struct</span> rk3x_i2c *)adap-&gt;algo_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> timeout, flags;</span><br><span class="line">    u32 val;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i2c-&gt;suspended)</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 使能时钟</span></span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;clk);</span><br><span class="line">    <span class="built_in">clk_enable</span>(i2c-&gt;pclk);</span><br><span class="line"></span><br><span class="line">    i2c-&gt;is_last_msg = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * Process msgs. We can handle more than one message at once (see</span></span><br><span class="line"><span class="comment">        * rk3x_i2c_setup()).</span></span><br><span class="line"><span class="comment">        * i+ret就是指一次循环处理多条msg</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i += ret) &#123;</span><br><span class="line">        ret = <span class="built_in">rk3x_i2c_setup</span>(i2c, msgs + i, num - i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i2c msg处理出错</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;rk3x_i2c_setup() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ret为本轮已处理的msgs数量，i为过去已处理的msgs数量，如果刚好等于msgs总数，则</span></span><br><span class="line">        <span class="keyword">if</span> (i + ret &gt;= num)</span><br><span class="line">            i2c-&gt;is_last_msg = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 启动i2c_adapter</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_start</span>(i2c);	</span><br><span class="line">        <span class="comment">// 释放自旋锁，并恢复标志寄存器的值为变量flags保存的值</span></span><br><span class="line">        <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区分调用的是rk3x_i2c_xfer还是rk3x_i2c_xfer_polling</span></span><br><span class="line">        <span class="keyword">if</span> (!polling) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                * 调用rk3x_i2c_xfer, 挂起等待队列头i2c-&gt;wait(wait_queue_head_t)。</span></span><br><span class="line"><span class="comment">                * 直到i2c_adapter不再繁忙或者等待超时，则调用wake_up(i2c-&gt;wait)会唤醒进程并继续往下执行</span></span><br><span class="line"><span class="comment">                * 如果未超时且i2c_adapter繁忙，则进程会被阻塞</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">            timeout = <span class="built_in">wait_event_timeout</span>(i2c-&gt;wait, !i2c-&gt;busy,</span><br><span class="line">                                <span class="built_in">msecs_to_jiffies</span>(WAIT_TIMEOUT));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">rk3x_i2c_wait_xfer_poll</span>(i2c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得自旋锁，并且备份本地中断和中断状态到flags变量</span></span><br><span class="line">        <span class="built_in">spin_lock_irqsave</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时了</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dev_err</span>(i2c-&gt;dev, <span class="string">&quot;timeout, ipd: 0x%02x, state: %d\n&quot;</span>,</span><br><span class="line">                <span class="built_in">i2c_readl</span>(i2c, REG_IPD), i2c-&gt;state);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Force a STOP condition without interrupt */</span></span><br><span class="line">            <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">            val = <span class="built_in">i2c_readl</span>(i2c, REG_CON) &amp; REG_CON_TUNING_MASK;</span><br><span class="line">            val |= REG_CON_EN | REG_CON_STOP;</span><br><span class="line">            <span class="built_in">i2c_writel</span>(i2c, val, REG_CON);</span><br><span class="line"></span><br><span class="line">            i2c-&gt;state = STATE_IDLE;</span><br><span class="line"></span><br><span class="line">            ret = -ETIMEDOUT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未超时，但是i2c_adapter运行中产生错误</span></span><br><span class="line">        <span class="keyword">if</span> (i2c-&gt;error) &#123;</span><br><span class="line">            ret = i2c-&gt;error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺利完成i2c通信？</span></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable_irq</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭i2c总线</span></span><br><span class="line">    <span class="built_in">rk3x_i2c_disable</span>(i2c);</span><br><span class="line">    <span class="comment">// 关闭时钟</span></span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;pclk);</span><br><span class="line">    <span class="built_in">clk_disable</span>(i2c-&gt;clk);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_unlock_irqrestore</span>(&amp;i2c-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出错返回ret，成功返回处理msgs的数量</span></span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用poll机制而非等待队列</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">rk3x_i2c_wait_xfer_poll</span><span class="params">(<span class="keyword">struct</span> rk3x_i2c *i2c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ktime_get()得到当前时间，ktime_add_ms来设置超时时间。</span></span><br><span class="line">    <span class="type">ktime_t</span> timeout = <span class="built_in">ktime_add_ms</span>(<span class="built_in">ktime_get</span>(), WAIT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * READ_ONCE是一个用来读取变量的宏，为了避免编译器优化导致多线程时读取出错而编写</span></span><br><span class="line"><span class="comment">        * ktime_compare用来确定是否超时</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">READ_ONCE</span>(i2c-&gt;busy) &amp;&amp;</span><br><span class="line">            <span class="built_in">ktime_compare</span>(<span class="built_in">ktime_get</span>(), timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没超时且i2c_adapter繁忙，则延时等待</span></span><br><span class="line">        <span class="built_in">udelay</span>(<span class="number">5</span>); </span><br><span class="line">        <span class="comment">// 设置中断</span></span><br><span class="line">        <span class="built_in">rk3x_i2c_irq</span>(<span class="number">0</span>, i2c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回i2c_adapter的状态</span></span><br><span class="line">    <span class="keyword">return</span> !i2c-&gt;busy; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-4-功能检测函数func"><a href="#7-4-功能检测函数func" class="headerlink" title="7.4. 功能检测函数func()"></a>7.4. 功能检测函数func()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无格式i2c-level命令(Pure SMBus适配器不能用这些命令)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="comment">// 处理所有的能够被I2C adapter仿真的SMBus命令(RK平台的控制器兼容I2C与SMBus总线)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE | \</span><br><span class="line">                                I2C_FUNC_SMBUS_BYTE_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WORD_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PROC_CALL | \</span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \</span><br><span class="line">                                I2C_FUNC_SMBUS_I2C_BLOCK | \</span><br><span class="line">                                I2C_FUNC_SMBUS_PEC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟知的有I2C_M_IGNORE_NAK, I2C_M_REV_DIR_ADDR, I2C_M_NOSTART, I2C_MNO_RD_ACK等flags(I2C寄存器状态？)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 <span class="comment">/* I2C_M_IGNORE_NAK etc. */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_quick命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="comment">//  处理SMBus read_byte &amp; write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">                                I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data &amp; write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data &amp; write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理SMBus process_call命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="comment">// 处理SMBus wrtie_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data &amp; write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">					                I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_byte_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="comment">// 处理SMBus write_word_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="comment">// 处理SMBus read_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 <span class="comment">/* I2C-like block xfer  */</span></span></span><br><span class="line"><span class="comment">// 处理SMBus write_i2c_block_data命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 <span class="comment">/* w/ 1-byte reg. addr. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出所支持的命令集(检测通信方法支持的功能或协议)</span></span><br><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">rk3x_i2c_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-5-i2c-adapter添加函数i2c-add-adapter"><a href="#7-5-i2c-adapter添加函数i2c-add-adapter" class="headerlink" title="7.5. i2c_adapter添加函数i2c_add_adapter()"></a>7.5. i2c_adapter添加函数i2c_add_adapter()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_add_adapter - declare i2c adapter, use dynamic bus number</span></span><br><span class="line"><span class="comment"> * @adapter: the adapter to add</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine is used to declare an I2C adapter when its bus number</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t matter or when its bus number is specified by an dt alias.</span></span><br><span class="line"><span class="comment"> * Examples of bases when the bus number doesn&#x27;t matter: I2C adapters</span></span><br><span class="line"><span class="comment"> * dynamically added by USB links or PCI plugin cards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When this returns zero, a new bus number was allocated and stored</span></span><br><span class="line"><span class="comment"> * in adap-&gt;nr, and the specified adapter became available for clients.</span></span><br><span class="line"><span class="comment"> * Otherwise, a negative errno value is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device</span> *dev = &amp;adapter-&gt;dev;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在设备树结点(在rk3x_i2c_probe中赋值)</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">        <span class="comment">// 获得总线号，因为总线驱动可以兼容多个同一平台的I2C控制器。一般会在dts里指定，即静态分配ID号</span></span><br><span class="line">		id = <span class="built_in">of_alias_get_id</span>(dev-&gt;of_node, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果找到I2C总线号则直接注册</span></span><br><span class="line">		<span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			<span class="keyword">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 为i2c_adapter动态分配ID并绑定</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adapter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(i2c_add_adapter); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-5-1-总线号获取函数of-alias-get-id"><a href="#7-5-1-总线号获取函数of-alias-get-id" class="headerlink" title="7.5.1. 总线号获取函数of_alias_get_id()"></a>7.5.1. 总线号获取函数of_alias_get_id()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_alias_get_id - Get alias id for the given device_node</span></span><br><span class="line"><span class="comment"> * @np:		Pointer to the given device_node</span></span><br><span class="line"><span class="comment"> * @stem:	Alias stem of the given device_node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function travels the lookup table to get the alias id for the given</span></span><br><span class="line"><span class="comment"> * device_node and alias stem.  It returns the alias id if found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_alias_get_id</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *stem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">alias_prop</span> *app;</span><br><span class="line">	<span class="type">int</span> id = -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;of_mutex);</span><br><span class="line">    <span class="comment">// 遍历链表aliases_lookup(成员为alias_prop)，逐一对比字符串stem。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">list_for_each_entry</span>(app, &amp;aliases_lookup, link) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉dtsi中aliases结点内的非I2C结点</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(app-&gt;stem, stem) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果字符串匹配且找到对应的设备树结点，则说明找到了adapter(I2C控制器)设备结点的ID号</span></span><br><span class="line">		<span class="keyword">if</span> (np == app-&gt;np) &#123;</span><br><span class="line">			id = app-&gt;id;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;of_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(of_alias_get_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-5-2-已指定ID号i2c-adapter注册函数-i2c-add-numbered-adapter"><a href="#7-5-2-已指定ID号i2c-adapter注册函数-i2c-add-numbered-adapter" class="headerlink" title="7.5.2. 已指定ID号i2c_adapter注册函数__i2c_add_numbered_adapter()"></a>7.5.2. 已指定ID号i2c_adapter注册函数__i2c_add_numbered_adapter()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1</span></span><br><span class="line"><span class="comment"> * @adap: the adapter to register (with adap-&gt;nr initialized)</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See i2c_add_numbered_adapter() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __i2c_add_numbered_adapter(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 使id号和adapter结构体按照IDR机制关联起来(IDR用类基树结构构造稀疏数组，以ID为索引来找到对应数组元素，进而找到对应的数据结构指针)</span></span><br><span class="line">	id = <span class="built_in">idr_alloc</span>(&amp;i2c_adapter_idr, adap, adap-&gt;nr, adap-&gt;nr + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">    <span class="comment">// 注册i2c_adapter</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">i2c_register_adapter</span>(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-3-i2c-adapter注册函数i2c-register-adapter"><a href="#7-5-3-i2c-adapter注册函数i2c-register-adapter" class="headerlink" title="7.5.3. i2c_adapter注册函数i2c_register_adapter()"></a>7.5.3. i2c_adapter注册函数i2c_register_adapter()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can&#x27;t register until after driver model init 得先注册I2C总线才能注册adapter */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN_ON</span>(!is_registered)) &#123;</span><br><span class="line">		res = -EAGAIN;</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity checks 如果adapter没有name和algo算法，则直接返回，无法注册 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WARN</span>(!adap-&gt;name[<span class="number">0</span>], <span class="string">&quot;i2c adapter has no name&quot;</span>))</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;algo) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;</span>, adap-&gt;name);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;lock_ops)</span><br><span class="line">		adap-&gt;lock_ops = &amp;i2c_adapter_lock_ops;</span><br><span class="line"></span><br><span class="line">	adap-&gt;locked_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;bus_lock);</span><br><span class="line">	<span class="built_in">rt_mutex_init</span>(&amp;adap-&gt;mux_lock);</span><br><span class="line">	<span class="built_in">mutex_init</span>(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">		adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register soft irqs for Host Notify */</span></span><br><span class="line">	res = <span class="built_in">i2c_setup_host_notify_irq_domain</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t create Host Notify IRQs (%d)\n&quot;</span>,</span><br><span class="line">		       adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_set_name</span>(&amp;adap-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line">	adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 本来这里进去会有调用总线probe的机会，但是由于i2c bus</span></span><br><span class="line"><span class="comment">	 * 没有指定match回调，所以会在中途返回，而且返回的是0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	res = <span class="built_in">device_register</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res) &#123;</span><br><span class="line">		<span class="built_in">pr_err</span>(<span class="string">&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;</span>, adap-&gt;name, res);</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">of_i2c_setup_smbus_alert</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pm_runtime_no_callbacks</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">pm_suspend_ignore_children</span>(&amp;adap-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">pm_runtime_enable</span>(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">i2c_init_recovery</span>(adap);</span><br><span class="line">	<span class="keyword">if</span> (res == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> out_reg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;adapter [%s] registered\n&quot;</span>, adap-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	res = <span class="built_in">class_compat_create_link</span>(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="built_in">dev_warn</span>(&amp;adap-&gt;dev,</span><br><span class="line">			 <span class="string">&quot;Failed to create compatibility class link\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">    <span class="comment">// 构建从设备的软件抽象i2c_client，并与adapter建立联系</span></span><br><span class="line">	<span class="built_in">of_i2c_register_devices</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_install_space_handler</span>(adap);</span><br><span class="line">	<span class="built_in">i2c_acpi_register_devices</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		<span class="built_in">i2c_scan_static_board_info</span>(adap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify drivers */</span></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">bus_for_each_drv</span>(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_reg:</span><br><span class="line">	<span class="built_in">init_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">	<span class="built_in">device_unregister</span>(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="built_in">wait_for_completion</span>(&amp;adap-&gt;dev_released);</span><br><span class="line">out_list:</span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;core_lock);</span><br><span class="line">	<span class="built_in">idr_remove</span>(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-5-4-解析从设备，构建i2c-client函数of-i2c-register-devices"><a href="#7-5-4-解析从设备，构建i2c-client函数of-i2c-register-devices" class="headerlink" title="7.5.4. 解析从设备，构建i2c_client函数of_i2c_register_devices()"></a>7.5.4. 解析从设备，构建i2c_client函数of_i2c_register_devices()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">of_i2c_register_devices</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *bus, *node;</span><br><span class="line">    <span class="comment">// 构建i2c_client</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only register child devices if the adapter has a node pointer set 设备树结点不为空 */</span></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;dev.of_node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: walking child nodes\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找设备树结点中名称有直接描述I2C总线的结点，为了缩小查找范围</span></span><br><span class="line">	bus = <span class="built_in">of_get_child_by_name</span>(adap-&gt;dev.of_node, <span class="string">&quot;i2c-bus&quot;</span>);</span><br><span class="line">    <span class="comment">// 没找到则从头开始遍历</span></span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		bus = <span class="built_in">of_node_get</span>(adap-&gt;dev.of_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个子结点，调用of_i2c_register_device解析设备树结点内容</span></span><br><span class="line">	for_each_available_child_of_node(bus, node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_test_and_set_flag</span>(node, OF_POPULATED))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		client = <span class="built_in">of_i2c_register_device</span>(adap, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client)) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;Failed to create I2C device for %pOF\n&quot;</span>,</span><br><span class="line">				 node);</span><br><span class="line">			<span class="built_in">of_node_clear_flag</span>(node, OF_POPULATED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">of_node_put</span>(bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	of_get_child_by_name - Find the child node by name for a given parent</span></span><br><span class="line"><span class="comment"> *	@node:	parent node</span></span><br><span class="line"><span class="comment"> *	@name:	child name to look for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      This function looks for child node for given matching name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns a node pointer if found, with refcount incremented, use</span></span><br><span class="line"><span class="comment"> *	of_node_put() on it when done.</span></span><br><span class="line"><span class="comment"> *	Returns NULL if node is not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">device_node</span> *<span class="built_in">of_get_child_by_name</span>(<span class="type">const</span> <span class="keyword">struct</span> device_node *node,</span><br><span class="line">				<span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">device_node</span> *child;</span><br><span class="line"></span><br><span class="line">	for_each_child_of_node(node, child)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">of_node_name_eq</span>(child, name))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(of_get_child_by_name);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">i2c_client</span> *<span class="built_in">of_i2c_register_device</span>(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">						 <span class="keyword">struct</span> device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span> *client;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_board_info</span> info;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: register %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_i2c_get_board_info</span>(&amp;adap-&gt;dev, node, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(ret);</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">i2c_new_client_device</span>(adap, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(client))</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;of_i2c: Failure registering %pOF\n&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">of_i2c_get_board_info</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_node *node,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="keyword">struct</span> i2c_board_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 addr;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="built_in">sizeof</span>(*info));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_modalias_node</span>(node, info-&gt;type, <span class="built_in">sizeof</span>(info-&gt;type)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: modalias failure on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">of_property_read_u32</span>(node, <span class="string">&quot;reg&quot;</span>, &amp;addr);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(dev, <span class="string">&quot;of_i2c: invalid reg on %pOF\n&quot;</span>, node);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_TEN_BIT_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_TEN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) &#123;</span><br><span class="line">		addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_SLAVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info-&gt;addr = addr;</span><br><span class="line">	info-&gt;of_node = node;</span><br><span class="line">	info-&gt;fwnode = <span class="built_in">of_fwnode_handle</span>(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_property_read_bool</span>(node, <span class="string">&quot;host-notify&quot;</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_HOST_NOTIFY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">of_get_property</span>(node, <span class="string">&quot;wakeup-source&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">		info-&gt;flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(of_i2c_get_board_info);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device - instantiate an i2c device</span></span><br><span class="line"><span class="comment"> * @adap: the adapter managing the device</span></span><br><span class="line"><span class="comment"> * @info: describes one I2C device; bus_num is ignored</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create an i2c device. Binding is handled through driver model</span></span><br><span class="line"><span class="comment"> * probe()/remove() methods.  A driver may be bound to this device when we</span></span><br><span class="line"><span class="comment"> * return from this function, or any later moment (e.g. maybe hotplugging will</span></span><br><span class="line"><span class="comment"> * load the driver module).  This call is not appropriate for use by mainboard</span></span><br><span class="line"><span class="comment"> * initialization logic, which usually runs during an arch_initcall() long</span></span><br><span class="line"><span class="comment"> * before any i2c_adapter could exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This returns the new i2c client, which may be saved for later use with</span></span><br><span class="line"><span class="comment"> * i2c_unregister_device(); or an ERR_PTR to describe the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">i2c_client</span> *</span><br><span class="line"><span class="built_in">i2c_new_client_device</span>(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">i2c_client</span>	*client;</span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line"></span><br><span class="line">	client = <span class="built_in">kzalloc</span>(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line">	client-&gt;flags = info-&gt;flags;</span><br><span class="line">	client-&gt;addr = info-&gt;addr;</span><br><span class="line"></span><br><span class="line">	client-&gt;init_irq = info-&gt;irq;</span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;init_irq)</span><br><span class="line">		client-&gt;init_irq = <span class="built_in">i2c_dev_irq_from_resources</span>(info-&gt;resources,</span><br><span class="line">							 info-&gt;num_resources);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strlcpy</span>(client-&gt;name, info-&gt;type, <span class="built_in">sizeof</span>(client-&gt;name));</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_validity</span>(client-&gt;addr, client-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line">		<span class="keyword">goto</span> out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address business */</span></span><br><span class="line">	status = <span class="built_in">i2c_check_addr_ex</span>(adap, <span class="built_in">i2c_encode_flags_to_addr</span>(client));</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">			<span class="string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,</span><br><span class="line">			status, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">	client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">	client-&gt;dev.of_node = <span class="built_in">of_node_get</span>(info-&gt;of_node);</span><br><span class="line">	client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">i2c_dev_set_name</span>(adap, client, info, status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties) &#123;</span><br><span class="line">		status = <span class="built_in">device_add_properties</span>(&amp;client-&gt;dev, info-&gt;properties);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			<span class="built_in">dev_err</span>(&amp;adap-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,</span><br><span class="line">				client-&gt;name, status);</span><br><span class="line">			<span class="keyword">goto</span> out_err_put_of_node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">device_register</span>(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_free_props;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dev_dbg</span>(&amp;adap-&gt;dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">		client-&gt;name, <span class="built_in">dev_name</span>(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_free_props:</span><br><span class="line">	<span class="keyword">if</span> (info-&gt;properties)</span><br><span class="line">		<span class="built_in">device_remove_properties</span>(&amp;client-&gt;dev);</span><br><span class="line">out_err_put_of_node:</span><br><span class="line">	<span class="built_in">of_node_put</span>(info-&gt;of_node);</span><br><span class="line">out_err_silent:</span><br><span class="line">	<span class="built_in">kfree</span>(client);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL_GPL</span>(i2c_new_client_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>RK3568</category>
        <category>I2C驱动</category>
        <category>代码分析</category>
      </categories>
      <tags>
        <tag>Linux设备驱动</tag>
        <tag>RK3568</tag>
      </tags>
  </entry>
  <entry>
    <title>Zigbee协议栈 1</title>
    <url>/2022/02/27/ZigBee/2022-02-27-Zigbee%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Zigbee协议栈"><a href="#Zigbee协议栈" class="headerlink" title="Zigbee协议栈"></a>Zigbee协议栈</h1><h2 id="Zigbee协议栈简介"><a href="#Zigbee协议栈简介" class="headerlink" title="Zigbee协议栈简介"></a>Zigbee协议栈简介</h2><h3 id="协议和协议栈"><a href="#协议和协议栈" class="headerlink" title="协议和协议栈"></a>协议和协议栈</h3><ul>
<li>协议是一系列的通信标准，通信双方需要共同按照这一标准进行正常的数据发射和接收。</li>
<li>协议栈是协议的具体实现形式，即协议和用户之间的一个接口。开发人员通过协议栈使用协议，进而实现无线数据收发。</li>
</ul>
<h3 id="Zigbee协议栈架构"><a href="#Zigbee协议栈架构" class="headerlink" title="Zigbee协议栈架构"></a>Zigbee协议栈架构</h3><p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/Zigbee%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png?raw=true" alt="Zigbee无线网络协议层"></p>
<ul>
<li>Zigbee协议分为两部分：<ul>
<li>IEEE802.15.4定义了PHY(物理层)和MAC(介质访问层)技术规范。</li>
<li>Zigbee联盟定义了NWK(网络层)、APS(应用程序支持子层)、APL(应用层)技术规范。</li>
</ul>
</li>
<li>Zigbee协议栈就是将各个层定义的协议都集合在一起，以函数的形式实现，并给用户提供API(应用层)，用户可以直接调用。</li>
</ul>
<h3 id="Z-stack"><a href="#Z-stack" class="headerlink" title="Z-stack"></a>Z-stack</h3><ul>
<li>Z-stack是挪威半导体公司Chipcon(目前已经被TI公司收购)推出其CC2430(现在基本使用的是CC2530)开发平台时，推出的一款业界领先的商业级协议栈软件。</li>
<li>由于这个软件协议栈软件的出现，用户可以很容易开发出具体的应用程序(常说的掌握10个函数就能使用Zigbee通讯)。</li>
<li>使用瑞典公司IAR开发的IAR Embedded Workbench for MCS-51作为集成开发环境。</li>
<li>Chipcon公司为自己设计的Z-Stack协议栈中提供了一个名为操作系统抽象层OSAL的协议栈调度程序。<ul>
<li>对于用户来说，除了能够看到OSAL调度程序外，其他任何协议栈操作的具体实现细节都被封装在库代码中。</li>
<li>用户在进行具体的应用开发时，只能够通过调用API接口进行，而无权知道Zigbee协议栈实现的具体细节。只需要知道应用层的数据是使用哪些函数，通过什么方式把数据发送出去或者把数据接收过来的。</li>
</ul>
</li>
</ul>
<h3 id="Z-stack体系架构深度剖析"><a href="#Z-stack体系架构深度剖析" class="headerlink" title="Z-stack体系架构深度剖析"></a>Z-stack体系架构深度剖析</h3><ul>
<li>Z-stack的体系结构由称为层的各模块组成。每一层为上层提供特定的服务：<ul>
<li>由数据服务实体提供数据传输服务</li>
<li>由管理实体提供所有的其他管理服务。</li>
</ul>
</li>
<li>每个服务实体通过相应的服务接入点(SAP)为其上层提供了一个接口，每个服务接入点通过服务原语来完成所以对应的功能。<br><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/Z-stack%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png?raw=true" alt="Z-stack体系结构"></li>
<li>Z-stack根据IEEE802.15.4和Zigbee标准分为：<ul>
<li>物理层(PHY)：物理层定义了物理无线信道和MAC子层之间的接口，提供物理层数据服务和物理层管理服务，物理层内容：<ul>
<li>Zigbee的激活</li>
<li>当前信道的能量检测</li>
<li>接收链路服务质量信息</li>
<li>Zigbee信道接入方式</li>
<li>信道频率选择</li>
<li>数据传输和接收</li>
</ul>
</li>
<li>介质接入控制子层(MAC)：MAC层负责处理所有的物理无线信道访问，并产生网络信号、同步信号；支持PAN连接和分离，提供两个对等MAC实体之间可靠的链路。MAC层功能：<ul>
<li>网络协调器产生信标</li>
<li>与信标同步</li>
<li>支持PAN(个域网)链路的建立和断开</li>
<li>为设备安全性提供支持</li>
<li>信道接入方式采用免冲突载波检测多址接入(CSMA-CA)机制</li>
<li>处理和维护保护时隙(GTS)机制</li>
<li>在两个对等的MAC实体之间提供一个可靠的通信链路</li>
</ul>
</li>
<li>网络层(NWK)：Z-stack的核心部分。网络层主要实现节点加入或离开网络、接收或抛弃其他节点、路由查找及传送数据等功能。网络层功能：<ul>
<li>网络发现</li>
<li>网络形成</li>
<li>允许设备连接</li>
<li>路由器初始化</li>
<li>设备同网络连接</li>
<li>直接将设备同网络连接</li>
<li>断开网络连接</li>
<li>重新复位设备</li>
<li>接收机同步</li>
<li>信息库维护</li>
</ul>
</li>
<li>应用层(APL)：提供一些必要函数以及为网络层提供合适的服务接口，定义自己的应用对象。<ul>
<li>应用层框架包括<ul>
<li>应用支持层(APS)<ul>
<li>主要功能是：维持绑定表、在绑定的设备之间传送信息</li>
</ul>
</li>
<li>Zigbee设备对象(ZDO)<ul>
<li>主要功能是：定义设备在网络中的角色(协调器还是终端)、发起和响应绑定请求、在网络设备之间建立安全机制、发现网络中的设备并决定提供何种应用服务。</li>
</ul>
</li>
<li>制造商所定义的应用对象。<ul>
<li>应用程序框架(AF)：运行在Zigbee协议栈上的应用程序实际上就是厂商自定义的应用对象，并且遵循规范(profile)运行在端点1~240上。在Zigbee应用中，提供键值对(KVP)或报文(MSG)两种标准服务类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ZigBee开发</category>
      </categories>
      <tags>
        <tag>ZigBee</tag>
      </tags>
  </entry>
  <entry>
    <title>协议栈无线收发控制LED</title>
    <url>/2022/02/27/ZigBee/2022-02-27-%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%97%A0%E7%BA%BF%E6%94%B6%E5%8F%91%E6%8E%A7%E5%88%B6LED/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ZigBee开发—提高篇</category>
      </categories>
      <tags>
        <tag>ZigBee</tag>
      </tags>
  </entry>
  <entry>
    <title>Zigbee协议栈 3</title>
    <url>/2022/03/12/ZigBee/2022-03-12-Zigbee%E5%8D%8F%E8%AE%AE%E6%A0%88%203/</url>
    <content><![CDATA[<h1 id="Zigbee协议栈-3"><a href="#Zigbee协议栈-3" class="headerlink" title="Zigbee协议栈 3"></a>Zigbee协议栈 3</h1>]]></content>
      <categories>
        <category>ZigBee开发</category>
      </categories>
      <tags>
        <tag>ZigBee</tag>
      </tags>
  </entry>
  <entry>
    <title>Zigbee协议栈 2</title>
    <url>/2022/03/04/ZigBee/2022-03-04-Zigbee%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Zigbee协议栈"><a href="#Zigbee协议栈" class="headerlink" title="Zigbee协议栈"></a>Zigbee协议栈</h1><h2 id="Zigbee协议栈构成"><a href="#Zigbee协议栈构成" class="headerlink" title="Zigbee协议栈构成"></a>Zigbee协议栈构成</h2><h3 id="Zigbee协议栈项目结构分析"><a href="#Zigbee协议栈项目结构分析" class="headerlink" title="Zigbee协议栈项目结构分析"></a>Zigbee协议栈项目结构分析</h3><p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/Z-stack%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png?raw=true" alt="Z-stack文件目录"></p>
<ul>
<li>Components：库文件夹</li>
<li>Documents：TI开发文档，协议栈的API</li>
<li>Projects：TI协议栈例子程序</li>
<li>Tools：TI的例子程序的一些上位机之类的程序，作为工具使用。<blockquote>
<p>Z-Stack 3.0.1\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\GenericApp.eww文件讲解</p>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/GenericApp%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png?raw=true" alt="GenericApp.eww项目结构"></p>
<p>App：应用层目录，用户创建各种不同工程的区域，包含了应用层的内容和项目的主要内容。</p>
<p>HAL：硬件层目录，包含与硬件相关的配置和驱动及操作函数。</p>
<p>MAC：MAC层目录，包含了MAC层的参数配置文件及其MAC的LIB库的函数接口文件。</p>
<p>MT：实现通过串口可控制各层，并与各层进行直接交互。</p>
<p>NWK：网络层目录，包含网络层配置参数文件、网络层库的函数接口文件及APS层库的函数接口。</p>
<p>OSAL协议栈的操作系统。</p>
<p>Profile：应用框架层目录，包含AF层处理函数文件。应用框架层是应用程序和APS层的无线数据接口。</p>
<p>Security：安全层目录，包含安全层处理函数，比如加密函数。</p>
<p>Services：地址处理函数目录，包括地址模式的定义及地址处理函数。</p>
<p>Tools：工程配置目录，包括空间划分及Z-stack相关配置信息。</p>
<p>ZDO：ZDO目录。</p>
<p>ZMac：MAC层目录，包括MAC层参数配置及MAC层LIB库函数回调处理函数。</p>
<p>ZMain：主函数目录，包括入口函数及硬件配置文件。</p>
<p>Output：输出文件目录，由IAR IDE自动生成。</p>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%BD%93%E7%B3%BB%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AF%B9%E5%BA%94.png?raw=true" alt="协议栈体系分层结构与协议栈代码文件夹对应"></p>
</blockquote>
</li>
</ul>
<h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/Zigbee%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true" alt="Zigbee网络示意图"></p>
<ul>
<li>三种逻辑设备类型<ul>
<li>Coordinator(协调器)<ul>
<li>负责启动整个网络，也是网络的第一个设备。协调器选择一个信道和一个网络ID(PAN ID，即Personal Area Network ID)，随后启动整个网络。协调器也可以用来协助建立网络中安全层和应用层的绑定(bindings)。</li>
<li>协调器的角色主要涉及网络的启动和配置。一旦完成，协调器工作就像一个路由器(Zigbee网络本身有分布特性)。</li>
</ul>
</li>
<li>Router(路由器)<ul>
<li>允许其他设备加入网络，多跳路由和协助它自己的由电池供电的终端设备的通讯。</li>
<li>通常路由器希望是一直处于活动状态的，因此常使用主电源供电。</li>
<li>当使用树状网络拓扑结构时，允许路由间隔一定的周期操作一次，就可以使用电池供电。</li>
</ul>
</li>
<li>End-Device(终端设备)<ul>
<li>没有特定的维持网络结构的责任，可以睡眠或者唤醒，因此可以是一个电池供电设备。通常终端设备对存储空间(特别是RAM)的需要比较小。</li>
</ul>
</li>
</ul>
</li>
<li>Zigbee网络由一个协调器以及多个路由器和多个终端设备组成。</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E5%85%B3%E4%BA%8EZigbee%E8%8A%82%E7%82%B9%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.png?raw=true" alt="关于Zigbee节点设备类型的编译选项"></p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><ul>
<li>三种拓扑结构<ul>
<li>星状网络<ul>
<li>一个协调器和多个终端设备组成，只存在PAN协调器与终端的通讯，终端设备间的通讯都需通过协调器转发。</li>
</ul>
</li>
<li>树(簇)状网络<ul>
<li>一个协调器和一个或多个星状结构连接而成，设备除了能与自己的父节点或子节点进行点对点通讯外，其他只能通过树状路由完成消息传输。</li>
</ul>
</li>
<li>网状网络<ul>
<li>在树状网络的基础上实现，允许网络中所有具有路由功能的节点直接互连，由路由器中的路由表实现消息的网状路由。</li>
<li>优点是减少了消息延时，增强了可靠性。</li>
<li>缺点是需要更多的存储空间开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png?raw=true" alt="拓扑结构"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\nwk\nwk_globals.h</span></span><br><span class="line"><span class="comment">// Controls the operational mode of network</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MODE_STAR         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MODE_TREE         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MODE_MESH         2</span></span><br></pre></td></tr></table></figure>
<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h3><ul>
<li><p>Zigbee设备有两种类型的地址：</p>
<ul>
<li>64位IEEE地址，即MAC地址。<ul>
<li>全球唯一的地址，设备将在它的生命周期中一直拥有。通常由制造商或者被安装时设置。由IEEE来维护和分配。</li>
</ul>
</li>
<li>16位网络地址。<ul>
<li>设备加入自建的Zigbee网络后分配的，在网络中是唯一的，用来在网络中鉴别设备和发送数据。其中协调器的网络地址是0x00。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\nwk\nwk_globals.h</span></span><br><span class="line"><span class="comment">// Network PAN Coordinator Address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_PAN_COORD_ADDR 0x0000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>网络地址分配</p>
<ul>
<li>Zigbee 2006和Zigbee 2007<ul>
<li>使用分布式寻址方案来分配网络地址。</li>
<li>保证在整个网络中所有分配的地址是唯一的。进而保证一个特定的数据包能够发送给指定的设备而不出现混乱。同时，寻址算法本身的分布特性保证设备只能与父辈设备通讯来接收一个网络地址。不需要整个网络范围内通讯的地址分配，有助于网络的可测量性。</li>
<li>假设父设备可拥有的最大设备数为$C_m$，其拥有的最大路由子设备数为$R_m$，网络的最大深度为$L_m$，则父设备所能分配子区段地址数为：<ul>
<li>若$R<em>m=1, C</em>{skip}(d)=(1+C_m-R_m-C_m*(R_m)^{(L_m-d-1)}/(1-R_m)$</li>
<li>子节点为父设备的第n个子路由器的短地址分配：<ul>
<li>$A<em>{child}=A</em>{parent}+(n-1)*C_{skip}(d)+1, n=1$</li>
<li>$A<em>{child}=A</em>{parent}+(n-1)*C_{skip}(d), n&gt;1$</li>
</ul>
</li>
<li>子节点为父设备的第n个子终端设备的短地址分配：<ul>
<li>$A<em>{child}=A</em>{parent}+R<em>m*C</em>{skip}+n$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Zigbee 2007 PRO<ul>
<li>使用随机地址分配机制，对新加入的节点使用随机地址分配，为保证网络内地址分配不重复，使用其余的随即地址再进行分配。</li>
<li>当一个节点加入时，将接收到父节点的随机分配地址，然后产生”设备声明”(包含分配到的网络地址和自身的IEEE地址)发送至网络中的其余节点。如果另一个节点有相同的网络地址，则通过路由广播”网络状态——地址冲突”至网络中的所有节点。所有发生网络地址冲突的节点更改自己的网络地址，然后再发起”设备声明”检测新的网络地址是否会发生冲突。</li>
<li>终端设备不会发生广播”地址冲突”，因为父节点会帮助完成。如果一个终端设备发生了”地址冲突”，父节点将发送”重新加入”消息至终端设备，并要求他们更改网络地址。然后终端设备再发起”设备声明”检测新的网络地址是否冲突。<ul>
<li>即终端设备会告诉父节点自己的网络地址，由父节点去广播确认”地址冲突”。</li>
</ul>
</li>
<li>当接收到”设备声明”后，关联表和绑定表将被更新使用新的网络地址，但是路由表不会被更新。</li>
<li>在每个路由加入网络之前，寻址方案需要知道和配置一些参数。<ul>
<li><code>MAX_DEPTH</code>：最大网络深度。协调器位于深度0，子节点深度1，以此类推。该参数限制了网络在物理上的长度。</li>
<li><code>MAX_CHILDREN</code>：最大子结点个数，决定了一个路由或者协调器可以处理的子节点的最大个数。</li>
<li><code>MAX_ROUTERS</code>：最多路由数，决定了一个路由或者协调器可以处理的具有路由功能的子节点的最大个数，是MAX_CHILDREN的一个子集。终端节点的最大个数是$MAX_CHILDREN-MAX_ROUTERS$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * Z-stack工程中参数设置如下，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( STACK_PROFILE_ID == ZIGBEEPRO_PROFILE )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODE_DEPTH      20</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> ( STACK_PROFILE_ID == HOME_CONTROLS )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODE_DEPTH 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> ( STACK_PROFILE_ID == GENERIC_STAR )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODE_DEPTH 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> ( STACK_PROFILE_ID == NETWORK_SPECIFIC )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODE_DEPTH 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MAX_ROUTERS 6</span></span><br><span class="line"><span class="comment">// Maximum number in tables</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined( NWK_MAX_DEVICE_LIST )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MAX_DEVICE_LIST     20  <span class="comment">// Maximum number of devices in the</span></span></span><br><span class="line">                                    <span class="comment">// Assoc/Device list.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// Don&#x27;t change this value to set the number of devices.  Change</span></span><br><span class="line"><span class="comment">//  NWK_MAX_DEVICE_LIST above</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NWK_MAX_DEVICES   ( NWK_MAX_DEVICE_LIST + 1 )    <span class="comment">// One extra space for parent</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>寻址</p>
<blockquote>
<p>为了向一个在Zigbee网络中的设备发送数据，应用程序通常使用<code>AF_DataRequest()</code>函数。数据包将要发送给一个<code>afAddrType_t</code>类型的目标设备(该类型定义在AF.h中)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * Endpoint  Descriptions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  afAddrNotPresent = AddrNotPresent,</span><br><span class="line">  afAddr16Bit      = Addr16Bit,</span><br><span class="line">  afAddr64Bit      = Addr64Bit,</span><br><span class="line">  afAddrGroup      = AddrGroup,</span><br><span class="line">  afAddrBroadcast  = AddrBroadcast</span><br><span class="line">&#125; afAddrMode_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    uint16      shortAddr;</span><br><span class="line">    ZLongAddr_t extAddr;</span><br><span class="line">  &#125; addr;</span><br><span class="line">  afAddrMode_t addrMode;</span><br><span class="line">  uint8 endPoint;</span><br><span class="line">  uint16 panId;  <span class="comment">// used for the INTER_PAN feature</span></span><br><span class="line">&#125;  afAddrType_t;</span><br></pre></td></tr></table></figure>
<p>除了网络地址之外，还要指定地址模式参数。目的地址模式可以设置为以下几个值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\osal\include\ZComDef.h</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  AddrNotPresent = <span class="number">0</span>,</span><br><span class="line">  AddrGroup = <span class="number">1</span>,</span><br><span class="line">  Addr16Bit = <span class="number">2</span>,</span><br><span class="line">  Addr64Bit = <span class="number">3</span>,</span><br><span class="line">  AddrBroadcast = <span class="number">15</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>组寻址<ul>
<li>当应用程序需要将数据包发送给网络上的一组设备时，使用该模式。地址模式要设置为<code>afAddrGroup</code>，并且<code>addr.shortAddr</code>设置为组ID。</li>
<li>在使用该功能之前，必须在网络中定义组。(Z-stack API文档中的<code>aps_AddGroup()</code>函数)</li>
<li>注意组可以用来关联间接寻址，在绑定表中找到的目标地址可能时单点传送或者时一个组地址。</li>
<li>广播发送可以看作是一个组寻址的特例。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设备加入ID为1的组中。</span></span><br><span class="line">aps_Group_t group;</span><br><span class="line"><span class="comment">// Assign yourself to group 1</span></span><br><span class="line">group.ID = <span class="number">0x0001</span>;</span><br><span class="line">group.name[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// This could be a human readable string</span></span><br><span class="line"><span class="built_in">aps_AddGroup</span>( SAMPLEAPP_ENDPOINT, &amp;group );</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *      1. endpoints：将接收发送到组字段中的组的消息的端点</span></span><br><span class="line"><span class="comment"> *      2. group：在gropu表中包含group ID和group名字的数据结构。</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> *      1. 如果加入成功，返回ZSuccess</span></span><br><span class="line"><span class="comment"> *      2. 如果加入失败，返回ZApsDuplicateEntry(重复加入)，ZApsTableFull(group表满了)或ZMemError(内存错误)</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数据包<ul>
<li>单点传送(unicast)<ul>
<li>标准寻址模式，将数据包发送给一个已经知道网络地址的网络设备。</li>
<li>将<code>afAddrMode</code>设置为<code>Addr16Bit</code></li>
<li>并且在数据包中携带目标设备地址。</li>
</ul>
</li>
<li>多点传送(multicast)<ul>
<li>数据包发给一组设备。</li>
</ul>
</li>
<li>间接传送(indirect)<ul>
<li>当应用程序不知道数据包的目标设备在哪里的时候使用，</li>
<li>将模式设置为<code>AddrNotPresent</code></li>
<li>并且目标地址没有指定。<ul>
<li>从发送设备的栈的绑定表中查找目标设备(源绑定)。当数据向下发送到达栈中，从绑定表中查找并且使用该目标地址。如此数据包将被处理成为一个标准的单点传送数据包。如果在绑定表中找到多个设备，则向每个设备都发送一个数据包的拷贝。</li>
<li>协调器绑定：发送设备将数据包发送给协调器，由协调器查找自己栈中的绑定表，然后将数据发送给最终的目标设备。</li>
</ul>
</li>
</ul>
</li>
<li>广播传送(broadcast)<ul>
<li>应用程序需要将数据包发送给网络的每一个设备时，使用广播传送。</li>
<li>地址模式设置为<code>AddrBroadcast</code>。</li>
<li>目标地址可以设置为<ul>
<li><code>NWK_BROADCAST_SHORTADDR_DEVALL(0xFFFF)</code>：数据包将被传送到网络上的所有设备，包括睡眠中的设备。对于睡眠中的设备，数据包将被保留在其父亲节点直到查询到它，或者消息超时(<code>NWK_INDIRECT_MSG_TIMEOUT</code>)。</li>
<li><code>NWK_BROADCAST_SHORTADDR_DEVRXON(0xFFFD)</code>：数据包将被传送到网络上的所有在空闲时打开接收到的设备(<code>RXONWHENIDLE</code>)，也就是说，除了睡眠中的所有设备。</li>
<li><code>NWK_BROADCAST_SHORTADDR_DEVZCZR(0xFFFC)</code>：数据包发送给所有的路由器，包括协调器。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>重要设备地址<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用程序可能需要知道它的设备地址和父亲地址。使用下面的函数获取设备地址：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NLME_GetShortAddr</span>()</span><br><span class="line"><span class="built_in">NLME_GetExtAddr</span>()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用下面的函数获取该设备的父亲设备的地址：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NLME_GetCoordShortAddr</span>()</span><br><span class="line"><span class="built_in">NLME_GetCoordExtAddr</span>()</span><br></pre></td></tr></table></figure></li>
<li>属性<ul>
<li>Attribute是一个反映物理数量或状态的数据值，比如开关值(On/Off)，温度值，百分比等。</li>
</ul>
</li>
<li>群集<ul>
<li>群集Cluster是包含一个或多个属性(attribute)的群组。简单的说，群集就是属性的集合。每个群集被分配一个唯一的群集ID且每个群集最多由65536个属性。</li>
</ul>
</li>
<li>设备描述符<ul>
<li>指定群集是输入还是输出。主要有：<ul>
<li>节点描述符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\af\AF.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  uint8 LogicalType:<span class="number">3</span>;</span><br><span class="line">  uint8 ComplexDescAvail:<span class="number">1</span>;  <span class="comment">/* AF_V1_SUPPORT - reserved bit. */</span></span><br><span class="line">  uint8 UserDescAvail:<span class="number">1</span>;     <span class="comment">/* AF_V1_SUPPORT - reserved bit. */</span></span><br><span class="line">  uint8 Reserved:<span class="number">3</span>;</span><br><span class="line">  uint8 APSFlags:<span class="number">3</span>;</span><br><span class="line">  uint8 FrequencyBand:<span class="number">5</span>;</span><br><span class="line">  uint8 CapabilityFlags;</span><br><span class="line">  uint8 ManufacturerCode[<span class="number">2</span>];</span><br><span class="line">  uint8 MaxBufferSize;</span><br><span class="line">  uint8 MaxInTransferSize[<span class="number">2</span>];</span><br><span class="line">  uint16 ServerMask;</span><br><span class="line">  uint8 MaxOutTransferSize[<span class="number">2</span>];</span><br><span class="line">  uint8 DescriptorCapability;</span><br><span class="line">&#125; NodeDescriptorFormat_t;</span><br></pre></td></tr></table></figure></li>
<li>电源描述符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\af\AF.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> PowerMode:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> AvailablePowerSources:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> CurrentPowerSource:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> CurrentPowerSourceLevel:<span class="number">4</span>;</span><br><span class="line">&#125; NodePowerDescriptorFormat_t;</span><br></pre></td></tr></table></figure></li>
<li>简单描述符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\af\AF.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  uint8          EndPoint;</span><br><span class="line">  uint16         AppProfId;</span><br><span class="line">  uint16         AppDeviceId;</span><br><span class="line">  uint8          AppDevVer:<span class="number">4</span>;</span><br><span class="line">  uint8          Reserved:<span class="number">4</span>;             <span class="comment">// AF_V1_SUPPORT uses for AppFlags:4.</span></span><br><span class="line">  uint8          AppNumInClusters;</span><br><span class="line">  cId_t         *pAppInClusterList;</span><br><span class="line">  uint8          AppNumOutClusters;</span><br><span class="line">  cId_t         *pAppOutClusterList;</span><br><span class="line">&#125; SimpleDescriptionFormat_t;</span><br></pre></td></tr></table></figure></li>
<li>端点描述符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \Z-Stack 3.0.1\Components\stack\af\AF.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  uint8 endPoint;</span><br><span class="line">  uint8 epType;</span><br><span class="line">  uint8 *task_id;  <span class="comment">// Pointer to location of the Application task ID.</span></span><br><span class="line">  SimpleDescriptionFormat_t *simpleDesc;</span><br><span class="line">  afNetworkLatencyReq_t latencyReq;</span><br><span class="line">&#125; endPointDesc_t;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>端点<ul>
<li>端点EndPoint是协议栈应用层的入口，也可以理解应用对象(Application Object)存在的地方，是为了实现一个设备描述而定义的一组群集。每个Zigbee设备可以最多支持240个端点。意味着每个设备上可以定义240个应用对象。</li>
<li>端点0被保留用于ZDO接口，每个Zigbee设备都必须使用该端点。</li>
<li>端点255被保留用于广播。</li>
<li>端点241-254被保留用于将来做扩展使用。</li>
</ul>
</li>
<li>节点<ul>
<li>Node，也可以理解为一个容器，包含一组Zigbee设备，分享一个无线信道。每个节点有且只有一个无线信道。</li>
</ul>
</li>
<li>绑定(binding)<ul>
<li>在Zigbee协议中定义的一种特殊操作。能够通过使用ClusterID为不同节点上的独立端点建立一个逻辑上的连接。</li>
<li>要实现绑定操作，端点必须向协调器发送绑定请求，协调器在有限的时间间隔内接收到两个端点的绑定请求后，便通过建立端点之间的绑定表在这两个不同的端点之间搭建一个逻辑链路。绑定后的两个端点之间的信息传送属于间接传送。其中一个端点首先会将信息发送到Zigbee的协调器，Zigbee协调器在接收到消息后通过查找绑定表，将消息发送到与这个端点相绑定的所有端点中，从而实现绑定端点之间的通信。<br><img src="https://github.com/zjn-astonishe/image/blob/main/Zigbee/%E7%BB%91%E5%AE%9A.png?raw=true" alt="绑定"><blockquote>
<p>图中Zigbee网络中的两个节点Z1和Z2。</p>
<p>其中Z1节点中包含两个独立端点——EP3和EP21，分别表示开关1和开关2。</p>
<p>Z2节点中有EP5、EP7、EP8、EP17四个端点，分别表示从1到4四盏灯。</p>
<p>在网络中，通过建立Zigbee绑定操作，将EP3和EP5、EP7、EP8进行绑定，将EP21和EP17进行绑定。开关1就可以同时控制电灯1、2、3，开关2便可以控制电灯4。利用绑定操作，还可以更改开关和电灯之间的绑定关系，从而形成不同的控制关系。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul>
<li>路由对应用层来说是完全透明的。应用程序只需简单的向下发送去往任何设备的数据到栈中，栈会负责寻找路径，即应用程序不知道操作是在一个多跳的网络当中的。</li>
<li>路由还能自愈Zigbee网络，如果某个无线连接断开，路由功能会自动寻找一条新的路径避开那个断开的网络连接。极大的提高了网络的可靠性。</li>
<li><p>协议栈规范(Stack Profile)</p>
<ul>
<li>Zigbee联盟制定，在同一个网络中的设备必须符合同一个协议栈规范(同一个网络中所有设备的协议栈规范必须一致)。</li>
<li>所有的设备只要遵循该规范，即使在不同厂商买的不同设备同样可以形成网络；但是不遵循规范，即使相同的设备也不能组成网络(该产品具有特殊性，被称为”关闭的网络”，更改后的规范称为”特定网络”规范。</li>
<li>协议栈规范的ID号可以通过查询设备发送的beacon帧获得。在设备加入网络之前，首先需要确认协议栈规范的ID。”特定网络”规范ID号为0，Zigbee协议栈规范ID号为1，Zigbee PRO协议栈规范ID号为2。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controls various stack parameter settings</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETWORK_SPECIFIC      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOME_CONTROLS         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIGBEEPRO_PROFILE     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERIC_STAR          3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERIC_TREE          4</span></span><br><span class="line"><span class="comment">// STACK_PROFILE_ID表示的是协议栈规范的ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( ZIGBEEPRO )</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> STACK_PROFILE_ID      ZIGBEEPRO_PROFILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> STACK_PROFILE_ID      HOME_CONTROLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>路由协议</p>
<ul>
<li>Zigbee执行基于AODV专用网络的路由协议。当路由器从自身的应用程序或者别的设备收到单点发送的数据包：<ul>
<li>如果目标节点是相邻路由的一个，则数据包直接被传送给目标设备，</li>
<li>否则将检索路由器自身的路由表，获得与所要传送的数据包的目标地址相符合的记录。<ul>
<li>如果存在与目标地址相符合的活动路由记录，则数据包将发送到存储在记录中的下一级地址中去。</li>
<li>如果没有发现任何相关的路由记录，则路由器发起路径寻找，数据包存储在缓冲区中直到寻找结束。</li>
</ul>
</li>
</ul>
</li>
<li>Zigbee终端节点不执行任何路由功能，终端节点要向任何一个设备传送数据包，只需要简单的将数据向上发送刚给父设备，由父设备以终端节点的名义执行路由。同样，任何一个设备要给终端节点发送数据，发起路由寻找，终端节点的父亲节点都以终端节点的名义来回应。</li>
<li>Zigbee地址分配方案使得对于任何一个目标设备，根据它的地址都可以得到一条路径。</li>
<li>在Z-stack中，如果万一正常的路径寻找过程不能启动(缺少路由表空间)，那么Z-stack拥有自动回退机制。</li>
<li>在Z-stack中，执行的路由已经优化了路由表的记录。通常，每一个目标设备都需要要一条路由表记录。但是，通过把一定父亲节点记录与其所有子节点的记录合并，既可以优化路径，又可以不丧失任何功能。</li>
<li>Zigbee路由器，包括协调器执行下面的路由函数<ul>
<li>路径发现<ul>
<li>网络设备凭借网络相互协作发现和建立路径的一个过程。</li>
<li>路由发现可以由任意一个路由设备发起，并且对于某个特定的目标设备一直执行。</li>
<li>路由发现机制寻找源地址和目标地址之间的所有路径，并且试图选择可能的最好的路径。</li>
</ul>
</li>
<li>路由选择<ul>
<li>路由选择即选择出可能的最小成本的路径。</li>
<li>每个节点通常持有跟它所有临界点的连接成本(link cost)。通常衡量连接成本的典型函数是接收到的信号的强度。沿着路径，求出所有连接的连接成本总和，便可以得到整个路径的”路径成本”。</li>
<li>路由算法试图寻找到拥有最小路径成本的路径。路径通过一系列的请求和回复数据包被发现。源设备通过向它所有的临界节点广播一个路由请求数据包，来请求一个目标地址的路径。当一个节点接收到<code>RREQ</code>数据包，会在为数据包更新连接成本后，依次广播转发<code>RREQ</code>数据包。这个过程一直持续到<code>RREQ</code>数据包到达目标设备。通过不同的路由器，许多<code>RREQ</code>数据包都将到达目标设备，说明从源设备到目标设备存在多条路径，目标设备会选择最好的<code>RREQ</code>数据包(最小路径成本)，然后发回一个路径答复<code>RREP</code>数据包给源设备。<code>RREP</code>数据包是一个单点发送数据包，沿着中间节点的相反路径传送直到到达原来发送请求的节点为止。一旦一条路径被创建，数据包就可以发送了。</li>
<li>当一个节点与下一级相邻节点失去连接(发送数据没有收到<code>MAC ACK</code>)，该节点会向所有等待接收它的<code>RREQ</code>数据包的节点发送一个<code>REER</code>数据包，将路径设为无效。</li>
<li>各个节点根据收到的<code>REEQ</code>、<code>REEP</code>、<code>REER</code>数据包更新路由表。</li>
</ul>
</li>
<li>路径保持维护<ul>
<li>网状网提供路径维护和网络自愈功能。中间节点沿着连接跟踪传送失败。</li>
<li>如果一个连接被认定是坏链，<ul>
<li>那么上游节点将针对所有使用这条连接的路径启动路径修复，节点发起重新发现直到下一次数据包到达该节点，标志路径修复完成。</li>
<li>如果不能够启动路径发现或者由于某种原因失败，节点则向数据包的源节点发送路径错误包(REER)，负责启动新路径的发现。</li>
</ul>
</li>
</ul>
</li>
<li>路径期满<ul>
<li>路由表为已经建立连接路径的节点维护路径记录。</li>
<li>如果在一定的时间周期内，没有数据通过沿着这条路径发送，这条路径将被表示为期满。期满的路径一直保留到所占用的空间要被使用为止。</li>
<li>在配置文件<code>f8wConfig.cfg</code>文件中配置自动路径期满时间。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* in seconds; set to 0 to turn off route expiry */</span></span><br><span class="line"><span class="comment">// 单位为秒，如果设置为0，则表示关闭自动期满功能。</span></span><br><span class="line">-DROUTE_EXPIRY_TIME=<span class="number">30</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ZigBee开发</category>
      </categories>
      <tags>
        <tag>ZigBee</tag>
      </tags>
  </entry>
  <entry>
    <title>OS Agents 笔记</title>
    <url>/2025/04/14/%E6%99%BA%E8%83%BD%E4%BD%93/2025-04-14-OS%20Agents%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="OS-Agent-A-Survey-on-MLLM-based-Agents-for-Computer-Phone-and-Browser-Use"><a href="#OS-Agent-A-Survey-on-MLLM-based-Agents-for-Computer-Phone-and-Browser-Use" class="headerlink" title="OS Agent: A Survey on MLLM-based Agents for Computer, Phone and Browser Use"></a>OS Agent: A Survey on MLLM-based Agents for Computer, Phone and Browser Use</h1><h2 id="Agents基础"><a href="#Agents基础" class="headerlink" title="Agents基础"></a>Agents基础</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E6%99%BA%E8%83%BD%E4%BD%93/OS%20Agents%20%E5%9F%BA%E7%A1%80_%E5%85%B3%E9%94%AE%E8%A6%81%E7%B4%A0%E5%92%8C%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B.png" alt="关键要素和核心能力"></p>
<h3 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h3><ul>
<li>环境(Environment): 智能体操作的系统或平台。环境是智能体完成任务的舞台，支持从简单的信息检索到复杂的多步骤操作。</li>
<li>观察空间(Observation Space): 智能体可获取的所有信息范围。如屏幕截图、文本描述(HTML代码)或GUI界面结构，是智能体理解环境和任务的基础。</li>
<li>动作空间(Action Space): 智能体与环境交互的动作集合。定义了可执行操作(点击、输入文本、导航操作甚至调用外部工具)。使得智能体能够自动化完成任务并优化工作流</li>
</ul>
<h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h3><ul>
<li>理解(Understanding): 理解复杂的操作环境，提取关键信息，构建对任务和环境的全面认知。理解能力是处理信息检索等任务的前提。</li>
<li>规划(Planning): 要求将复杂的任务拆解为多个子任务，并依此制定操作序列实现目标。最好还要能够根据环境变化动态调整计划，适应复杂的操作系统环境(动态网页和实时更新的用户屏幕界面)。</li>
<li>操作(Grounding): 将规划转化为具体可执行的操作(点击按钮、输入文本、调用API)。</li>
</ul>
<h2 id="构建Agents"><a href="#构建Agents" class="headerlink" title="构建Agents"></a>构建Agents</h2><h3 id="基础模型-Foundation-Model"><a href="#基础模型-Foundation-Model" class="headerlink" title="基础模型(Foundation Model)"></a>基础模型(Foundation Model)</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E6%99%BA%E8%83%BD%E4%BD%93/OS%20Agents%20%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B-%E6%9E%B6%E6%9E%84_%E9%A2%84%E8%AE%AD%E7%BB%83_%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.png" alt="架构_预训练_监督微调和强化学习"></p>
<h4 id="架构-Architecture"><a href="#架构-Architecture" class="headerlink" title="架构(Architecture)"></a>架构(Architecture)</h4><ol>
<li>Existing LLMs: 直接采用开源的大语言模型架构，将结构化的屏幕界面信息以文本形式输入给LLMs，从而使得模型可以感知环境。(如何获得文本形式的屏幕界面信息？)</li>
<li>Existing MLLMs: 直接采用开源的多模态大语言模型架构块，整合文本和视觉处理能力，提升对GUI的理解能力，减少文本化视觉信息而造成的特征损失(优化目标)。</li>
<li>Concatenated MLLMs: 由LLM与视觉编码器桥接而成，灵活性更高，可以根据任务需求选择不同的语言模型和视觉模型进行组合。</li>
<li>Modified MLLMs: 对现有MLLM架构进行优化调整，解决特定场景的挑战<ul>
<li>添加额外模块，如高分辨率视觉编码器或图像分割模块，更细致地感知和理解屏幕界面细节。</li>
</ul>
</li>
</ol>
<h4 id="预训练-Pre-training"><a href="#预训练-Pre-training" class="headerlink" title="预训练(Pre-training)"></a>预训练(Pre-training)</h4><ul>
<li>为模型构建打下基础，通过海量数据提升对屏幕界面的理解能力。<ul>
<li>屏幕定位(Screen Grounding)</li>
<li>屏幕理解(Screen Understanding)</li>
<li>光学字符识别(OCR)</li>
</ul>
</li>
<li>数据源<ul>
<li>公共数据集</li>
<li>合成数据集</li>
</ul>
</li>
</ul>
<h4 id="监督微调-Supervised-Fine-tuning"><a href="#监督微调-Supervised-Fine-tuning" class="headerlink" title="监督微调(Supervised Fine-tuning)"></a>监督微调(Supervised Fine-tuning)</h4><ul>
<li>让模型更贴合GUI场景，提升智能体规划能力和执行能力。<ul>
<li>记录任务执行轨迹生成训练数据。</li>
<li>利用HTML渲染屏幕界面细节，提升模型对不同GUI的泛化能力。</li>
</ul>
</li>
</ul>
<h4 id="强化学习-Reinforcement-Learning"><a href="#强化学习-Reinforcement-Learning" class="headerlink" title="强化学习(Reinforcement Learning)"></a>强化学习(Reinforcement Learning)</h4><ul>
<li>用(M)LLMs作为特征提取到(M)LLM-as-Agent的范式转变，帮助智能体在动态环境中交互，根据奖励反馈，不断优化决策。提升了智能体的对齐程度，泛化能力和任务适配性。</li>
</ul>
<h3 id="智能体框架-Agent-Framework"><a href="#智能体框架-Agent-Framework" class="headerlink" title="智能体框架(Agent Framework)"></a>智能体框架(Agent Framework)</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E6%99%BA%E8%83%BD%E4%BD%93/OS%20Agents%20%E6%A1%86%E6%9E%B6_%E6%84%9F%E7%9F%A5_%E8%A7%84%E5%88%92_%E8%AE%B0%E5%BF%86%E5%92%8C%E8%A1%8C%E5%8A%A8.png" alt="框架_感知_规划_记忆和行动"></p>
<h4 id="感知-Perception"><a href="#感知-Perception" class="headerlink" title="感知(Perception)"></a>感知(Perception)</h4><ul>
<li>文本感知: 将操作系统的状态转化为结构化文本描述。<ul>
<li>DOM树</li>
<li>HTML文件</li>
</ul>
</li>
<li>屏幕界面感知<ul>
<li>使用视觉编码器对屏幕界面截图进行理解。</li>
<li>通过视觉定位(按钮、菜单)和语义连接(HTML标记)精准识别关键元素。</li>
</ul>
</li>
</ul>
<h4 id="规划-Planning"><a href="#规划-Planning" class="headerlink" title="规划(Planning)"></a>规划(Planning)</h4><ul>
<li>作为智能体的”大脑”，负责制定任务的执行策略。<ul>
<li>全局规划: 一次生成完整的计划并执行。</li>
<li>迭代规划: 随着环境的变化动态调整计划，适应实时更新的屏幕界面和任务需求。</li>
</ul>
</li>
</ul>
<h4 id="记忆-Memory"><a href="#记忆-Memory" class="headerlink" title="记忆(Memory)"></a>记忆(Memory)</h4><ul>
<li>内部记忆(Internal Memory): 存储操作历史、屏幕截图、状态数据和动态环境信息，支持任务执行的上下文理解和轨迹优化。<ul>
<li>借助截图解析屏幕界面布局。</li>
<li>根据历史操作生成决策。</li>
</ul>
</li>
<li>外部记忆(External Memory): 提供长期知识支持。<ul>
<li>调用外部工具(API)</li>
<li>从知识库获取领域背景知识，辅助复杂任务的决策。</li>
</ul>
</li>
<li>特定记忆(Specific Memory): 聚焦于特定任务的知识和用户需求。<ul>
<li>存储子任务分解方法、用户偏好或屏幕界面交互功能。</li>
<li>提供高度针对性的操作支持。</li>
<li>记忆优化策略。</li>
</ul>
</li>
</ul>
<h4 id="行动-Action"><a href="#行动-Action" class="headerlink" title="行动(Action)"></a>行动(Action)</h4><ul>
<li>输入操作: 与数字屏幕界面交互的基础。<ul>
<li>鼠标操作</li>
<li>触控操作</li>
<li>键盘操作</li>
</ul>
</li>
<li>导航操作: 探索和移动于目标平台，获取执行任务所需的信息。</li>
<li>扩展操作: 不止与屏幕界面交互。<ul>
<li>代码执行</li>
<li>API调用</li>
</ul>
</li>
</ul>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h3 id="评估协议-Evaluation-Protocol"><a href="#评估协议-Evaluation-Protocol" class="headerlink" title="评估协议(Evaluation Protocol)"></a>评估协议(Evaluation Protocol)</h3><ul>
<li>评估的核心为: <ul>
<li>评估过程应如何进行。</li>
<li>需要对哪些方面进行评估。</li>
</ul>
</li>
</ul>
<h4 id="评估原则-Evaluation-Principle"><a href="#评估原则-Evaluation-Principle" class="headerlink" title="评估原则(Evaluation Principle)"></a>评估原则(Evaluation Principle)</h4><ul>
<li>客观评估(Objective): 通过标准化的数值指标，评估智能体在特定任务中的性能。<ul>
<li>操作的准确性</li>
<li>任务的成功率</li>
<li>语义匹配的精准度</li>
</ul>
</li>
<li>主观评估(Subjective): 基于人类用户的主观感受，评估智能体的输出质量。<ul>
<li>相关性</li>
<li>自然性</li>
<li>连贯性</li>
<li>整体效果</li>
</ul>
</li>
<li>借助(M)LLM-as-Judge评估: 提高效率和一致性。</li>
</ul>
<h4 id="评估指标-Evaluation-Metric"><a href="#评估指标-Evaluation-Metric" class="headerlink" title="评估指标(Evaluation Metric)"></a>评估指标(Evaluation Metric)</h4><p>评估指标聚焦于智能体的理解、规划和操作能力，衡量其在不同任务中的表现。</p>
<ul>
<li>步骤级指标: 评估智能体在每一步操作中的准确性。<ul>
<li>任务执行中动作的语义匹配程度</li>
<li>任务执行中操作的准确性</li>
</ul>
</li>
<li>任务级指标: 聚焦于整个任务完成情况。<ul>
<li>任务成功率</li>
<li>完成任务的效率</li>
</ul>
</li>
</ul>
<h3 id="评估基准-Evaluation-Benchmark"><a href="#评估基准-Evaluation-Benchmark" class="headerlink" title="评估基准(Evaluation Benchmark)"></a>评估基准(Evaluation Benchmark)</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E6%99%BA%E8%83%BD%E4%BD%93/OS%20Agents%20%E5%B9%B3%E5%8F%B0-%E5%9F%BA%E5%87%86%E4%B8%8E%E4%BB%BB%E5%8A%A1%E5%88%86%E7%B1%BB.png" alt="平台-基准与任务分类"></p>
<h4 id="评估平台-Evaluation-Platform"><a href="#评估平台-Evaluation-Platform" class="headerlink" title="评估平台(Evaluation Platform)"></a>评估平台(Evaluation Platform)</h4><ul>
<li>移动平台(Mobile)</li>
<li>桌面平台(Desktop)</li>
<li>网页平台(Web)</li>
</ul>
<h4 id="基准设置-Benchmark-Setting"><a href="#基准设置-Benchmark-Setting" class="headerlink" title="基准设置(Benchmark Setting)"></a>基准设置(Benchmark Setting)</h4><ul>
<li>静态环境(Static): 适用与基础任务的离线评估。</li>
<li>交互式环境(Interactive): 全面测试智能体在复杂动态场景中的实际能力。<ul>
<li>模拟环境(Simulated): 多用于功能调试验证。</li>
<li>真实环境(Real-World): 强调泛化能力和动态适应性，未来评估的重要方向。</li>
</ul>
</li>
</ul>
<h4 id="任务-Task"><a href="#任务-Task" class="headerlink" title="任务(Task)"></a>任务(Task)</h4><p>当前的基准测试整合了各种专业化任务，涵盖从系统级任务(安装和卸载应用程序)到日常应用任务(发送邮件和在线购物)。</p>
<ul>
<li>GUI定位(GUI Grounding): 评估智能体将指令转换为屏幕界面操作的能力。<ul>
<li>如何在操作系统中与指定的可操作元素交互。</li>
</ul>
</li>
<li>信息处理(Information Processing):评估智能体高效处理和总结信息的能力。<ul>
<li>尤其在动态和复杂环境中，从大量数据提取有用信息的能力。</li>
</ul>
</li>
<li>智能体任务(Agentic Tasks): 评估智能体的核心能力，规划和执行复杂任务。<ul>
<li>为智能体提供目标或指令，要求其在没有显式指导的情况下完成任务。</li>
</ul>
</li>
</ul>
<h4 id="安全-Security"><a href="#安全-Security" class="headerlink" title="安全(Security)"></a>安全(Security)</h4><ul>
<li>为评估 OS Agents 在不同场景下的鲁棒性，还引入了一些智能体安全基准测试，用于全面测试和改进系统的安全表现。<ul>
<li>ST-WebAgentBench</li>
<li>MobileSafetyBench</li>
</ul>
</li>
</ul>
<h2 id="挑战与未来"><a href="#挑战与未来" class="headerlink" title="挑战与未来"></a>挑战与未来</h2><h3 id="安全与隐私"><a href="#安全与隐私" class="headerlink" title="安全与隐私"></a>安全与隐私</h3><ul>
<li>面临多种攻击方式，包括间接提示注入攻击、恶意弹出窗口和对抗性指令生成，这些威胁可能导致系统执行错误操作或泄露敏感信息。</li>
<li>当前研究主要集中于设计专门应对注入攻击和后门攻击等特殊威胁的防御方案，急待开发全面的且可扩展防御框架，以提升 OS Agents 的整体安全性和可靠性。</li>
</ul>
<h3 id="个性化和自我进化"><a href="#个性化和自我进化" class="headerlink" title="个性化和自我进化"></a>个性化和自我进化</h3><ul>
<li>需要根据用户偏好不断调整行为和功能。<ul>
<li>多模态大语言模型正逐步支持理解用户历史记录和动态适应用户需求，OpenAI的Memory功能在这一方向上已经取得了一定进展。</li>
<li>未来将记忆机制扩展到更复杂的形式，如音频、视频、传感器数据等，从而提供更高级的预测能力和决策支持。</li>
</ul>
</li>
<li>进化<ul>
<li>让智能体通过用户交互和任务执行过程持续学习和优化，从而提升个性化程度和性能。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>智能体</category>
      </categories>
      <tags>
        <tag>智能体</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray conclusion</title>
    <url>/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Ray%20conclusion/</url>
    <content><![CDATA[<h1 id="《Ray-A-Distributed-Framework-for-Emerging-AI-Applications》-Review"><a href="#《Ray-A-Distributed-Framework-for-Emerging-AI-Applications》-Review" class="headerlink" title="《Ray: A Distributed Framework for Emerging AI Applications》 Review"></a>《Ray: A Distributed Framework for Emerging AI Applications》 Review</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文提出了一个分布式强化学习框架Ray，以解决其他框架无法统一直接地完成强化学习计算的问题。</p>
<ul>
<li>功能上，Ray实现了一个统一的接口，由一个动态执行的引擎提供并行任务(task-parallel)和基于actor的计算(actor-based computation)的支持。</li>
<li>性能上，Ray采用分布式调度器和一个分布式的(distributed)且容许出错的(falut-tolerant)存储以管理系统的状态控制。</li>
<li>实验结果表明：Ray拥有每秒超过180万个任务的扩展性，以及在几个具有挑战性的强化学习应用中拥有比其他现有专门系统更好的性能。</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>新兴的人工智能应用越来越多地运行在动态的环境中。它们对环境的变化做出反应，并采取一系列行动来完成长期目标——不仅是利用收集到的数据，而且还要探索可能的行动空间。这些更广泛的要求很自然地被置于强化学习(RL)的范式中。</p>
<p>强化学习(Reinforcement Learning，RL)，即在一个不确定的环境中，基于延迟和有限的反馈，进行不断地学习。它的核心目标是学习一个策略(strategy)，实现从环境状态到行动选择的映射，以达到更好的效果。这就提出了它需要具备的三个主要能力：</p>
<ul>
<li>依赖于模拟(simulation)去评估策略，探索不同的行动序列，并了解这些选择的长期后果。</li>
<li>需要进行分布式训练，根据模拟或与物理世界的互动产生的数据改进策略。</li>
<li>策略的目的是提供解决方案以控制问题。因此有必要在closed-loop和open-loop的控制场景中为策略提供服务。</li>
</ul>
<h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>考虑RL系统的基本组成部分，如图1所示，在一个RL环境中，一个agent会反复与环境进行交互，它的目标是学习一个使奖励(reward)最大化的策略(policy)。策略则是一个从环境状态到行动选择的映射。其中的Environment、Agent、state、action、reward的精确定义是视应用而定的。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/16.png" style="zoom: 33%;" /></p>
<p>为了学习一个策略，Agent通常要采用两步程序：</p>
<ul>
<li>评估策略<ul>
<li>为了评估策略，Agent需要与Environment互动，产生由state和reward二元组构成的trajectory。</li>
</ul>
</li>
<li>改进策略<ul>
<li>根据得到的trajectory改进policy：按照使reward最大化的梯度方向更新policy。</li>
</ul>
</li>
</ul>
<p>图2显示了一个Agent学习策略的伪代码例子，通过调用<code>rollout(environment, policy)</code>生成trajectory评估策略，然后调用<code>train_policy()</code>通过<code>policy_update(trajectories)</code>改进当前策略。随后不断重复，直到收敛。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/1.png" style="zoom:45%;" /></p>
<p>由伪代码可以看出，RL应用的框架必须为Training、Serving和Simulation提供有效的支持：</p>
<ul>
<li>Training涉及运行随机梯度下降(SGD)以更新策略。</li>
<li>Serving使用训练过的策略，根据环境的当前状态采取一个行动。</li>
<li>Simulation进行策略评估。</li>
</ul>
<p>因此，RL应用的框架应该满足以下的需求：</p>
<ul>
<li><p>支持细粒度的计算：</p>
<ul>
<li>在真实世界交互在毫秒内呈现动作，并执行大量的计算。</li>
</ul>
</li>
<li><p>支持异构的计算</p>
<ul>
<li><p>时间上：计算的持续时间从毫秒到小时不等</p>
</li>
<li><p>硬件上：训练通常需要异构的硬件(CPU、GPU、TPU)</p>
</li>
</ul>
</li>
<li><p>灵活的计算模型：无状态计算和有状态计算</p>
<ul>
<li>无状态计算：在任何节点上都可运行，很适合细粒度的模拟和数据处理，如从图像或视频中提取特征。</li>
<li>有状态计算，非常适合实现参数服务器(parameter server)，对GPU支持的数据进行重复计算，或运行不暴露其状态的第三方模拟器。</li>
</ul>
</li>
<li><p>动态执行</p>
<ul>
<li>计算完成的顺序并不总是事先知道的。</li>
<li>计算的结果可以决定未来的计算。</li>
</ul>
</li>
<li><p>高吞吐量</p>
<ul>
<li>为了在大型集群中实现较高的利用率，框架必须每秒能处理数百万的任务。</li>
</ul>
</li>
<li><p>通用性</p>
<ul>
<li>能够与现有的模拟器和深度学习框架无缝集成。</li>
</ul>
</li>
</ul>
<h3 id="Deficiencies"><a href="#Deficiencies" class="headerlink" title="Deficiencies"></a>Deficiencies</h3><p>RL要求Training、Serving和Simulation必须紧密耦合在一个应用程序中，且三者有严格的延迟要求。但目前没有任何框架能支持。</p>
<ul>
<li>MapReduce、Apache Spark、Dryad等批量同步并行系统(Bulk-synchronous parallel systems)不支持细粒度模拟(fine-grained simulation)或策略服务(policy serving)。</li>
<li>CIEL、Dask等任务并行系统(Task-parallel systems)和Naiad、Storm等流媒体系统(streaming systems)几乎不支持分布式的训练和服务(distributing training and serving)</li>
<li>TensorFlow和MXNet等分布式深度学习框架不支持模拟(simulation)和服务(serving)。</li>
<li>TensorFlow Serving和Clipper等模型服务系统不支持训练(training)和模拟(simulation)。</li>
</ul>
<p>也许在理论上可以直接缝合多个专门的框架以提供整体功能，但在实践中，系统间由此产生的数据移动和延迟会令人望而却步。</p>
<p>如果为专门的RL应用程序构建一次性的系统(one-off systems)，会给分布式应用程序的开发带来巨大的系统工程负担，因为基本把系统层需要处理的问题推到了应用层。</p>
<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><h3 id="Programming-and-Computation-Model"><a href="#Programming-and-Computation-Model" class="headerlink" title="Programming and Computation Model"></a>Programming and Computation Model</h3><p>Ray实现了一个动态任务图计算模型(dynamic task graph computation model)，将应用程序建模为一个在执行过程中不断变化的依赖性任务图。在此基础上，提供了actor和task-parallel的编程抽象。</p>
<h4 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h4><p>在Ray中有两种编程模型：task和actor</p>
<ul>
<li><p>task：表示在无状态worker上执行一个remote函数。当调用一个remote函数的时候，会立即返回表示task结果的future(可以由<code>ray.get()</code>API获取)。也可以作为参数传递给其他remote函数，而无需等待结果。</p>
<ul>
<li>由于是无状态的，所以输出完全由输入决定。</li>
<li>相当于C/C++中的函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Running a Task</span></span><br><span class="line"><span class="comment"># Define the square task.</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch four parallel square tasks.</span></span><br><span class="line">futures = [square.remote(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve results</span></span><br><span class="line"><span class="built_in">print</span>(ray.get(futures))</span><br><span class="line"><span class="comment"># -&gt;[0, 1, 4, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>actor：表示有状态的计算模型，每个actor都公开了其可以被远程调用并连续执行的方法(这些方法类似于task，不同之处是这些方法在有状态worker上执行)。actor的句柄可以传递给其他的actor或者task，使它们也能够调用该actor上的方法。</p>
<ul>
<li>相当于C/C++中的类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling an Actor</span></span><br><span class="line"><span class="comment"># Define the Counter actor.</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.i += value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Counter actor.</span></span><br><span class="line">c = Counter.remote()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Submit calls to the actor. These calls run asynchronously but in</span></span><br><span class="line"><span class="comment"># submission order on the remote actor process.</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    c.incr.remote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve final actor state.</span></span><br><span class="line"><span class="built_in">print</span>(ray.get(c.get.remote()))</span><br><span class="line"><span class="comment"># -&gt; 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两者主要区别如表2所示：</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/17.png" style="zoom:50%;" /></p>
<p>为了满足异构性和灵活性的需求，用三种方式增强API：</p>
<ul>
<li>为了处理具有不同持续时间的并发任务，引入<code>ray.wait()</code>，等待前k个可用结果，而不是像<code>ray.get()</code>等待所有的结果。</li>
<li>为了处理资源异构任务，Ray使开发人员能够指定资源需求(在定义task和actor的时候指定)，以便Ray调度器可以高效管理资源。</li>
<li>为了提高灵活性，启用了嵌套的remote函数，意味着remote函数可以调用其他remote函数。对于实现高可扩展性也是至关重要的，因为它允许多个进程以分布式方式调用remote函数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2.png" style="zoom:50%;" /></p>
<div style="page-break-after: always;"></div>

<h4 id="Computation-Model"><a href="#Computation-Model" class="headerlink" title="Computation Model"></a>Computation Model</h4><p>Ray采用了动态任务图计算模型。当remote函数与actor方法的输入可用时，系统会自动触发它们的执行。其构建方式可以从下面图3和图4实例得知：</p>
<p><center class = "half">
  <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/4.png" width="49%"/>
  <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/3.png" width="50%"/>
</center></p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>如图5所示，Ray的架构设计分为两层：</p>
<ul>
<li>提供API的应用层。</li>
<li>提供高扩展性和容错的系统层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/22.png" style="zoom: 40%;" /></p>
<h4 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h4><p>Ray的应用层采用传统的driver-worker模式进行组织：</p>
<ul>
<li>driver：运行用户程序的进程。</li>
<li>worker：一个无状态的进程，用于执行由driver或另一个worker调度的task(remote函数)。它会自动启动，并由系统曾分配任务。</li>
<li>actor：一个有状态的进程，只执行它公开的方法。相当于worker或driver的显式实例化。<ul>
<li>方法是串行执行的，且每个方法都依赖于前一个方法执行所产生的状态。</li>
</ul>
</li>
</ul>
<h4 id="System-Layer"><a href="#System-Layer" class="headerlink" title="System Layer"></a>System Layer</h4><p>系统层包括三个主要的组件：所有的组件都具备水平可扩展性和容错性。</p>
<ul>
<li><p>全局控制存储(global control store，GCS)</p>
<ul>
<li>负责维护系统的整个控制状态，核心是具有发布订阅(pub-sub)功能的KV(key-value)存储。<ul>
<li>每条存储的数据都会采用一条随机生成的数据作为ID，利用ID作为分片键将数据分散到多个GCS分片中。由于GCS也是分布式的，等同于一个分布式的redis集群加上一个统一入口，分片提供了扩展能力。并且每个分片都进行了链复制(chain-replicated)以保证容错。</li>
</ul>
</li>
<li>GCS显著简化了Ray的总体设计，使得系统中的每个节点(除了GCS节点)都是无状态的。<ul>
<li>实现了持久脉络存储(durable lineage storage)与其他系统组件的解耦。所有的节点在故障时只需重新启动并从GCS读取存储的脉络(lineage)即可恢复。</li>
<li>将对象元数据(object metadata)存储在GCS，而不是全局调度器中，实现任务调度和数据传输的解耦，最大限度减少任务调度的开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>自下而上的分布式调度器(bottom-up distributed scheduler，DS)</p>
<ul>
<li><p>设计了一个由全局调度器和每个节点上的本地调度器组成的两级层次调度器。</p>
<ul>
<li>都使用事件驱动的单线程进程(event-driven singlet-hreaded process)实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/19.png" style="zoom:50%;" /></p>
</li>
<li><p>本地调度器(local scheduler)</p>
<ul>
<li>为了避免全局调度器过载，在节点上创建的task首先提交到节点的本地调度器。自下而上的意思便是首先在本地尝试调度task。</li>
<li>如果节点过载(本地task队列超过了预定义的阈值)，或者不能满足task的需求(例如缺乏GPU)，本地调度器将决定不在本地调度task，而将其转发给全局调度器。</li>
</ul>
</li>
<li><p>全局调度器(global scheduler)</p>
<ul>
<li>考虑每个节点的负载和task的约束条件做出调度决定。更确切的说，全局调度器确定有足够的任务所要求类型的资源的节点集，并在这些节点中选择那个具有最低估计等待时间的节点。<ul>
<li>最低估计等待时间(lowest estimated waiting time)为以下两项之和：<ul>
<li>task在该节点排队的估计时间(task队列大小*平均task执行时间)。</li>
<li>task的远程输入的估计传输时间(远程输入的总大小除以平均带宽)。</li>
</ul>
</li>
</ul>
</li>
<li>全局调度器通过心跳(heartbeats)获取每个节点的队列大小和资源的可用性。</li>
<li>全局调度器使用简单的指数平均(simple exponential averaging)计算平均task执行时间和平均传输带宽。</li>
<li>全局调度器实际也是分布式的。如果全局调度器成为了瓶颈，可以通过GCS实例化更多的共享相同信息的调度器副本，使得调度器架构具有很高的可扩展性。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存中的分布式对象存储(In-Memory distributed object store，DOS)</p>
<ul>
<li>为了最小化task的延迟，实现了一个基于内存的分布式存储系统，用于存储每个task的输入和输出，或者无状态的计算结果。<ul>
<li>Ray中的节点在启动时，默认会从机器的物理内存占据一部分作为对象存储。</li>
<li>对象存储直接采用Apache Arrow数据格式。</li>
</ul>
</li>
<li>每个节点通过共享内存进行对象存储：<ul>
<li>如果本地资源能够满足，则允许在同一节点上运行的不同task之间进行零拷贝的数据共享。</li>
<li>对象存储仅限于不可变的数据，无需更新对象。</li>
<li>如果task的输入不是来自本地，则在执行之前DOS会将输入复制到本地的对象存储中。task的输出也会写入本地的对象存储。<ul>
<li>复制消除了由热数据对象引起的潜在瓶颈(不需要多次通信传输相同对象)。内存不够时，使用LRU机制将部分数据换出内存，写入磁盘。</li>
<li>task只需要从本地内存读取数据或像本地内存写入数据(应用层)，因此最大限度地缩短了任务的执行时间，但也增加了计算绑定工作负载的吞吐量。</li>
</ul>
</li>
<li>当节点出现故障时，Ray通过重启节点运行re-execution进行恢复，在初始执行期间，存储在GCS中的脉络会追踪无状态的task和有状态的actor，并使用前者重构重启节点存储中的对象。</li>
<li>对象存储不支持分布式对象，使用者可以在应用层去实现。</li>
</ul>
</li>
<li>为了在不同的对象存储之间传输大型的对象，将对象分割到多个TCP连接中。</li>
</ul>
</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Ray是一个活跃的开源项目(40k代码)，与Python环境完全集成，只需要执行以下指令即可轻松安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install Ray</span><br></pre></td></tr></table></figure>
<div style="page-break-after: always;"></div>

<h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><p>下面展示Ray是如何运行端到端的工作的：以将两个对象(可以是标量或者矩阵)<code>a</code>和<code>b</code>相加，并返回结果<code>c</code>为例。</p>
<p>图a表示的是driver程序调用$add.remote(a, b)$的具体步骤，其中<code>a</code>和<code>b</code>分别存储在节点<code>N1</code>和<code>N2</code>。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/20.png" style="zoom:50%;" /></p>
<ol>
<li>remote函数$add()$在初始化时自动注册到GCS，并分发给系统中的每个worker。</li>
<li>driver程序将$add(a,b)$提交给<code>N1</code>的本地调度器。</li>
<li><code>N1</code>的本地调度器在发现输入<code>b</code>不在本地，不满足运行条件，便将$add(a,b)$转发给全局调度器。</li>
<li>全局调度器在GCS中查找$add(a,b)$的参数位置。</li>
<li>全局调度器决定在存储参数<code>b</code>的<code>N2</code>上运行$add(a,b)$。</li>
<li><code>N2</code>的本地调度器检查本地的对象存储是否包含$add(a,b)$的参数。</li>
<li>由于<code>N2</code>的本地存储没有对象<code>a</code>，且全局调度器已经指定由其完成该task，于是它在GCS中查找对象<code>a</code>的位置。</li>
<li><code>N2</code>得知对象<code>a</code>存储在<code>N1</code>，<code>N2</code>的对象存储在本地复制<code>N1</code>中的对象<code>a</code>。</li>
<li>现在$add()$的所有参数都存储在<code>N2</code>本地，<code>N2</code>的本地调度器在本地worker处调用$add()$。</li>
<li>$add()$通过共享内存访问参数。</li>
</ol>
<p>图b表示的是在<code>N1</code>执行$ray.get()$获得在<code>N2</code>执行的$add()$所返回值的具体步骤：</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/21.png" style="zoom:50%;" /></p>
<ol>
<li><code>N1</code>调用$ray.get(id_c)$时，driver程序使用$add()$返回的<code>future</code>检查本地对象存储中的值<code>c</code>。</li>
<li>由于<code>N1</code>本地对象存储没有存储<code>c</code>，<code>N1</code>在GCS中查找<code>c</code>的位置。此时GCS中并没有<code>c</code>的条目，因为<code>c</code>还未被创建。因此<code>N1</code>的对象存储空间向GCS中的对象表注册一个回调，该回调在<code>c</code>的条目被创建时触发。</li>
<li>当<code>N2</code>中的worker执行完$add()$后，将结果<code>c</code>存储在<code>N2</code>的本地对象存储中。</li>
<li><code>N2</code>的本地存储将对象<code>c</code>的条目添加到GCS中。</li>
<li>GCS创建对象<code>c</code>的条目，并由此触发了<code>N1</code>的对象存储所注册的回调。</li>
<li><code>N1</code>的本地存储从<code>N2</code>的本地存储复制对象<code>c</code>。</li>
<li><code>N1</code>本地存储将对象<code>c</code>返回到$ray.get()$，完成了task。</li>
</ol>
<div style="page-break-after: always;"></div>

<h2 id="Advantages-and-Disadvantages"><a href="#Advantages-and-Disadvantages" class="headerlink" title="Advantages and Disadvantages"></a>Advantages and Disadvantages</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul>
<li>Ray设计和构建了第一个联合了训练、模拟和服务的分布式框架，能够满足新型人工智能应用对框架的各种需求。<ul>
<li>Ray在只考虑训练、模拟或服务的单独场景中拥有接近甚至超过专门系统的性能表现。</li>
<li>在Ray上实现的需要训练、模拟和服务紧密耦合的强化学习算法在性能上接近甚至超过专门为该算法设计的系统。</li>
</ul>
</li>
<li>Ray在单个动态任务图中统一了task parallel和actor programming models，采用了由全局控制存储GCS和自下而上的分布式调度器构成的架构，使得：<ul>
<li>Ray允许开发者用task对模拟actor产生的输出进行昂贵的后续处理，且Ray能够通过60个节点每秒完成100万个task，意味着可以实现Billion级别的大规模仿真。</li>
<li>Ray的GCS和分布式调度器能够水平扩展系统以支持高吞吐量的细粒度任务，同时保持容错性和低延迟任务调度。</li>
</ul>
</li>
<li>Ray非常的灵活，并没有绑定成某一种特定应用场景或计算模式的解决方案，是一个真正的原生分布式框架。<ul>
<li>在上层抽象出不同的计算模式，包括流处理、批处理、图计算、机器学习、深度学习、强化学习等。但Ray本身不提供具体计算的功能，可结合TensorFLow或者Pytorch计算框架使用。</li>
<li>在下层提供分布式服务，解决调度问题、容错问题、资源恢复问题等。通过简单的硬件资源参数设置，就能让计算运行在不同的异构硬件上。</li>
</ul>
</li>
<li>Ray的API简单高效，使得编程模式非常友好。能非常容易实现先进的RL算法。</li>
</ul>
<h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ul>
<li>Ray的task是无副作用的，而对于GPU，开发者并不只想用来运行任务、获取数据和存储数据，希望能够把状态实际保留在GPU上，导致任务不能保持无副作用，令提供容错能力变得困难。</li>
<li>Ray的actor只适用于顺序性的单独线程，在使用多线程的情况下难以提供容错性。</li>
<li>Ray缺少系统隔离能力，一个有害的actor实现可以轻易独占当前的CPU资源。</li>
<li>由于Ray的分布式节点上会有不止一个线程，需要频繁进行切换，其调度和上下文切换的开销会比理论上的结果更大。表现在当任务较多时，容易卡死。</li>
<li>Ray要在不完全了解计算图的情况下做出调度决策、优化可能需要更复杂的运行时分析。</li>
<li>Ray使用对象(object)的作用域来管理对象的生命周期，这意味着没有作用域的对象将会有无限的生命周期。Ray缺乏垃圾回收策略，无法约束GCS中的存储成本。使得在数据密集时容易出现严重的数据膨胀。</li>
<li>深度学习框架像对待数据计算一样重视且全权管理数据搬运，不能把数据搬运委托给更底层的机制以至于数据搬运隐式地在背后发生，这会丧失宝贵的确定性和可预测性，深度学习要求必须把数据搬运像计算一样作为算子显式的调度管理。但Ray通过对象存储和RPC机制实现了一套“自动”的数据搬运机制，反而可能会帮倒忙。</li>
<li>Ray主要使用gRPC通信，手段较为单一，缺乏集群通信等的支持。通信功能有待增强。</li>
<li>Ray的API和功能不够丰富，需要更高级别的为调度决策提供信息的原语和库。</li>
<li>Ray是基于Python实现的，Python主要的应用场景在数据科学(数据分析/AI/科学计算)和运维两个领域。企业应用主要还是使用Java，所以Ray好像很少有企业应用的案例。因此从市场前景的角度，Ray还离通用框架有一定距离。</li>
</ul>
<div style="page-break-after: always;"></div>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>通过对本文的学习，主要有以下收获：</p>
<ul>
<li>对新一代的分布式强化学习框架Ray有了大致的了解。</li>
<li>分布式系统中如果丢失了一些数据，可以根据保留的最初创建该数据的任务链恢复数据。如果任务(task)是无副作用且确定性的，那么重新执行将获得同样的输出。依此可以实现容错性模型。</li>
<li>集中控制状态将是未来分布式系统的一个关键设计组件。它既能简化边缘端设备的程序设计，又方便对各个边缘设备进行监控调试，在边缘节点故障时能通过集中控制状态组件迅速恢复。</li>
<li>通过将调度器划分为全局和本地两层，并将全局调度器与数据存储解耦，能够最大限度减少任务调度的开销。</li>
<li>分布式系统中的组件也可以是分布式的，这使得系统具有非常强大的扩展性。</li>
<li>复杂的算法能通过简单的API实现。</li>
<li>对开源的第三方著名项目要保持继承发扬的态度，既不应抗拒，也不应依赖。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://arxiv.org/pdf/1712.05889v2">Ray: A Distributed Framework for Emerging AI Applications</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&amp;mid=2247486546&amp;idx=1&amp;sn=1f9578739d434f30afc2e90556685004&amp;chksm=fe418264c9360b72b75ceddcd1c413493c9dec3061fcaddab41e82db5363676580c7c39f5b05&amp;scene=21#wechat_redirect">Ion Stoica：做成Spark和Ray两个明星项目的秘笈</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/566982400">《Ray: A Distributed Framework for Emerging AI Applications》论文解读</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/446818362">Ray解读：从论文看架构</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/86658441">Ray: A Distributed Framework for Emerging AI App 笔记</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/681561996">Ray: A Distributed Framework for Emerging AI Applications 阅读笔记</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/507619560">Ray: A Distributed Framework for Emerging AI Applications 学习笔记</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/61818897">分布式框架Ray及RLlib简易理解</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/265485941">如何看UCBerkeley RISELab即将问世的Ray，replacement of Spark？</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/498342150">解读谷歌 Pathways 架构（二）：向前一步是 OneFlow</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Sia</title>
    <url>/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Sia/</url>
    <content><![CDATA[<h1 id="Sia-Heterogeneity-aware-goodput-optimized-ML-cluster-scheduling"><a href="#Sia-Heterogeneity-aware-goodput-optimized-ML-cluster-scheduling" class="headerlink" title="Sia: Heterogeneity-aware, goodput-optimized ML-cluster scheduling"></a>Sia: Heterogeneity-aware, goodput-optimized ML-cluster scheduling</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文提出了一个分布式调度器——Sia，能够为弹性的资源自适应job高效地分配异构的深度学习集群资源，是一个支持混合(异构)并行Job弹性地扩展的集群调度器</p>
<ul>
<li>Sia提出了一个新的调度公式(scheduling formulation)来扩大搜索空间的大小搜索集群资源，合理地配置运行job的GPU类型和GPU数量。</li>
<li>Sia提出了一个低分析开销(low-profiling-overhead)的方法为每个新的job引导(bootstrapping)吞吐量模型(throughput models)，用于评估可能的资源分配配置。</li>
</ul>
<p>实验结果表明，Sia的性能优于目前最先进的调度器，至少可以扩展到大小为2000个GPU的分布式集群，为每个job提供了更好的公平性，并且对调度器参数的初始化设置不太敏感</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>大小可变的深度学习集群(DL clusters)被多个用户共享为多个不同的问题训练各自的深度学习模型。</p>
<ul>
<li>深度学习集群是由混合类型的GPU构成的</li>
<li>调度器用来为job分配集群的资源</li>
</ul>
<h3 id="Sia"><a href="#Sia" class="headerlink" title="Sia"></a>Sia</h3><p>Sia是一个为自适应资源(resource-adaptive)的DL训练job和异构资源设计的调度器</p>
<ul>
<li>在每个调度轮次，Sia会考虑为当前job分配GPU数量和类型的可能性，评估这些job的goodput(包括了job的重新分配大小的花费)，选择在下一个轮次运行的最好的集群资源分配</li>
<li>要实现非常有挑战性，有以上两个原因：<ul>
<li>对于一个可变大小的集群来说，搜索空间很大</li>
<li>不同的job对于不同的GPU类型和不同的GPU数量的性能反应不同，因为不同类型的GPU本身就具有不同的计算网络带宽比。GPU的多种类型，不同数量，可以有不同的组合，因此要遍历所有的分配情况是不现实的，昂贵且耗时</li>
</ul>
</li>
<li>Sia解决上述挑战的方法是: <ul>
<li>提出一个新的求解公式(solver formulation)以处理规模问题<ul>
<li>Sia的新ILP公式: 即使负载(load)和集群(cluster)大小增加，能够有效找到所有待处理job的GPU类型、GPU计数和数据批量大小的配置方式</li>
</ul>
</li>
<li>提出一个新方法在线学习(online-learning)每个job，每种GPU类型的吞吐量模型(throughput model)<ul>
<li>Sia的吞吐量模型是关于GPU类型、GPU数量和数据批量大小的函数，能够避免大规模的分析(大规模分析可能会使得优秀的调度算法反而性能变坏)，实际就是处理批量大小数据花费的时间</li>
<li>因为Sia对于每种GPU类型仅仅使用一个最小规模的配置文件(开销就低了)引导每个新job的吞吐量模型，然后再进行缩放/投影(scaling/projection)，最后在job运行的时候动态优化吞吐模型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul>
<li>揭示目前最先进的调度器的不足之处，指出研究方向: 异构性(heterogeneity)和弹性(elastic)</li>
<li>提出第一个能够弹性扩展，具有混合类型异构的，并行job的集群(cluster)调度器Sia<ul>
<li>提出新的ILP公式，解决了异构GPU类型和job自适应的复合复杂性: 要兼顾GPU的不同类型、GPU的不同数量和不同的数据批量大小</li>
<li>提出新的吞吐量模型，预先观察几个小批量在每个GPU类型的运行结果作为引导(bootstrap)，然后随着job按Sia的优化配置运行而且在运行过程中快速有效地改进</li>
</ul>
</li>
<li>表明Sia在其目标领域中与最先进的调度器相匹配，并且在结合其域的复杂性方面优于它们，结果还显示了Sia的可扩展性(scalability)、公平性(fairness)和参数化鲁棒性(parameterization robustness)</li>
</ul>
<h2 id="DL-cluster-scheduling"><a href="#DL-cluster-scheduling" class="headerlink" title="DL cluster scheduling"></a>DL cluster scheduling</h2><p>深度学习(DL)训练job是以迭代的方式在多个周期根据数据集上的数据训练DNN模型。对于每个迭代周期中的每个小批量(minibatch)，优化器会根据小批量样本计算损失函数，以最小化损失函数为目的更新模型的参数</p>
<ul>
<li>对于耗时长的训练(如果不是整个训练)，minibatch的大小通常是固定的，大多数的DL jobs总共花费固定且可预测的时间处理一个minibatch</li>
<li>jobs通常也是可抢占的，可以在处理任何minibatch后检查job的状态(包括模型和优化器的状态)，从checkpoint恢复jobs，而不会损失太多的进度</li>
<li>易于扩展，因为梯度计算可以在单个节点上的多个GPU或多个节点进行并行化</li>
</ul>
<h3 id="Data-Parallelism"><a href="#Data-Parallelism" class="headerlink" title="Data Parallelism"></a>Data Parallelism</h3><p>大多数的training job使用的是同步的数据并行(synchronous data parallelism)，即给定一组GPU，每个GPU上都会运行一个完整的模型，而不同的GPU运行例如all-reduce算法根据不同的minibatch(与GPU本身的内存大小相关)的数据计算梯度，然后更新各自GPU上的模型的参数</p>
<ul>
<li>对于每个小批量的数据，梯度计算阶段在各个GPU内部独立完成，而在reduce阶段进行同步</li>
</ul>
<p>给定的DL job的扩展程度取决于job的特性</p>
<ul>
<li>计算强度</li>
<li>模型参数的个数</li>
<li>GPU的性能</li>
<li>连接GPU的内部网络？(inter-GPU network, 和通信相关？)</li>
</ul>
<h3 id="Model-Parallelism"><a href="#Model-Parallelism" class="headerlink" title="Model Parallelism"></a>Model Parallelism</h3><p>在被训练的模型太大，一个GPU的内存无法容纳的时候，可以把模型分割到几个GPU上运行</p>
<ul>
<li>流水线(Pipeline Model Parallelism, PMP)</li>
<li>Tensor Model Parallelism(TMP)</li>
</ul>
<h3 id="弹性和资源自适应的DL-jobs"><a href="#弹性和资源自适应的DL-jobs" class="headerlink" title="弹性和资源自适应的DL jobs"></a>弹性和资源自适应的DL jobs</h3><p>数据并行的jobs可以随着时间的推移弹性地重新调整整体batch_size的大小，通过checkpoint保留上下文，然后在不同数量的GPU上重新启动。(例如在更多的GPU上训练以扩大整体bacth_size)<br>数据并行的实现也可以不重新启动，通过拷贝原始配置进行缩放</p>
<h3 id="异构资源"><a href="#异构资源" class="headerlink" title="异构资源"></a>异构资源</h3><p>GPU类型有很多种，在内存大小、计算和通信性能方面不同。<br>DL集群通常会包含多种GPU。</p>
<ul>
<li>因为集群是随着时间的推移进行部署和增长的，每次购买添加的新硬件时都可以选择最具成本效益的选项。</li>
</ul>
<h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>DL jobs作为请求提交到共享的集群中，调度器为job分配资源以实现集群范围的目标。目前许多调度器只允许指定固定数量的相同类型GPU的请求，忽略了弹性、资源自适应和异构性。</p>
<h3 id="异构感知-Heterogeneity-aware-的调度器"><a href="#异构感知-Heterogeneity-aware-的调度器" class="headerlink" title="异构感知(Heterogeneity-aware)的调度器"></a>异构感知(Heterogeneity-aware)的调度器</h3><p>考虑集群的不同GPU类型，但现有的调度器只适用于刚性(rigid)job，无资源的自适应</p>
<ul>
<li>rigid job必须使用用户指定数量的GPU运行，不允许弹性缩放，也不能自适应地分配资源(也就是非动态的分配)，做其他调整<br>其中的代表是Gavel，使用一个可以扩展到大集群的快速线性规划公式。但不支持job的自适应，只在job提交者指定的小批量大小和GPU数量的情况下优化分配的GPU的类型。</li>
<li>如果批量太小，这种方法可能会导致频繁更新、更强大的GPU利用率不足等问题</li>
<li>当集群里的job数量拥塞时，会频繁切换运行的job，使得将GPU时间浪费在checkpoint的恢复操作上<br>这是因为Gavel用的是填充有<code>(job_id, GPU_type)</code>对的吞吐量矩阵(throughput matrix)表示调度选项，如果简单地扩展条目为<code>(job_id, GPU_type, num_GPUs, minibatch_size)</code>，有个问题:</li>
<li>求解吞吐量矩阵的非零解，需要对每个job进行大量多余分析，优化程序会很大，无法迅速解决问题</li>
</ul>
<h3 id="自适应感知-Adaptivity-aware-的调度器"><a href="#自适应感知-Adaptivity-aware-的调度器" class="headerlink" title="自适应感知(Adaptivity-aware)的调度器"></a>自适应感知(Adaptivity-aware)的调度器</h3><p>考虑job在不同数量的GPU上执行(非刚性，调整批量大小batch_size)，但这些GPU都是同一类型的，不考虑异构性。<br>其中的代表是Pollux，使用每个Job的吞吐量模型为其设置GPU数量和批量大小，并根据更新的job的行为和job的队列信息在每个调度周期重新考虑所有的分配(弹性分配，避免未使用或过度使用GPU资源)。</p>
<ul>
<li>每个作业的goodput模型由两个组件组成<ul>
<li>一个是统计效率模型(基于梯度噪声标度Gradient Noise Scale的每个样本的训练进度，训练每个样本的速度)，批量大小的函数</li>
<li>一个是吞吐量模型(每秒处理的样本数量)，GPU数量和批量大小的函数。<ul>
<li>通过放大、测量每个尝试的GPU数量计数并为其他计数插值，可以了解每个job如何随着GPU数量缩放</li>
<li>每个job模型采用遗传算法搜索所有当前job的资源分配空间和相应的批量大小，通过公平性地加权以最大化集群范围内的总产出<ul>
<li>遗传算法对于同构的GPU集群的扩展都非常困难，何况对异构GPU集群的扩展</li>
<li>因为对于每个<code>(job, GPU_count)</code>对，要考虑将此作业放置在所有节点的可能性。而可能的解的数量和节点数量及节点内GPU的数量呈指数关系。(1000多个GPU的集群，遗传算法需要几十分钟才能完成)</li>
</ul>
</li>
<li>但是无预分析(no-pre-profiling)的吞吐量模型阻碍了GPU的异构性</li>
</ul>
</li>
</ul>
</li>
<li>在同构系统中，Pollux针对整个资源空间进行优化，你每个job的可选情况复杂度为$O(N^R)$<ul>
<li>假设一个job需要R个GPU，考虑全局情况，则每个GPU都有N个节点选择。所以一共为$O(N^R)$</li>
</ul>
</li>
</ul>
<h3 id="同构集群上刚性job的调度器"><a href="#同构集群上刚性job的调度器" class="headerlink" title="同构集群上刚性job的调度器"></a>同构集群上刚性job的调度器</h3><p>要求job的提交者为每个job指定GPU数量和相关配置，调度器不会根据当前负载或当前job的可扩展性/运行效率调整分配的GPU数量，也不会考虑GPU类型的差异(假设所有GPU都是相同种类)。效率较低。<br>现在有些能够调整GPU数量提高GPU利用率，但不会同时调整批量大小和GPU数量、类型。代表性的是Shockwave</p>
<h3 id="非集群调度器的并行优化器"><a href="#非集群调度器的并行优化器" class="headerlink" title="非集群调度器的并行优化器"></a>非集群调度器的并行优化器</h3><p>为单独的job孤立地考虑并选择配置，而非集群调度器，即只考虑个体job运行效率，而不考虑整体集群的效率</p>
<h2 id="Sia-Design-and-Implementation"><a href="#Sia-Design-and-Implementation" class="headerlink" title="Sia Design and Implementation"></a>Sia Design and Implementation</h2><p>Sia是一个抢占式的基于轮次的调度器，优化一组job的资源分配，以最大限度地提高集群范围内的goodput指标(该指标包含统计效率模型和吞吐量模型，具体见<a href="#自适应感知adaptivity-aware的调度器">自适应感知(Adaptivity-aware)的调度器</a>)。使用checkpoint-restore的抢占机制优化自适应的job</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Sia%20Process.png" alt="img"></p>
<ul>
<li>用户提交一个job给Sia的队列Queue，记为J</li>
<li>Sia的Profiler宣告本次执行的最大的批量大小(max_bsz)和最大的GPU数量(max_ngpus)。接着配置J使用小批量数据分别在各个类型的一块GPU运行</li>
<li>Sia的Goodput Estimator引导一个吞吐量模型评估J在各个类型的一块GPU上运行的性能(评估用的是statistical efficiency model和throughput model)<ul>
<li>Goodput Estimator为GPU内存容量，互连的速度和吞吐量进行建模</li>
</ul>
</li>
<li>J会一直停留在队列Queue中，直到Sia分配一些GPU给它</li>
<li>Sia的Policy根据来自Goodput Estimator的goodput评估值，在集群的job之间找到最佳的集群资源划分方案</li>
<li>Sia的Placer根据Policy给出的配置方案将对应的资源分配给对应的job，并尝试减少由于资源碎片化而导致的不必要的job的迁移<ul>
<li>将分配分为策略和实际两步进行，能够限制分配的放置空间，也就是减少碎片化。需要遵循三条规则：<ul>
<li>部分节点(这些节点被请求的GPU数量少于其拥有的最大GPU数量?)的分配不得在两个节点上拆分(即节点本身满足资源要求，就不能强行拆分到不同节点)</li>
<li>整个节点分配必须占用整个节点(也是不能随便拆分)</li>
<li>如果不存在满足以上两个规则的位置，则拿下一个job再重启继续尝试分配(这种情况非常罕见，通常不超过3次)</li>
</ul>
</li>
</ul>
</li>
<li>Sia的Adaptive Executors负责运行job，支持:<ul>
<li>透明的checkpoint-restore机制，用于低开销的job抢占和资源扩展</li>
<li>自适应的批量大小，以最大化统计效率。当统计效率要求比GPU内存有限的支持更大的批量大小时，会使用梯度累计算法(gradient accumulation)</li>
<li>频繁报告当前分配下模型的梯度和吞吐量统计数据(默认为30s一次)</li>
<li>每个job最开始是在一块GPU上运行的，然后通过每个调度轮扩大为在2倍数量的GPU上运行(当然有最低运行要求的job，会从要求的最小GPU数量开始运行扩大)。每个job也可能被缩小规模到最低运行要求以便在集群中job拥塞的时候容纳更多的joib</li>
</ul>
</li>
<li>J在Adaptive Executors开始执行后，Goodput Estimator会使用Adaptive Executors报告J的梯度和吞吐量统计数据更新J在当前资源配置下的goodput model</li>
<li>在下一轮调度前，Sia的Policy会根据Goodput Estimator反馈的更新后J在所有GPU类型上的goodput估计值继续寻找最佳的集群资源划分方案</li>
<li>不断循环，直到完成或终止</li>
</ul>
<h3 id="Bootstrapping-of-throughput-models"><a href="#Bootstrapping-of-throughput-models" class="headerlink" title="Bootstrapping of throughput models"></a>Bootstrapping of throughput models</h3><p>为每种类型的GPU构建每个job的吞吐量模型(作为GPU数量和批量大小的函数)的传统方法是运行每种GPU的多GPU分配方案，收集计算和通信时间。这种分析方法的开销随着GPU类型数量和每个节点拥有的GPU的数量都是线性增长的<br>Sia则以最少的分析信息开始，根据观察到的分配进行改进。对于每个job，Sia为每种GPU类型学习一个吞吐量模型和为job学习一个统计效率模型(批量大小的函数)。Sia首先分配各种类型的GPU给最低数量要求给job($\geq 1$)，从小的批量大小开始，不断提高批量大小直到达到GPU内存限制(通常是10倍)。每个类型的GPU在这个过程花费$\lt 20$ GPU seconds。就能获得：</p>
<ul>
<li>不同的GPU类型和批量大小组合的计算时间</li>
<li>比较不同GPU类型的计算时间<br>假设计算时间和GPU数量增长是独立的，无关系的，因为采用的是采用all-reduce的数据并行技术。所以整个集群的时间分为计算时间和通信时间，计算时间只和单个GPU的计算时间相关</li>
</ul>
<p>Sia会为某种GPU类型在2个GPU上运行，然后计算吞吐量模型结果。与单个GPU上运行的吞吐量模型结果的两倍的差值便能得到耗费在通信的时间<br>根据在该类型GPU上测得的通信时间可以给其他类型GPU利用，因为假设是通信时间与计算时间无关，即通信时间与GPU类型无关。也就是说，已知N个某类型GPU的表现，则可以根据不同类型的GPU在单个GPU上的表现的比值来估计N个其他类型GPU的表现(实验也佐证了可用性)，用一个公式表示：</p>
<ul>
<li>$est-xput_B(N) = \frac{xput_B(1)}{xput_A(1)}*xput_A(N)$<br>不过需要注意的是，这只是对没有运行的GPU类型的粗略的估计，如果已经运行了某类型的GPU，则应该使用在线配置(online profiling)的结果准确预测通信时间</li>
</ul>
<h3 id="Configurations"><a href="#Configurations" class="headerlink" title="Configurations"></a>Configurations</h3><p>配置由一系列的资源组成，如CPU, GPU, Network, etc，可以表示为<code>(n, r, t)</code>，其中<code>n</code>表示节点数量，<code>r</code>表示资源数量，<code>t</code>表示资源类型。</p>
<ul>
<li>例如<code>(2, 16, T4)</code>表示的是2个节点包含16个T4 GPU<br>为了减少资源争用，避免分布式作业共享节点。配置集合可以划分为两部分：</li>
<li>单节点分配集合: 不会跨节点分配资源，${(1, 2^0, X), (1, 2^1, X), …, (1, R, X)}\bigcup\quad\leftarrow$ single-node<ul>
<li>该分配方式限制每次都分配一个节点内2的倍数的GPU，直到节点拥有的最多GPU数量$R$。如果$R$不是2的幂，则可以把$R$拆分成2的幂的和，即把一个物理节点拆分成多个虚拟节点</li>
</ul>
</li>
<li>多节点分配集合: 需要跨节点分配资源，${(2, 2R, X), …, (N, N\cdot R, X), n\in N}\quad\leftarrow$ multi-node<ul>
<li>该分配方式要求每个节点的GPU都必须完全被利用，即遵守第二条规则(详见<a href="#process">process</a>)<br>假设集群是同构的，Sia在优化配置过程中考虑的复杂度是$O(N+log_2R)$</li>
</ul>
</li>
<li>因为不需要考虑所有的情况。</li>
<li>假设一个job需要R个GPU，每个节点都能满足该要求，且Sia限制job不能在节点资源未得到完全利用的情况下跨越其他节点，则只需选定在哪个节点运行——有$N$种情况。</li>
<li>Sia从1个GPU开始，每个迭代轮次将分配的GPU数量翻倍，即共有$log_2R$种配置</li>
</ul>
<h3 id="Scheduler-objective"><a href="#Scheduler-objective" class="headerlink" title="Scheduler objective"></a>Scheduler objective</h3><h4 id="Valid-Configurations"><a href="#Valid-Configurations" class="headerlink" title="Valid Configurations"></a>Valid Configurations</h4><p>即可用的配置，可用于分配给设备的配置。具体可见<a href="#Configuration">Configuration</a>。在一个调度轮次，一个job要么不被分配资源，要么按照列举的可用配置分配资源</p>
<h4 id="Goodput-Estimation"><a href="#Goodput-Estimation" class="headerlink" title="Goodput Estimation"></a>Goodput Estimation</h4><p>定义了一个大小为$|J|\times|C|$(每个job的每种配置)的goodput矩阵$G$，$G_{ij}$表示的是$J_i$使用$c_j$给定配置的资源估计得到的goodput</p>
<ul>
<li>对于这个矩阵的每一行，即表示每一个job，可以直接对比矩阵的值来确定哪种配置更加优秀</li>
<li>但对于这个矩阵的每一列，即表示每一种配置，不可以直接对比矩阵的值来说明该配置更适合哪个job去运行(需要简单的行归一化)</li>
</ul>
<h4 id="Normalized-goodput-matrix"><a href="#Normalized-goodput-matrix" class="headerlink" title="Normalized goodput matrix"></a>Normalized goodput matrix</h4><p>对于最低GPU数量要求为$N_i^{min}$的$J_i$，有公式: </p>
<ul>
<li>$G<em>{ij}\leftarrow N_i^{min}\cdot\frac{G</em>{ij}}{min<em>jG</em>{ij}}$<ul>
<li>$min<em>jG</em>{ij}$: $J_i$所有配置的goodput估计值中的最小值</li>
</ul>
</li>
<li>即用矩阵每行最小值进行归一化，有两个好处：<ul>
<li>可以把$G$解释为$J$的效用矩阵(utility-matrix)，每一个元素的值都说明某种配置对某个job的效用</li>
<li>对于每种配置，可以比较其对每种job的效用<br>每个新运行的job都会为矩阵$G$添加一个新的行，每个已完成的job都会在矩阵$G$删除对应行。矩阵$G$只记录活跃的job，且其中的值也会随着goodput的变化而变化</li>
</ul>
</li>
</ul>
<h4 id="Scheduler-objective-1"><a href="#Scheduler-objective-1" class="headerlink" title="Scheduler objective"></a>Scheduler objective</h4><p>定义了一个大小与$G$相同的二进制矩阵$A$，其中$A_{ij}==1$表明下一轮次J_i选择的配置为$c_j$<br>Sia调度的目标是为每个job选择配置，使得所有job的归一化goodput之和最大</p>
<ul>
<li>不是每个job都挑选归一化goodput值最大是因为可能出现多对一的情况，但实际是一对一的<br>于是对Sia的调度目标建模得到：</li>
<li>$\displaystyle\max<em>A\sum</em>{i=1}^{|J|}(\sum<em>{j=1}^{|C|}A</em>{ij}\cdot G_{ij} + \lambda(1-\lVert A_i\rVert_1))$<ul>
<li>$\lVert v\rVert_1$表示相邻$v$的L1范式，即求和后的绝对值</li>
<li>这是一个二进制整数线性规划问题，有以下限制:<ul>
<li>每个job最多选择一种配置: $\lVert A_i\rVert \leq 1$</li>
<li>被分配的GPU数量不能超过对应类型GPU的可用数量</li>
</ul>
</li>
<li>外层的求和是对所有job选择的配置的goodput估计值求和，max说明目标把该求和最大化</li>
<li>内层对包含两个部分<ul>
<li>前者为一整行求和，由于$A$矩阵每一行最多只有一个非零值，因此实际是说明$J_i$选择的配置的goodput。</li>
<li>后者为惩罚项，当$J_i$不选择任何一种配置的时候，该项为非0，否则为0。惩罚项也许是负数，即对不分配资源做出惩罚，是减少调度器队列中的job的一种激励，使得Sia为集群中的每个job至少分配一个GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Restart-Factor-重启参数"><a href="#Restart-Factor-重启参数" class="headerlink" title="Restart Factor(重启参数)"></a>Restart Factor(重启参数)</h4><p>频繁地重新分配资源会带来频繁地重启，而频繁重启对性能有害，代价昂贵。<br>因此设置了一个重启参数$r_i$，用来评估是否要重启job(重新分配资源)</p>
<ul>
<li>$r_i=\frac{T_i-N_i\cdot S_i}{T_i+S_i}$<ul>
<li>$J_i$: job</li>
<li>$T_i$: job已经运行的时间</li>
<li>$S_i$: 每次浪费在重启操作上的GPU seconds</li>
<li>$N_i$: 先前已经重启过的次数(已经重启过的次数越多，再次重启的可能性就越低)<br>最好只在如果不重启(重新分配资源)会使得调度目标的goodput最佳值大幅度下降时，才会重启</li>
</ul>
</li>
</ul>
<h4 id="Balancing-goodput-with-fairness"><a href="#Balancing-goodput-with-fairness" class="headerlink" title="Balancing goodput with fairness"></a>Balancing goodput with fairness</h4><p>用一个参数$p$来平衡job的goodput。让每个job都能获得相对公平的资源分配。则加上重启参数$r_i$公式变为</p>
<ul>
<li>$\displaystyle\max<em>A\sum</em>{i=1}^{|J|}(\sum<em>{j=1}^{|C|}A</em>{ij}\cdot (r<em>i\cdot G</em>{ij})^p + \lambda(1-\lVert A_i\rVert_1))\quad p\gt 0$</li>
<li>$\displaystyle\min<em>A\sum</em>{i=1}^{|J|}(\sum<em>{j=1}^{|C|}A</em>{ij}\cdot (r<em>i\cdot G</em>{ij})^p + \lambda(1-\lVert A_i\rVert_1))\quad p\lt 0$</li>
<li>实验发现$p$在$-1.0~1.0$之间能够在获得稳定的公平性的同时对性能指标最小的负面影响，其中$p=-0.5$效果最好</li>
</ul>
<h4 id="Support-for-limited-adaptivity-支持有限制的自适应性"><a href="#Support-for-limited-adaptivity-支持有限制的自适应性" class="headerlink" title="Support for limited adaptivity(支持有限制的自适应性)"></a>Support for limited adaptivity(支持有限制的自适应性)</h4><p>大的数据规模使模型有高的吞吐量和使GPU有高利用率，但也可能导致训练模型的泛化误差(generalization gap)。因此Sia页支持对不同类型的job使用不同程度的自适应性。</p>
<ul>
<li>strong-scaling(强扩展) jobs: 固定的批量大小，但允许优化GPU数量和类型<ul>
<li>优化的目标函数公式: $\displaystyle\max<em>A\sum</em>{i=1}^{|J|}(\sum<em>{j=1}^{|C|}A</em>{ij}\cdot (r<em>i\cdot T</em>{ij})^p + \lambda(1-\lVert A_i\rVert_1))\quad p\gt 0$(因为对于固定的批量大小，throughput和goodput成正比，不用考虑统计效率)</li>
</ul>
</li>
<li>rigid(刚性) job: 固定的批量大小和GPU数量，只允许优化GPU类型<ul>
<li>优化的目标函数公式: $\displaystyle\max<em>B\sum</em>{i=1}^{|J<em>R|}(\sum</em>{g=1}^{|N<em>g|}B</em>{ig}\cdot (r<em>i\cdot T</em>{ig})^p + \lambda(1-\lVert B_{ig}\rVert_1))\quad p\gt 0$(固定了GPU数量，配置的方案只需要考虑GPU的类型)</li>
</ul>
</li>
</ul>
<h4 id="Preemption-and-reservation-抢占和预订"><a href="#Preemption-and-reservation-抢占和预订" class="headerlink" title="Preemption and reservation(抢占和预订)"></a>Preemption and reservation(抢占和预订)</h4><p>Sia假设所有的job都是抢占式的，但也支持一小部分的job是非抢占式的(只要它们的总需求能够得到满足)。在分配资源的时候，保证这些非抢占式的job被先分配资源，每一轮调度都要保证非抢占(在公式中为每个非抢占式的job加入限制项，促进资源分配给它们)。</p>
<p>如果DL训练job的资源分配发生改变，Sia只能在当前小批量处理完成后才抢占该作业进行重新分配(不会有正在进行的通信导致结果丢失等问题)</p>
<p>Reservation预定策略可以为设置了该策略的队列中的job预先保留一部分计算资源，不给其他job使用。原理和对非抢占式的处理相似</p>
<h4 id="Checkpoint-restore"><a href="#Checkpoint-restore" class="headerlink" title="Checkpoint-restore"></a>Checkpoint-restore</h4><p>Sia会在每一轮调度结束后，都会为最新的模型参数、数据加载器(数据采样器和迭代器的状态)和优化器的状态(如Adam的梯度统计数据)建立checkpoint，并存储在磁盘中<br>如果DL训练job的分配发生变化，则:</p>
<ul>
<li>在该轮调度结束完成checkpoint保存</li>
<li>释放分配给job的所有资源</li>
<li>在新的要分配的资源上，为每个GPU启动一个Adaptive Executors</li>
<li>从磁盘上的checkpoint在新分配的资源上恢复训练状态，继续模型训练</li>
</ul>
<p>checkpoint-restore还可以用于将job从故障中恢复，即在每个轮次出了故障，从上次的checkpoint重新恢复</p>
<h4 id="Support-for-other-parallelization-techniques-其他的并行技术"><a href="#Support-for-other-parallelization-techniques-其他的并行技术" class="headerlink" title="Support for other parallelization techniques(其他的并行技术)"></a>Support for other parallelization techniques(其他的并行技术)</h4><p>扩展Sia的吞吐量模型，使其支持使用流水线和数据并行的job，允许Sia调度拥有几十亿参数模型的job</p>
<ul>
<li>流水线并行属于模型并行，策略是把一个大模型拆分到多个GPU上。</li>
<li>数据并行用来扩展训练规模，即同一时间可以训练更多的数据</li>
</ul>
<p>假设模型的每个部分可以映射到$P$个GPU上($P\geq 1$)，有$N$个数据并行副本的job实际需要$N\times P$个GPU。因为每个数据并行副本都要在同一时间单独完整地过一遍模型，也就需要$N$个模型，而模型被拆分到了P个GPU上，所以一共需要$N\times P$个GPU<br>N条流水线上的副本会使用梯度all-reduce算法进行同步，完成一次训练迭代</p>
<ul>
<li>all-reduce实际目的是要汇总所有计算出来的梯度做个平均再分发给各个并行部分去更新各自参数继续训练</li>
</ul>
<p>假设给定mini-batch_size为$M$，表示一次迭代要处理的总的数据数量。给定micro-batch为$m$，表示每P个GPU(模型每个部分)一次迭代能处理的数据数量。</p>
<ul>
<li>则模型每一部分P个GPU上的副本都要在本地用$\frac{M}{mN}$个micro-batch计算梯度。<ul>
<li>数据并行，所以一个模型处理$\frac{M}{N}$的数据</li>
<li>模型并行，所以模型的每个组件(拥有$P$个GPU)需要处理$\frac{\frac{M}{N}}{m}$的数据</li>
</ul>
</li>
</ul>
<p>现在的混合并行优化器(hybrid-parallel, 即混合了模型并行和数据并行)非常耗时，这属于未来可以研究的方向</p>
<h4 id="Scheduling-other-workload-types-调度其他类型的工作负载"><a href="#Scheduling-other-workload-types-调度其他类型的工作负载" class="headerlink" title="Scheduling other workload types(调度其他类型的工作负载)"></a>Scheduling other workload types(调度其他类型的工作负载)</h4><p>Sia可以不止用于调度深度学习训练的job，还可以用于其他类型的job(例如inference推理)</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>实现用的是开源的AdaptDL框架(基于PyTorch，提供对动态调整批量大小和GPU数量的原生支持)，只是用Sia替换了本身的调度器，且重构了框架的数据加载器(data-loader)<br>采用可配置的学习率缩放规则(configurable learning rate scaling rule)，根据批量大小缩放训练的学习率(批量大学习率大，批量小学习率小)</p>
<ul>
<li>使用AdamW优化器的模型，采用平方根学习率缩放规则(即缩放的步长为平方或平方根)</li>
<li>使用SGD优化器的模型，采用AdaScale自适应缩放规则(训练一个检测器来检测学习率的效果，从而决定如何缩放学习率)</li>
</ul>
<p>Sia的Policy像一个Kubernetes服务一样运行，在每轮调度开始的时候，根据最近的goodput模型的结果用公式优化资源分配(详细见<a href="#scheduler-objective">Scheduler objective</a>)。</p>
<ul>
<li>将公式看作是混合整数线性规划问题(Mixed-Integer Linear Program)，用来自CVXPY包的GLPK_MI求解器求解</li>
</ul>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 2</title>
    <url>/2022/03/02/%E9%9D%A2%E8%AF%95/2022-03-02-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%202/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h2><h3 id="特权模式切换"><a href="#特权模式切换" class="headerlink" title="特权模式切换"></a>特权模式切换</h3><ul>
<li>用户态和内核态的划分，引出上下文的概念。</li>
<li>创建一个进程(如main函数)需要控制一个外部设备时(比如控制LED亮灭)，程序员编写在用户空间的代码通过<strong>系统调用</strong>(操作系统提供给用户空间的接口函数)进入内核空间，由内核继续代表进程运行于内核空间。</li>
<li>在系统调用的过程中发生上下文切换：<ol>
<li>CPU寄存器里面原来用户态的指令位置，需要先保存起来，接着运行内核态代码。</li>
<li>CPU寄存器需要更新为内核态指令的位置，执行内核态代码。</li>
</ol>
</li>
<li>系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后切换为用户空间。</li>
<li>所以一次系统调用的过程，会发生两次的CPU上下文切换</li>
<li>但是一般说系统调用是特权模式切换而不是上下文切换。因为没有涉及到虚拟内存等这些进程用户态的资源，也不会切换进程，属于进程之内的上下文切换。</li>
</ul>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><ul>
<li>进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以用户态和内核态的切换不属于进程上下文切换。</li>
<li>进程的上下文包含了虚拟内存、栈、全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间的状态，所以进程的上下文切换要比系统调用更多一步——保存该进程的虚拟内存、栈等用户空间的资源。</li>
<li>进程上下文切换一般需要几十纳秒到数微秒的CPU时间，当进程上下文切换次数比较多的情况下，将导致CPU耗费大量的时间在寄存器、内核栈即虚拟内存等资源的保存和恢复上。</li>
<li>另外，Linux通过TLB快表来管理虚拟内存到物理内存的映射关系，当虚拟内存更新之后，需要刷新缓存，在这多处理系统上是很复杂的，因为多个处理器共享一个缓存。</li>
<li>进程在被调度的时候需要切换上下文，可能是主动地，也有可能是被动的：<ol>
<li>系统进程正常调度算法导致进程上下文切换。例如目前使用的<strong>时间片轮转算法</strong>，当一个进程的时间片耗尽之后，CPU会将进程调度切换到其他进程。</li>
<li>进程在<strong>资源不足</strong>的时候，会被挂起。例如在等待IO或者内存不足的时候，会主动挂起，并且等待系统调度其他进程。</li>
<li>当进程通过一些睡眠函数<strong>sleep()主动</strong>挂起的时候，也会重新调度。</li>
<li>当有高优先级的进程运行时，当前进程也会被挂起。<strong>(抢占)</strong>。</li>
<li>当发生<strong>硬件中断</strong>时，CPU上的进程会被中断挂起。</li>
</ol>
</li>
</ul>
<h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><ul>
<li>线程上下文切换，分为两种情况：<ol>
<li>前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。</li>
<li>前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。所以同进程内的线程切换要比多进程内的线程切换消耗更少的资源。</li>
</ol>
</li>
</ul>
<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><ul>
<li>中断是为了快速响应硬件的事件——计算机停下当前的事情，去处理其他的事情，然后在回来继续执行之前的任务。</li>
<li>例如在调用print函数的时候，其实汇编的底层会调用一条<strong>int 0x80</strong>的指令，便是调用0x80号中断。</li>
<li>中断要先将当前进程的状态保存下来，这样中断结束后进程仍然可以从原来的状态恢复运行，中断上下文的切换并不涉及进程的用户态，所以当中断程序打断了正在处于用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，只需要保存和恢复这个进程的内核态中的资源包括CPU寄存器、内核堆栈等。</li>
<li>对于同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生，一般来说中断程序都执行比较快短小精悍，以便快速结束执行之前的任务。</li>
<li>当中断上下文切换次数比较多的时候，会耗费大量的CPU时间。所以运行在中断上下文的代码不能做以下几件事：<ol>
<li>睡眠或者放弃CPU，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉。</li>
<li>尝试获得信号量，如果或得不到信号量，代码就会睡眠，结果同上。</li>
<li>执行耗时的任务，中断处理应该尽可能快，因为内核要相应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。</li>
<li>访问用户空间的虚拟地址，中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在无法访问用户空间的虚拟地址。</li>
</ol>
</li>
</ul>
<h3 id="查看CPU上下文切换情况"><a href="#查看CPU上下文切换情况" class="headerlink" title="查看CPU上下文切换情况"></a>查看CPU上下文切换情况</h3><ul>
<li><code>vmstat</code>是一个Linux常用的系统性能分析工具，可以用来分析CPU上下文切换和中断的次数。<ul>
<li><code>vmstat</code>工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数。</li>
<li>输出参数<ul>
<li><code>cs</code>(context switch)：每秒上下文切换的次数。</li>
<li><code>in</code>(interrupt)：每秒中断的次数。<ul>
<li>可以使用<code>cat</code>命令查看<code>/proc/interrupts</code>读取中断详细情况。</li>
</ul>
</li>
<li><code>r</code>(Running or Runnable)：就绪队列的长度，也就是正在运行和等待CPU的进程。</li>
<li><code>b</code>(Blocked)：处于不可中断睡眠状态的进程数。</li>
</ul>
</li>
</ul>
</li>
<li>要想查看每个进程的详细情况就需要使用<code>pidstat</code>，加上<code>-w</code>选项就可以查看进程上下文切换的情况:<ul>
<li>输出参数<ul>
<li><code>cswch</code>(voluntary context switches)：表示每秒<strong>自愿上下文切换</strong>的次数。<ul>
<li>自愿上下文切换：进程无法获取所需的资源，导致的上下文切换，例如IO、内存等资源不足时，就会发生自愿上下文切换。</li>
</ul>
</li>
<li><code>nvcswch</code>(non voluntary context switches)：表示每秒<strong>非自愿上下文切换</strong>的次数。<ul>
<li>非自愿上下文切换：进程由于时间片已到等时间，被系统强制调度，进而发生的上下文切换，例如大量的进程都在争抢CPU时，就容易发生非自愿上下文切换。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CPU上下文切换次数与性能的关系"><a href="#CPU上下文切换次数与性能的关系" class="headerlink" title="CPU上下文切换次数与性能的关系"></a>CPU上下文切换次数与性能的关系</h3><ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU，说明CPU的确成了瓶颈；</li>
<li>中断次数变多了，说明CPU被中断处理程序占用，还需要通过查看/proc/interrupts文件查看中断调用详情再做判断。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 1</title>
    <url>/2022/02/28/%E9%9D%A2%E8%AF%95/2022-02-28-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%201/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="进程线程的基本概念"><a href="#进程线程的基本概念" class="headerlink" title="进程线程的基本概念"></a>进程线程的基本概念</h2><h3 id="什么是进程、线程-彼此有什么区别"><a href="#什么是进程、线程-彼此有什么区别" class="headerlink" title="什么是进程、线程(彼此有什么区别)"></a>什么是进程、线程(彼此有什么区别)</h3><ul>
<li>进程是<strong>资源(CPU、内存等)分配</strong>的基本单位，线程是<strong>CPU调度</strong>的基本单位(<strong>程序执行的最小单位</strong>)。<ul>
<li>程序运行时，系统会给程序创建一个进程，并分配给予地址空间和其他资源，然后把进程加入到就绪队列中等待CPU执行。</li>
<li>线程是进程的一个执行流，实际上进程不能用来运行代码，真正运行代码的是进程里的线程。</li>
</ul>
</li>
<li>一个进程由<code>PCB</code>(进程控制块)、数据段、代码段组成<ul>
<li>进程一般会先创建出一个主线程，分配给主线程一定的系统资源，让主线程运行起来实现各种功能。主线程里可以创建出多个子线程，多个子线程在同一个进程里，利用进程所拥有的资源合作完成一系列更为复杂的功能。<blockquote>
<p>C程序中的main函数：</p>
<p>一方面作为程序入口，可以被认为是程序的主线程。</p>
<p>另一方面系统在执行main函数的时候，main函数又是一个独立的进程，程序员可以在main函数里编写插入创建子进程、子线程的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> g_cnt = <span class="number">0</span>;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">thread</span><span class="params">(<span class="type">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m_cnt = <span class="number">0</span>;</span><br><span class="line">    m_cnt = <span class="number">5</span>;</span><br><span class="line">    g_cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> m_cnt = <span class="number">0</span>;</span><br><span class="line">    err=<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);  <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != err)   <span class="comment">//检验是否创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can&#x27;t creat thread: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(err)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(g_cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">300</span>);   <span class="comment">//延迟300毫秒，让子线程运行一会儿</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;g_cnt = &quot;</span> &lt;&lt;  g_cnt &lt;&lt; <span class="string">&quot;, m_cnt = &quot;</span> &lt;&lt; m_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数里创建的多个子线程中，每个线程都将有自己的堆栈和局部变量，多个子线程还可以共享同个进程下的所有共享资源(例如全局变量)，因此可以通过创建多个线程来实现并发操作，完成更复杂的任务。</p>
<p>在上述代码中，main函数是一个主线程，由它开始执行程序。</p>
<p>但同时，main函数也扮演了进程的角色，因为它通过pthread_create函数创建了一个额子线程，用来执行函数thread()。子线程拥有自己的堆栈和局部变量，与主线程共享同一进程下的所有共享资源，如全局变量g_cnt，</p>
<p>所以主线程要输出的变量中，</p>
<p>g_cnt是子线程与主线程共享的全局变量，输出结果为1</p>
<p>m_cnt是各线程独自拥有的局部变量，子线程m_cnt的改变无法影响要输出的主线程m_cnt的值，输出结果为0</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="多进程、多线程的优点"><a href="#多进程、多线程的优点" class="headerlink" title="多进程、多线程的优点"></a>多进程、多线程的优点</h3><ul>
<li>由运行的稳定性来说<ul>
<li>多进程更健壮，一个进程停止运行不会影响其他进程，紫禁城停止运行也不会影响主进程的运行，因为进程是资源分配的基本单位，即系统为每个进程分配独立的资源。</li>
<li>多线程更脆弱，一个线程崩溃很可能影响到整个程序，因为线程是CPU调度的基本单位，多个线程都是在一个进程里运行的，其中难免会有一些共享的资源空间。</li>
</ul>
</li>
<li>从运行的性能来看<ul>
<li>进程的性能大于线程，每个进程都有独立的地址空间和资源</li>
<li>而多个线程是一起共享同个进程的空间和资源，线程存在竞争资源空间的问题，所以在性能方面比不上进程。</li>
</ul>
</li>
<li>从系统花销来看<ul>
<li>由于进程需要独立的地址空间和资源，因此创建多进程的系统化小要远大于多线程</li>
</ul>
</li>
<li>从数据传送来看<ul>
<li>多进程通讯因为需要跨越进程边界，因此不适合大量数据的传送，更适合小数据或者密集数据传送</li>
<li>多线程在同一个进程里运行，不需要跨越进程边界，适合各线程间大量数据传送，甚至多线程可以共享同一进程里的共享内存和变量</li>
</ul>
</li>
<li>从逻辑控制来看<ul>
<li>多进程逻辑控制比多线程复杂，需要与主进程交互，用来合作”做大事”</li>
<li>而多线程通常用来各自”做小事”(虽然其逻辑控制比较简单，但是需要复杂的线程同步和加锁控制等机制实现同步互斥)</li>
</ul>
</li>
<li>从增加数量上限来看<ul>
<li>进程数量可以通过增加CPU数量的方式来增加</li>
<li>线程数量由进程的空间资源和线程本身栈大小确定，无法通过增加CPU数量增加</li>
</ul>
</li>
</ul>
<h3 id="进程和线程的取舍"><a href="#进程和线程的取舍" class="headerlink" title="进程和线程的取舍"></a>进程和线程的取舍</h3><ul>
<li>创建和销毁较频繁的情况使用线程，因为创建和销毁进程的花销较大</li>
<li>需要大量数据传送的情况使用线程，多线程切换速度快，且不需要跨进程边界</li>
<li>并行操作使用线程(为实现并行的手段)</li>
<li>安全稳定的需求使用进程，快速频繁的需求选用线程</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>有一类子进程是不需要复制父进程的内存和数据的，单纯为了方便调用外部程序而创建</li>
<li>一个播放器框架<blockquote>
<p>主线程main函数创建子进程player执行播放视频的代码——调用外部播放器播放视频，创建子线程check监测播放器按钮情况，而main函数执行while(1)死循环。当用户按下播放器的某些按钮如：上一部、下一部时，子线程check会通知主线程main函数，让其再次创建子进程player调用外部播放器播放视频</p>
</blockquote>
</li>
</ul>
<h3 id="多进程、多线程同步-通讯-的方法"><a href="#多进程、多线程同步-通讯-的方法" class="headerlink" title="多进程、多线程同步(通讯)的方法"></a>多进程、多线程同步(通讯)的方法</h3><ul>
<li>进程间的通讯<ul>
<li>管道/命名、无名管道：<ul>
<li>一个管道实际上就是个<strong>只存在于内存中</strong>的文件，对这个文件的操作要通过两个已经打开的文件进行(管道两端)。但是，管道是一个特殊的文件，即它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。两个进程结束的时候，管道也会自动消失。</li>
<li>无名管道主要用于父进程与子进程之间，或者两个兄弟进程之间。Linux系统中可以通过系统调用建立起一个单向的通信管道，且这种关系只能由父进程来建立。因此，每个管道都是单向的，当需要双向通信的时候就需要建立起两个管道。管道两端的进程都将该管道看作是一个文件，一个进程负责往管道中写内容，一个进程负责从管道中读取。这种传输遵循先入先出(FIFO)的规则。</li>
<li>命名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计。建立在实际的磁盘戒指或是文件系统中会有自己名字的文件(<strong>不是只在内存</strong>)。任何进程任何时间通过文件名或者路径名都可以与该文件建立联系。<ul>
<li>引入新的文件类型——FIFO文件(遵循先进先出的原则)。命名管道一旦建立，之后读写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅仅是节点，文件数据还是存在于内存缓冲页面，和无名管道相同。</li>
</ul>
</li>
</ul>
</li>
<li>信号 <ul>
<li>进程间传递的消息，软中断</li>
</ul>
</li>
<li>共享内存</li>
<li>消息队列</li>
<li>信号量<ul>
<li>用于同步</li>
</ul>
</li>
<li>socket</li>
</ul>
</li>
<li>线程间的通信<ul>
<li>信号量<ul>
<li>用于同步，保证程序按照正确的顺序运行</li>
</ul>
</li>
<li>读写锁</li>
<li>条件变量</li>
<li>互斥锁<ul>
<li>用于互斥，即保证同一资源不能被同时访问</li>
</ul>
</li>
<li>自旋锁</li>
</ul>
</li>
<li>临界区指的是访问公共资源的程序片段，不是通信方式</li>
</ul>
<h3 id="进程的空间模型"><a href="#进程的空间模型" class="headerlink" title="进程的空间模型"></a>进程的空间模型</h3><ul>
<li>32位系统中，当系统运行一个程序，就会创建一个进程，系统会为其分配<strong>4G的虚拟地址空间</strong>，其中<strong>0-3G是用户空间</strong>，<strong>3-4G是内核空间</strong>，内核空间是受保护的，用户不能对该空间进行读写操作，否则可能出现段错误。其中栈空间的数据地址增加是往下的(新的数据地址值反而更小)，堆空间的地址增加是往上的。</li>
<li>空间模型分析<ul>
<li>栈区<ul>
<li>由编译器自动分配和释放，存放函数的参数值(形参)、局部变量等，其操作方式类似数据结构的栈，先进后出。</li>
<li>栈的空间有限，堆是很大的自由存储区，程序在编译期对变量和函数分配内存都在栈上进行，程序运行过程中函数调用参数的传递也是在栈上进行</li>
</ul>
</li>
<li>堆区<ul>
<li>一般由程序员分配和释放，若程序员不释放，可能会造成内存泄漏，程序结束的时候可能会被操作系统回收，分配方式类似链表，但不是数据结构中的堆。</li>
</ul>
</li>
<li>全局区(静态区)<ul>
<li>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在区域<code>.data</code>，未初始化的全局变量和未初始化的静态变量存储在相邻的区域<code>.bss</code>，程序结束后由系统释放。</li>
</ul>
</li>
<li>文字常量区<ul>
<li>常量字符串存储位置，程序结束后由系统释放。</li>
</ul>
</li>
<li>程序代码区(text)<ul>
<li>存放函数体的二进制代码。</li>
</ul>
</li>
<li>.rodata数据段用于<code>存放C中的字符串</code>和<code>#define定义的常量</code><br><img src="https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true" alt="Linux内核空间模型"></li>
</ul>
</li>
<li>64位操作系统下的虚拟内存空间大小：<ul>
<li>地址空间一般是$2^{48}$(256TB)，因为$2^{64}$太大，过大的空间只会造成资源的浪费。<ul>
<li>40位标识物理地址(可以找到存储对应物理地址的位置)</li>
<li><code>0x0000000000000000</code>~<code>0x00007fffffffffff</code>表示用户空间<ul>
<li>内核功能模块运行在内核空间。</li>
<li>内核运行在最高权限级别的内核态，可以进行所有操作。</li>
</ul>
</li>
<li><code>0xFFFF800000000000</code>~<code>0xFFFFFFFFFFFFFFFF</code>表示内核空间<ul>
<li>应用程序运行在用户空间。</li>
<li>应用程序运行在较低级别的用户态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程创建线程数量的决定因素"><a href="#进程创建线程数量的决定因素" class="headerlink" title="进程创建线程数量的决定因素"></a>进程创建线程数量的决定因素</h3><ul>
<li>虚拟内存的大小</li>
<li>分配给线程的调用栈大小决定</li>
</ul>
<h3 id="进程、线程的状态转换图"><a href="#进程、线程的状态转换图" class="headerlink" title="进程、线程的状态转换图"></a>进程、线程的状态转换图</h3><ul>
<li>状态<ul>
<li>创建态(new)<ul>
<li>一个进程(线程)正在被创建，还没转换到就绪态之前的状态。</li>
</ul>
</li>
<li>就绪态(ready)<ul>
<li>一个进程(线程)获得了除CPU时间片之外的一切所需资源，一旦得到CPU时间片即可被CPU调度运行。</li>
</ul>
</li>
<li>运行/执行态(running)<ul>
<li>一个进程(线程)得到CPU调度正在处理机上运行时的状态。</li>
</ul>
</li>
<li>睡眠/挂起态(sleep)<ul>
<li>由于某些资源暂时不可得到而进入该状态，将进程(线程)挂起，等待唤醒。</li>
</ul>
</li>
<li>阻塞/暂停态(blocked)<ul>
<li>一个进程(线程)正在等待某一事件而暂停运行时，如等待某资源成为可用，或等待文件读取完成。</li>
</ul>
</li>
<li>结束/僵尸态(exit)<ul>
<li>一个进程(线程)正在从系统中消失时的状态，进程(线程)结束或其他原因导致。</li>
</ul>
</li>
<li>死亡态(die)<ul>
<li>进程(线程)生命周期结束，所占用资源归还。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E7%94%9F.png?raw=true" alt="进程(线程)的一生"></p>
<blockquote>
<p>父进程调用fork()函数创建子进程，此时子进程处于创建态，系统将为进程分配地址和资源，</p>
<p>然后将其加入就绪队列，子进程进入就绪态。</p>
<p>就绪态的进程得到CPU时间片调度正式运行，进入执行态。在执行态将可能有四种情况发生：</p>
<ol>
<li>时间片耗尽或者被其他进程抢占，将重新进入就绪态，等待下一次CPU时间片。</li>
<li>由于某些资源暂时不可得到(如访问文件冲突)进入睡眠态，等待资源可得后再被唤醒，进入就绪态。</li>
<li>收到<strong>SIGSTOP/SIGTSTP信号</strong>进入暂停态，指导收到<strong>SIGCONT信号</strong>进入就绪态。</li>
<li>进程执行结束，通过内核调用进入僵尸态，等待资源回收。当父进程调用<strong>wait()/waitpid()</strong>后接收结束子进程，该进程进入死亡态。</li>
</ol>
</blockquote>
<h3 id="父进程和子进程的关系"><a href="#父进程和子进程的关系" class="headerlink" title="父进程和子进程的关系"></a>父进程和子进程的关系</h3><ul>
<li>子进程继承父进程的：<ul>
<li>用户号<code>UIDs</code>和用户组号<code>GIDs</code></li>
<li>环境<code>Environment</code></li>
<li>堆栈</li>
<li>共享内存</li>
<li>打开文件的描述符</li>
<li>执行时关闭(<code>Close-on-exec</code>)标志</li>
<li>信号(<code>Signal</code>)控制设定</li>
<li>进程组号</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件方式创建屏蔽字</li>
<li>资源限制</li>
<li>控制终端</li>
</ul>
</li>
<li>子进程独有的：<ul>
<li>地址空间</li>
<li>进程号<code>PID</code></li>
<li>不同的父进程号</li>
<li>自己的文件描述符和目录流的拷贝</li>
<li>子进程不继承父进程的进程正文(text)，数据和其他锁定内存(memory locks)</li>
<li>不继承异步输入和输出</li>
</ul>
</li>
<li>父进程调用fork()后，会克隆出一个子进程。但其实是父进程只复制了自己的<code>PCB块</code>交给子进程，而代码段，数据段和用户堆栈内存空间是父进程与子进程共享的。只有当子进程在运行中出现写操作时，才会产生中断，为子进程分配内存空间。<ul>
<li>也就是说：父子进程肯定共享代码空间，但是数据空间通常是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置(两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的)。</li>
<li>fork()在创建子进程的时候，有两个返回值：<ul>
<li>父进程中的返回值是子进程的进程号(不成功则返回错误)。</li>
<li>子进程中的返回值是0。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 3</title>
    <url>/2022/03/02/%E9%9D%A2%E8%AF%95/2022-03-02-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%203/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="并发、同步、异步、互斥、阻塞、非阻塞"><a href="#并发、同步、异步、互斥、阻塞、非阻塞" class="headerlink" title="并发、同步、异步、互斥、阻塞、非阻塞"></a>并发、同步、异步、互斥、阻塞、非阻塞</h2><h3 id="并发、同步、异步、互斥、阻塞、非阻塞的基本概念"><a href="#并发、同步、异步、互斥、阻塞、非阻塞的基本概念" class="headerlink" title="并发、同步、异步、互斥、阻塞、非阻塞的基本概念"></a>并发、同步、异步、互斥、阻塞、非阻塞的基本概念</h3><ul>
<li>并发<ul>
<li>在操作系统中，同个处理机上有多个程序同时运行。</li>
</ul>
</li>
<li>同步、异步<ul>
<li>同步：顺序执行，执行完一个再执行下一个，需要等待、协调运行。</li>
<li>异步：异步和同步是相对的，异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。<ul>
<li>线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需要等待子线程做完而是可以做其他事情。</li>
<li>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是实现异步的一种手段。</li>
</ul>
</li>
<li>同步和异步是对应的，是线程之间的关系。两个线程要么同步要么异步。</li>
</ul>
</li>
<li>阻塞、非阻塞<ul>
<li>当进程在访问数据时，根据IO操作的就绪状态不同而采取不同的处理方式。比如主程序调用一个函数要读取一个文件的内容：<ul>
<li>阻塞方式下主程序会等到函数读取完再继续往下执行。</li>
<li>非阻塞方式下读取函数会立刻返回一个状态值给主程序，主程序不等待文件读取完就继续往下执行。</li>
<li>要注意的是阻塞和非阻塞说明的是IO和CPU之间的关系，即CPU是否等待IO。</li>
</ul>
</li>
</ul>
</li>
<li>一般有以下4类IO模型，考虑发送方发出请求要接收方读取某文件内容为例：<ul>
<li>同步阻塞IO<ul>
<li>发送方发出请求后一直等待(同步)。接收方开始读取文件，如果不能马上得到读取结果就一直等待，直到获取读取结果再响应发送方，等待期间不可做其他操作(阻塞)。</li>
</ul>
</li>
<li>同步非阻塞IO<ul>
<li>发送方发出请求后一直等待(同步)。接收方开始读取文件，如果不能马上得到读取结果就一直等待，就立即返回，接受方继续去做其他事情。此时并未响应发送方，发送方一直等待。直到IO操作(读取文件)完成后，接收方获得读取结果响应发送方，接收方才可以进入下一次请求过程(非阻塞)。</li>
</ul>
</li>
<li>异步阻塞IO(理论存在，实际不用)<ul>
<li>发送方发出请求后，不等待响应，继续其他工作(异步)。接收方读取文件如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。</li>
</ul>
</li>
<li>异步非阻塞IO(效率最高)<ul>
<li>发送方发出请求后，不等待响应，继续其他工作(异步)。接收方读取文件如果不能马上得到结果，也不等待，而是马上返回去做其他事情。当IO操作(读取文件)完成以后，将完成状态和结果通知接收方，接收方再响应发送方。</li>
<li>阻塞和非阻塞是对同一个线程的某个时刻来说的。此时，线程要么阻塞，要么非阻塞。</li>
</ul>
</li>
</ul>
</li>
<li>阻塞是使用同步机制的结果，非阻塞是使用异步机制的结果。</li>
</ul>
<h3 id="线程的同步和互斥"><a href="#线程的同步和互斥" class="headerlink" title="线程的同步和互斥"></a>线程的同步和互斥</h3><ul>
<li>线程互斥<ul>
<li>当有若干个线程同时访问同一块资源时，规定同一时间只有一个线程可以得到访问权，其他线程需要等待占用资源者释放该资源才可以申请访问。</li>
<li>互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
</ul>
</li>
<li>线程同步：<ul>
<li>在互斥的基础上(大多数情况，除非允许同一时间多个访问者访问同一资源)，通过其它机制实现访问者对资源的有序访问，实现每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。</li>
</ul>
</li>
</ul>
<h3 id="线程同步与阻塞的关系"><a href="#线程同步与阻塞的关系" class="headerlink" title="线程同步与阻塞的关系"></a>线程同步与阻塞的关系</h3><ul>
<li>同步是过程，阻塞是状态<ul>
<li>当多个线程访问同一资源时，规定同一时间只有一个线程可进行访问，所以后访问的线程将被阻塞，等待先访问的线程访问完。</li>
</ul>
</li>
<li>线程同步不一定发生阻塞。只有当访问同一资源出现互相等待和互相唤醒才会发生阻塞。而阻塞了一定是同步，多线程用阻塞实现同步。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程 4</title>
    <url>/2022/03/03/%E9%9D%A2%E8%AF%95/2022-03-03-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%204/</url>
    <content><![CDATA[<h1 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h1><h2 id="孤儿进程、僵尸进程、守护进程的概念"><a href="#孤儿进程、僵尸进程、守护进程的概念" class="headerlink" title="孤儿进程、僵尸进程、守护进程的概念"></a>孤儿进程、僵尸进程、守护进程的概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>孤儿进程<ul>
<li>当父进程退出后，子进程还在运行，那么这些子进程就是孤儿进程。</li>
<li>孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。</li>
</ul>
</li>
<li>僵尸进程<ul>
<li>当子进程推出后，父进程却并未接收到结束子进程的信息(调用waitpid获取子进程的状态信息)，那么子进程仍停留在系统中，即僵尸进程。</li>
</ul>
</li>
<li>守护进程<ul>
<li>在后台运行不受终端控制的进程(输入、输出)。网络服务大部分是守护进程。</li>
</ul>
</li>
</ul>
<h3 id="如何创建守护进程"><a href="#如何创建守护进程" class="headerlink" title="如何创建守护进程"></a>如何创建守护进程</h3><ul>
<li>创建子进程，父进程退出<ul>
<li>因为守护进程是在后台运行不受终端控制的进程。父进程退出后控制台就以为该程序结束了，就可以让子进程在后台进行自己的任务，同时用户仍然可以在控制台输入指令，从而在形式上做到与控制台脱离。</li>
</ul>
</li>
<li>在子进程中创建新的会话(脱离控制终端)<ul>
<li>使用系统函数<code>setsid()</code>创建一个新的会话，并担任该会话组的组长，摆脱原会话的控制，进而摆脱原进程的控制，最后达到摆脱控制台控制的目的。<ul>
<li><code>setsid()</code>函数参数缺省时为关闭根目录，关闭文件描述符。</li>
</ul>
</li>
</ul>
</li>
<li>改变当前目录为根目录<ul>
<li>子进程会继承父进程的目录信息，但进程运行时对当前目录下的文件系统不能卸载，会造成很多隐藏麻烦。</li>
</ul>
</li>
<li>重设文件权限掩码，关闭文件描述符<ul>
<li>子进程还会继承父进程的文件权限掩码，即屏蔽掉文件权限中的对应位。此时子进程需将其重置为0，即在此时要有大的权限，从而提高该守护进程的灵活程度。最后，关闭从父进程继承的已经打开的文件描述符，如不进行关闭，将造成浪费资源以及子进程所有文件系统无法卸载等错误。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 第一次fork的作用在shell终端里造成一个程序已经运行完毕的假象。</span></span><br><span class="line"><span class="comment">     * 同时创建新会话的进程不能是进程组组长，所以父进程是进程组组长是不能创建新会话的，需要子进程中执行。</span></span><br><span class="line"><span class="comment">     * 所以到这里子进程便成为了一个新会话组的组长。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    pid = fork();   <span class="comment">// 成功则父进程获得子进程PID，子进程获得0。</span></span><br><span class="line">    <span class="built_in">If</span>(pid &lt; <span class="number">0</span>)  <span class="comment">//创建子进程失败。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//父进程退出。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   <span class="comment">//进入子进程。</span></span><br><span class="line">        <span class="built_in">setsid</span>();  <span class="comment">//创建新会话。</span></span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>); <span class="comment">//重置文件权限掩码。</span></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 第二次fork可以保证不会因为错误操作重新打开终端。</span></span><br><span class="line"><span class="comment">         * 因为只有会话组组长可以打开一个终端，再第二次fork后的子进程就不是会话组组长，就不会无意中打开终端了。</span></span><br><span class="line"><span class="comment">         * 但此部分非必须。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);  <span class="comment">//设置当前目录为根目录。</span></span><br><span class="line">        <span class="type">int</span> maxfd = <span class="built_in">getdtablesize</span>();    <span class="comment">// 获得打开的文件描述符。</span></span><br><span class="line">        <span class="keyword">while</span>(maxfd--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(maxfd);  <span class="comment">//关闭文件描述符。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_INFO,<span class="string">&quot;im deamon\n&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确处理孤儿进程、僵尸进程的方法"><a href="#正确处理孤儿进程、僵尸进程的方法" class="headerlink" title="正确处理孤儿进程、僵尸进程的方法"></a>正确处理孤儿进程、僵尸进程的方法</h3><ul>
<li>孤儿进程的处理<ul>
<li>孤儿进程也就是没有父进程的进程，它由进程号为1的init进程负责处理。当有孤儿进程需要处理的时候，系统就把孤儿进程的父进程设置为init，而init进程会循环地运行<code>wait()</code>来获取它子进程的状态。</li>
</ul>
</li>
<li>僵尸进程的处理<ul>
<li>如果父进程一直调用<code>wait()/waitpid()</code>函数接收子进程，那么子进程就一直保存在系统里，占用系统资源。</li>
<li>如果僵尸进程太多，就会导致系统空间饱满，无法创建新的进程，严重影响系统工作。</li>
<li>系统规定，子进程退出后，父进程会自动收到<code>SIGCHLD</code>信号，在父进程里重置<code>signal</code>函数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler函数里不能使用wait（）函数，</span></span><br><span class="line"><span class="comment">     * 比如同一时间有5个子进程都要结束了，均向父进程发送SIGCHLD信号，但父进程此时就在处理其中一个，在处理结束前，收到的其他SIGCHLD信号会忽略，导致漏掉部分子进程没有处理结束。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is die\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD, handler);   <span class="comment">// 设置函数handler来处理SIGCHLD信号。</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">//父进程循环等待。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;   <span class="comment">//子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD。</span></span><br><span class="line">                          <span class="comment">//信号调用handler函数接收结束子进程，打印child is die。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child, i die\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="waitpid-和wait-函数"><a href="#waitpid-和wait-函数" class="headerlink" title="waitpid()和wait()函数"></a>waitpid()和wait()函数</h3><ul>
<li><code>pid_t waitpid(pid_t pid,int *status,int options)</code>函数<ul>
<li>参数<ul>
<li><code>pid</code><ul>
<li>从参数的名字pid和类型pid_t中就可以看出，需要的是一个<strong>进程ID</strong>。但当pid取不同的值时，在这里有不同的意义。</li>
<li><strong>pid&gt;0</strong>时，指<strong>等待进程ID等于pid的子进程</strong>，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束,waitpid就会一直等下去。</li>
<li><strong>pid=-1</strong>时，<strong>等待任何一个子进程退出</strong>，没有任何限制，此时waitpid和wait的作用一模一样。 　　</li>
<li><strong>pid=0</strong>时，<strong>等待同一个进程组中的任何子进程</strong>，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。</li>
<li><strong>pid&lt;-1</strong>时，<strong>等待一个指定进程组中的任何子进程</strong>，这个<strong>进程组的ID等于pid的绝对值</strong>。 　　</li>
</ul>
</li>
<li><code>status</code><ul>
<li>用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉(绝大多数情况)，就可以<strong>设定这个参数为NULL</strong>。</li>
</ul>
</li>
<li><code>options</code><ul>
<li>提供了一些额外的选项来控制waitpid，目前在Linux中只支持<code>WNOHANG</code>和<code>WUNTRACED</code>两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用，不想使用则设置为0。<ul>
<li>如果使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去，即不需要阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>当正常返回的时候，waitpid返回收集到的<strong>子进程的进程ID</strong>；</li>
<li>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则<strong>返回0</strong>； 　　 　　</li>
<li>如果调用中出错，则<strong>返回-1</strong>，这时errno会被设置成相应的值以指示错误所在；当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD </li>
</ul>
</li>
</ul>
</li>
<li><code>pid_t wait(int *status)</code>函数<ul>
<li>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，<ul>
<li>如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；</li>
<li>如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</li>
</ul>
</li>
<li>参数<ul>
<li><code>status</code><ul>
<li>用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉(绝大多数情况)，就可以<strong>设定这个参数为NULL</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>如果成功，wait会返回被收集的<strong>子进程的进程ID</strong>。</li>
<li>如果调用进程没有子进程，调用就会失败，此时<strong>wait返回-1</strong>，同时<strong>errno被置为ECHILD</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>waitpid提供了wait函数不能实现的3个功能:<ol>
<li>waitpid等待<strong>特定</strong>的子进程, 而wait则返回<strong>任一</strong>终止状态的子进程;</li>
<li>waitpid提供了一个wait的<strong>非阻塞版本</strong>; </li>
<li>waitpid支持<strong>作业控制</strong>(以WUNTRACED选项). 用于检查wait和waitpid两个函数返回终止状态的宏: 这两个函数返回的子进程状态都保存在status指针中, 用以下3个宏可以检查该状态:<ul>
<li>WIFEXITED(status): 若为正常终止, 则为真，此时可执行WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位。</li>
<li>WIFSIGNALED(status): 若为异常终止, 则为真，此时可执行 WTERMSIG(status): 取使子进程终止的信号编号。</li>
<li>WIFSTOPPED(status): 若为当前暂停子进程, 则为真，此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号。</li>
</ul>
</li>
</ol>
</li>
<li>如果在父进程用wait()和waitpid()会使父进程挂起，解决的办法：<ul>
<li>可以用signal函数为SIGCHLD安装handler。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</li>
<li>如果父进程不关心子进程什么时候结束，那么可以用<code>signal(SIGCLD, SIG_IGN)</code>或<code>signal(SIGCHLD, SIG_IGN)</code>通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号。</li>
<li>fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做，子进程回收后父进程才挂起。 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer—基础知识</title>
    <url>/2022/03/28/%E9%9D%A2%E8%AF%95/2022-03-28-%E5%89%91%E6%8C%87Offer%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="剑指Offer—基础知识"><a href="#剑指Offer—基础知识" class="headerlink" title="剑指Offer—基础知识"></a>剑指Offer—基础知识</h1><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统简介</title>
    <url>/2024/09/21/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-21-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="分布式系统简介"><a href="#分布式系统简介" class="headerlink" title="分布式系统简介"></a>分布式系统简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>Autonomous processors communicating over a communication network<ul>
<li>No common physical clock</li>
<li>No shared memory</li>
<li>Geographical seperation</li>
<li>Autonomy and heterogeneity(异构)</li>
</ul>
</li>
<li>分布式系统：物理分布，逻辑集中；个体独立，整体统一<ul>
<li>若干独立自主计算机的集合(硬件)</li>
<li>这些计算机对于用户来说像是单个耦合系统(软件)</li>
</ul>
</li>
<li>A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable(不知道存在让自己计算机无法使用的故障计算机)——Leslie Lamport</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>自主性<ul>
<li>计算节点硬件或软件进程是独立的</li>
</ul>
</li>
<li>耦合性<ul>
<li>用户或者应用程序感觉系统是一个系统——节点之间需要相互协作</li>
</ul>
</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>使资源可访问：让用户方便地访问资源<ul>
<li>资源访问共享<ul>
<li>基于云的存储和文件系统</li>
<li>基于P2P的流媒体系统</li>
<li>共享邮件系统(外包邮件系统)</li>
<li>共享的Web支撑系统(CDN)</li>
</ul>
</li>
<li>The network is the computer</li>
</ul>
</li>
<li>透明性：隐藏资源在网络上的分布(隐藏进程和资源在多台计算机分布这一事实)，分布式透明性是一个较好的属性，但是需要区别对待<ul>
<li>访问：隐藏数据表示形式的不同以及资源访问方式的不同</li>
<li>位置：隐藏资源所在位置</li>
<li>迁移：异常资源是否移动到另一个位置</li>
<li>重定位：隐藏资源是否在使用过程中移动到另一个位置</li>
<li>复制：隐藏是否对资源进行复制</li>
<li>并发：隐藏资源是否由相互竞争的用户共享</li>
<li>故障：隐藏资源的故障和修复</li>
<li>持久化：隐藏数据在主存和磁盘</li>
<li>完全的透明性是不可取的，也是难以实现的：<ul>
<li>可能掩盖通信的性能问题</li>
<li>完全隐藏网络和节点的失效是不可能<ul>
<li>不能区分失效和性能变慢的节点</li>
<li>不能确定系统失效之前的操作是什么</li>
</ul>
</li>
<li>完全的透明性可能牺牲性能，暴露系统分布特征</li>
<li>保证复制节点与主节点的一致性需要时间</li>
<li>为了容错需要立即将内存修改的内容同步到磁盘上</li>
</ul>
</li>
</ul>
</li>
<li>开放性：访问接口的标准化，系统根据一系列准则提供服务，准则描述了所提供服务的语法和语义(标准化)<ul>
<li>系统应该具有良好定义的接口</li>
<li>系统应该容易实现互操作性</li>
<li>系统应该支持可移植性</li>
<li>系统应该容易实现可扩展性</li>
<li>策略与机制：机制是提供的功能，策略是如何用这些功能 <ul>
<li>两者严格分离：需要设计合适的机制，导致出现很多配置参数和复杂的管理</li>
<li>两者耦合：硬编码某些策略可以简化管理和配置参数，但迁移性灵活性不好，不同的系统要不同的策略</li>
</ul>
</li>
</ul>
</li>
<li>可扩展性：系统在规模、地域、管理上的可扩展性<ul>
<li>规模可扩展性(大部分系统关心)：用户数量和进程数量增加<ul>
<li>多个服务器独立并行运行</li>
</ul>
</li>
<li>地理可扩展性：节点之间的物理位置距离扩大</li>
<li>管理可扩展性：管理域的数量</li>
</ul>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>局域网</li>
<li>分布式数据库</li>
<li>搜索集群</li>
<li>大规模深度学习系统</li>
<li>大规模微服务系统</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/software%20components%20at%20each%20process.png" alt="img"></p>
<h2 id="Motivation-for-Distributed-System"><a href="#Motivation-for-Distributed-System" class="headerlink" title="Motivation for Distributed System"></a>Motivation for Distributed System</h2><ul>
<li>Inherently distributed computation(分布式计算本就是固有的特征)</li>
<li>Resource sharing</li>
<li>Access to remote resources</li>
<li>Increased performance / cost ratio(提升性价比)</li>
<li>Reliability<ul>
<li>availability</li>
<li>integrity</li>
<li>fault-tolerance</li>
</ul>
</li>
<li>Scalability</li>
<li>Modularity and incremental expandability</li>
</ul>
<h2 id="Parallel-Systems"><a href="#Parallel-Systems" class="headerlink" title="Parallel Systems"></a>Parallel Systems</h2><h3 id="Multiprocessor-systems"><a href="#Multiprocessor-systems" class="headerlink" title="Multiprocessor systems"></a>Multiprocessor systems</h3><ul>
<li>direct access to shared memory, UMA model, like Omega, Butterfly, Clos, Shuffle-exchange networks(可直接访问内存的多处理器系统)</li>
<li>Interconnection network <ul>
<li>bus(总线)</li>
<li>multi-stage switch(多阶段开关)</li>
</ul>
</li>
<li>Interconnection generation function(互联功能), routing function(输出功能)</li>
<li>UMA Models(Uniform memory access)<ul>
<li>the processors may locally cache data from memory<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/UMA.png" alt="img"></li>
</ul>
</li>
<li>Omega<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Omega.png" alt="img"><ul>
<li>n processors, nmemory banks</li>
<li>log n stages: with n/2 switches of size 2x2 in each stage(图中小方块)</li>
<li>Interconnection function: Output i of a stage connected to input j of next stage:<script type="math/tex; mode=display">
j = 
\begin{cases}
2i\quad for\quad 0 \leq i \leq n/2 - 1\\
2i+1-n\quad for\quad n/2 \leq i \leq n - 1
\end{cases}</script></li>
<li>Routing function: in any stage s at any switch: <ul>
<li>to route to dest. j(要输出到内存编号的最后一位是0还是1？)<ul>
<li>if $(s+1)^th$ MSB of $j = 0$ then route on upper wire</li>
<li>else $[(s+1)^th]$ MSB of $j =1$ then route on lower wire</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Butterfly<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Butterfly.png" alt="img"></li>
<li>Nvidia NVlink<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Nvidia%20NVlink.png" alt="img"></li>
<li>Interconnection Topologies for Multiprocessors<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Interconnection%20Topologies%20for%20Multiprocessors.png" alt="img"></li>
</ul>
<h3 id="Multicomputer-parallel-systems"><a href="#Multicomputer-parallel-systems" class="headerlink" title="Multicomputer parallel systems"></a>Multicomputer parallel systems</h3><ul>
<li>no direct access to shared memory, NUMA model, like NYU Ultracomputer, CM* Connection Machine, IBM Blue gene, 天河二号(不能直接访问内存的多计算机并行系统)<ul>
<li>NUMA(Non-uniform memory access)<ul>
<li>the processors may locally cache data from memory<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/NUMA.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Array-processors"><a href="#Array-processors" class="headerlink" title="Array processors"></a>Array processors</h3><ul>
<li>colocated, tightly coupled, common system clock, like Niche market, DSP applications(处理器阵列)</li>
</ul>
<h2 id="Flynn’s-Taxonomy-费林分类法"><a href="#Flynn’s-Taxonomy-费林分类法" class="headerlink" title="Flynn’s Taxonomy(费林分类法)"></a>Flynn’s Taxonomy(费林分类法)</h2><ul>
<li>SISD: Single Instruction Stream Single Data Stream(traditional)</li>
<li>SIMD: Single Instruction Stream Multiple Data Stream<ul>
<li>scientific applications, applications on large arrays</li>
<li>vector processors矢量处理器, systolic arrays脉动阵列, Pentium/SSE, DSP chips</li>
</ul>
</li>
<li>MISD: Multiple Instruction Stream Single Data Stream<ul>
<li>visualization(用于可视化)</li>
</ul>
</li>
<li>MIMD: Multiple Instruction Stream Multiple Data Stream<ul>
<li>distributed systems, vast majority of parallel systems<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Flynn&#39;s%20Taxonomy.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="Some-Terminology-一些术语"><a href="#Some-Terminology-一些术语" class="headerlink" title="Some Terminology(一些术语)"></a>Some Terminology(一些术语)</h2><ul>
<li>Coupling(联轴器)<ul>
<li>Interdependency/binding among modules(模块间的相互依赖或绑定), whether hardware or software(e.g., OS, middleware)</li>
</ul>
</li>
<li>Parallelism: T(1) / T(n)<ul>
<li>Function of program and system</li>
</ul>
</li>
<li>Concurrency(并发性) of a program<ul>
<li>Measures productive CPU time vs. waiting for synchronization operations(CPU运行的时间与等待同步操作的时间的比例)</li>
</ul>
</li>
<li>Granularity of a program<ul>
<li>Amt. of computation vs. amt. of communication</li>
<li>Fine-grained program suited for tightly-coupled system(细粒度程序适合紧密耦合的系统)</li>
</ul>
</li>
<li>Message-passing and Shared Memory<ul>
<li>Emulating MP over SM(共享内存模拟消息传递)<ul>
<li>Partition shared address space(部分共享地址空间)</li>
<li>Send/Receive emulated by writing/reading from special mailbox per pair of processes(向特殊的mailbox读写模拟收发)</li>
</ul>
</li>
<li>Emulating SM over MP(消息传递模拟共享内存)<ul>
<li>Model each shared object as a process(开一个共享进程)</li>
<li>Write to shared object emulated by sending message to owner process for the object(向该进程发送消息模拟写共享内存)</li>
<li>Read from shared object emulated by sending query to owner of shared object(向该进程接收消息模拟读共享内存)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式系统与其他系统的关系"><a href="#分布式系统与其他系统的关系" class="headerlink" title="分布式系统与其他系统的关系"></a>分布式系统与其他系统的关系</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="img"></p>
<h2 id="Classification-of-Primitives-分类原语"><a href="#Classification-of-Primitives-分类原语" class="headerlink" title="Classification of Primitives(分类原语)"></a>Classification of Primitives(分类原语)</h2><h3 id="Synchronous-and-Asynchronous-同步和异步"><a href="#Synchronous-and-Asynchronous-同步和异步" class="headerlink" title="Synchronous and Asynchronous(同步和异步)"></a>Synchronous and Asynchronous(同步和异步)</h3><ul>
<li>Synchronous(sned/receive, 读写都有同步的)<ul>
<li>Handshake between sender and receiver(收发间需要握手)</li>
<li>Send completes when Receive completes(接收完成后发送才完成)</li>
<li>Receive completes when data copied into buffer(数据完全拷贝进入缓存后接收才完成，所以发送是最后完成的？)</li>
</ul>
</li>
<li>Asynchronous(only send, 只有发送才是异步的)<ul>
<li>Control returns to process when data copied out of user-specified buffer(发送不用等接收完成才返回，只用在发送的数据从用户指定的缓存区复制出去后就可返回)</li>
</ul>
</li>
<li>Messgae-passing System<ul>
<li>Asynchronous Executions:<ul>
<li>there is no processor synchrony(处理器不同步) and there is no bound on the drift rate of processor clocks(时钟漂移率也没有限制，时钟漂移是抖动的另一种形式：当抖动频率小于10Hz的时候把这样的抖动叫做漂移。抖动即在时钟信号短时间内的波动。)</li>
<li>message delays(transmission + propagation times) are finite but unbounded(消息延迟包括传输和传播时间，有限但无界)</li>
<li>there is no upper bound on the time taken by a process to execute a step(进程执行一个步骤所花费的时间没有上限)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20Executions.png" alt="img"><ul>
<li>The arrows denote the message </li>
<li>The tail and head of an arrow mark the send and receive event for that message, denoted by a circle and vertical line, respectively(圆圈是发送事件，垂直线是接收事件)</li>
<li>Non-communication events, also termed as internal events, are shown by shaded circles(非通信的内部事件，有黑圈表示)</li>
</ul>
</li>
</ul>
</li>
<li>Synchronous Executions<ul>
<li>processors are synchronized and the clock drift rate between any two processors is bounded(处理器同步，任意两个处理器的时钟漂移率是绑定的)</li>
<li>message delivery(transmission + delivery) times are such that they occur in one logical step or round</li>
<li>there is a known upper bound on the time taken by a process to execute a step(一个进程执行一个步骤所花费的时间有一个已知的上限)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Synchronous%20Executions.png" alt="img"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sync_Execution(<span class="type">int</span> k, n)  <span class="comment">// k rounds, n processes</span></span><br><span class="line"><span class="keyword">for</span> r = <span class="number">1</span> to k <span class="keyword">do</span></span><br><span class="line">  proc i sends msg to (i+<span class="number">1</span>) mod n and (i - <span class="number">1</span>) mod n;</span><br><span class="line">  each proc i receives msg <span class="title function_">from</span> <span class="params">(i+<span class="number">1</span>)</span> mod n <span class="title function_">and</span> <span class="params">(i<span class="number">-1</span>)</span> mod n;</span><br><span class="line">  compute app-specific function on received values</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Comparison<ul>
<li>Difficul to build a truly synchronous system, can simulate this abstraction(非常困难构建一个真正的同步系统，但可以模拟同步系统)</li>
<li>Virtual synchrony(虚拟同步):<ul>
<li>async exection, processes synchronize as per application requirement(异步执行，进程根据应用程序要求同步)</li>
<li>execute in rounds/steps</li>
</ul>
</li>
<li>Emulations:<ul>
<li>Async program on sync system: trivial(Async is special case of Sync，同步系统中的异步程序，异步是同步的一种特例)</li>
<li>Sync program on async system: tool called synchronzier(异步系统的同步程序，比较困难)<br><img src="https://github.com/zjn-astonishe/image/blob/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/system%20emulations.png?raw=true" alt="img"><ul>
<li>Assumption: failure-free system</li>
<li>System A emulated by system B(B模拟出了A，则):<ul>
<li>if not solvable in B, not solvable in A(无法在B中解决的问题，A中也不能解决)</li>
<li>if solvable in A, solvable in B(能在A中解决的问题，在B中一定能解决)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Blocking-and-Nonblocking-阻塞和非阻塞"><a href="#Blocking-and-Nonblocking-阻塞和非阻塞" class="headerlink" title="Blocking and Nonblocking(阻塞和非阻塞)"></a>Blocking and Nonblocking(阻塞和非阻塞)</h3><ul>
<li>Blocking(send/receive)<ul>
<li>Control returns to invoking process after processing of primitive(whether sync or async) completes(需要在原语执行完成后才返回)</li>
</ul>
</li>
<li>Nonblocking(send/receive)<ul>
<li>Control returns to process immediately after invocation(调用结束后直接返回)</li>
<li>Send: even before data copied out of user buffer(甚至在数据从用户缓冲区复制出来之前)</li>
<li>Receive: even before data may have arrived from sender(甚至在数据从发送者到达之前)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// When the Wait can returns, at least one of its parameters is posted</span></span><br><span class="line">Send(X, destination, handle_k)  <span class="comment">// handle_k is a return parameter, returns a system-generated handle</span></span><br><span class="line"><span class="comment">// because it is non-blocking, later to check for status of completion of call, keep checking(loop or periodically) if handle has been posted(不断检查是否已经返回)</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Issue Wait(handle_1, handle_2, ...) call with list of handles</span></span><br><span class="line">Wait(handle_1, handle_2, ..., handle_k, ...handle_m)  <span class="comment">// Wait always blocks until one of the stipulated handles is posted</span></span><br></pre></td></tr></table></figure>
<h3 id="Combination-of-Blocking-Nonblocking-Synchronous-Asynchronous-send-receive-primities"><a href="#Combination-of-Blocking-Nonblocking-Synchronous-Asynchronous-send-receive-primities" class="headerlink" title="Combination of Blocking/Nonblocking, Synchronous/Asynchronous, send/receive primities"></a>Combination of Blocking/Nonblocking, Synchronous/Asynchronous, send/receive primities</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/primities.png" alt="img"></p>
<h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><h3 id="System-Perspective"><a href="#System-Perspective" class="headerlink" title="System Perspective"></a>System Perspective</h3><ul>
<li>Communication mechanisms<ul>
<li>Remote Procedure Call(RPC，远程过程调用)</li>
<li>Remote Object Invocation(ROI，远程对象调用)</li>
<li>Message-Oriented communication(面向消息的通信) vs. Stream-oriented communication(面向流的通信)</li>
</ul>
</li>
<li>Processes: <ul>
<li>Code migration(代码迁移)</li>
<li>process/thread management at clients and servers(客户端和服务端的进程/线程管理)</li>
<li>deign of software and mobile agents(设计软件和移动用户)</li>
</ul>
</li>
<li>Naming:<ul>
<li>Easy to use identifiers(容易使用标识符) needed to locate resources and processes transparently and scalably(透明和可扩展地运行，定位资源)</li>
</ul>
</li>
<li>Synchronization(同步)</li>
<li>Data storage and access(存储数据和访问数据)<ul>
<li>Schemes for data storage, search, and lookup should be fast and scalable across network(数据的存储、搜索和查找方案应该快速且可跨网络扩展)</li>
<li>Revisit file system design(需要重新审视对文件系统的设计)</li>
</ul>
</li>
<li>Consistency and replication(一致性和复制)<ul>
<li>Replication for fast access, scalability, avoid bottlenecks(为了快速访问和可扩展性要进行复制)</li>
<li>Reuire consistency management among replicas(副本之间要有一致性管理)</li>
</ul>
</li>
<li>Fault-tolerance(容错):<ul>
<li>correct and efficient operation despite link, node, process failures(即使链路、节点、流程出现故障，依然能正确有效运行)</li>
</ul>
</li>
<li>Distributed systems security(安全)<ul>
<li>Secure channels(信道安全)</li>
<li>access control(访问安全)</li>
<li>key management(key generation and key distribution，密钥管理：设计生成和分发)</li>
<li>authorization(认证)</li>
<li>secure group management(组管理)</li>
</ul>
</li>
<li>Scalability and modularity of algorithms, data, services(可扩展性和模块化)</li>
<li>Some experimental systems<ul>
<li>Globe</li>
<li>Globus</li>
<li>Grid</li>
<li>PlanetLab</li>
</ul>
</li>
<li>API for communications, services: ease of use(容易使用的API)</li>
<li>Transparency: hiding implementation policies from user<ul>
<li>Access: hide differences in data rep across systems, provide uniform operations to access resources</li>
<li>Location: locations of resources are transparent(要访问的资源在哪用户是不知道的)</li>
<li>Migration: relocate resources without renaming</li>
<li>Relocation: relocate resources as they are being accessed</li>
<li>Replication: hide replication from the users</li>
<li>Concurrency(并发，互斥？): mask the use of shared resources</li>
<li>Failure: reliable and fault-tolerant operation</li>
</ul>
</li>
</ul>
<h3 id="Algorithm-Design"><a href="#Algorithm-Design" class="headerlink" title="Algorithm/Design"></a>Algorithm/Design</h3><ul>
<li>Useful execution models and frameworks: to reason with and design correct distributed programs(模型和框架，推理和设计正确的分布式模型)<ul>
<li>Interleaving model(交错模型)</li>
<li>Partial order model(部分顺序模型)</li>
<li>Input/Output automata(输入/输出自动机)</li>
<li>Temporal Logic of Actions(行动的时间逻辑)</li>
</ul>
</li>
<li>Dynamic distributed graph algorithms(动态分布式图算法) and routing algorithms(路由算法)<ul>
<li>System topology: distributed graph, with only local neighborhood knowledge(只有本地邻域的知识构建分布式图，系统拓扑)</li>
<li>Graph algorithms: building blocks for group communication, data dissemination, object location(图算法：为组通信、数据传播、对象定位构建块)</li>
<li>Algorithms need to deal with dynamically changing graphs(解决动态变化的图)</li>
<li>Algorithm effiency: also impacts resource consumption, latency, traffic, congestion(影响资源消耗、延迟、流量和拥塞)</li>
</ul>
</li>
<li>Time and global state(时间和全局的状态)<ul>
<li>3D space, 1D time</li>
<li>Physical time(clock) accuracy，物理时间的精度</li>
<li>Logical time captures inter-process dependencies and tracks relative time progression，逻辑时间捕获进程间的依赖关系并跟踪相对时间进程</li>
<li>Global state observation: inherent distributed nature of system(全球状态观测，系统固有的分布式特性)</li>
<li>Concurrency measures(并发度量): concurrency depends on program logic, execution speeds within logical threads, communication speeds(程序逻辑、逻辑线程内的执行速度、通信速度)</li>
</ul>
</li>
<li>Synchronization/coordination mechanisms(同步和协作机制)<ul>
<li>Physical clock synchronization: hardware drift needs correction(硬件漂移需要校正，让物理时钟同步)</li>
<li>Leader election: select a distinguished process, due to inherent symmetry(选择一个较好的进程作为领导者)</li>
<li>Mutual exclusion: coordinate access to critical resources(相互排斥，协调关键资源的获取)</li>
<li>Distributed deadlock detection and resolution: need to observe global state; avoid duplicate detection(避免重复检测), unnecessary aborts(不必要的中止)</li>
<li>Termination detection(终止检测): global state of quiescence(全局静止状态); no CPU processing(无CPU处理) and no in-transit messages(无传输中的消息)</li>
<li>Garbage collection: Reclaim objects no longer pointed to by any process(回收不再被任何进程指向的对象)</li>
</ul>
</li>
<li>Group communication, multicast, and ordered message delivery(组通信、多播和有序消息传递)<ul>
<li>Group: processes sharing a context, collaborating(共享上下文、协作的流程)</li>
<li>Multiple joins, leaves, fails</li>
<li>Concurrent sends: semantics of delivery order(并发发送：交付顺序)</li>
</ul>
</li>
<li>Monitoring distributed events and predicates(监视分布式的事件和预测)<ul>
<li>Predicate: condition on global system state(全局系统状态条件)</li>
<li>Debugging, environmental sensing, industrial process control, analyzing event streams(事件流分析)</li>
</ul>
</li>
<li>Distributed program design and verification tools</li>
<li>Debugging distributed programs</li>
<li>Data replication, consistency models, and caching<ul>
<li>Fast, scalable access;</li>
<li>coordinate replica updates;</li>
<li>optimize replica placement</li>
</ul>
</li>
<li>World Wide Web design: caching, searching, scheduling<ul>
<li>Global scale distributed system; end-users</li>
<li>Read-intensive; prefetching over caching</li>
<li>Object search and navigation are resource-intensive</li>
<li>User-perceived latency</li>
</ul>
</li>
<li>Distributed shared memory abstraction(共享内存抽象)<ul>
<li>Wait-free algorithm design(无等待算法设计): process completes execution, irrespective of actions of other processes, i.e., n - 1 fault-resilience</li>
<li>Mutual exclusion(相互排斥)<ul>
<li>Bakery algorithm, semaphores(信号量), based on atomic hardware primitives, fast algorithms when contention-free access</li>
</ul>
</li>
<li>Register constructions<ul>
<li>Revisit assumptions about memory access</li>
<li>What behavior under concurrent unrestricted access to memory? 并发无限制访问内存Foundation for future architectures, decoupled with technology (semiconductor, biocomputing, quantum …)</li>
</ul>
</li>
<li>Consistency models:<ul>
<li>coherence versus access cost trade-off(一致性和访问成本相比)</li>
<li>Weaker models(弱模型) than strict consistency of uniprocessors(单一处理器的严格一致性)</li>
</ul>
</li>
</ul>
</li>
<li>Reliable and fault-tolerant distributed systems<ul>
<li>Consensus algorithms(共识算法): processes reach agreement in spite of faults (under various fault models)，尽管存在故障流程仍能达成一致</li>
<li>Replication and replica management(复制和副本管理)</li>
<li>Voting and quorum(法定人数) systems</li>
<li>Distributed databases, commit: ACID properties</li>
<li>Self-stabilizing systems: ”illegal” system state changes to ”legal” state; requires built-in redundancy(内置冗余)</li>
<li>Checkpointing and recovery algorithms: roll back and restart from earlier ”saved” state(回滚并从之前的“已保存”状态重新启动)</li>
</ul>
</li>
<li>Failure detectors(故障检测器):<ul>
<li>Difficult to distinguish a ”slow” process/message from a failed process/ never sent message(很难区分 “缓慢进程、消息和失败进程、从未发送的消息)</li>
<li>algorithms that ”suspect” a process as having failed and converge on a determination of its up/down status</li>
</ul>
</li>
<li>Load balancing(负载平衡，动态减少延迟和动态提高吞吐量): to reduce latency, increase throughput, dynamically. E.g., server farms<ul>
<li>Computation migration(计算迁移): relocate processes to redistribute workload(重新分配工作负载)</li>
<li>Data migration(数据迁移): move data, based on access patterns(访问模式)</li>
<li>Distributed scheduling(分布式调度): across processors(跨处理器)</li>
</ul>
</li>
<li>Real-time scheduling: difficult without global view, network delays make task harder(实时调度：没有全局视图会很困难，网络延迟会导致任务更困难)</li>
<li>Performance modeling and analysis: Network latency to access resources must be reduced(性能建模和分析：必须减少访问资源的网络延迟)<ul>
<li>Metrics: theoretical measures for algorithms, practical measures for systems(度量：算法的理论度量，系统的实际度量)</li>
<li>Measurement methodologies and tools(测量方法和工具)</li>
</ul>
</li>
<li>系统设计<ul>
<li>正确的接口设计和抽象</li>
<li>如何换分功能和可扩展性</li>
</ul>
</li>
<li>一致性<ul>
<li>如何一致共享数据</li>
</ul>
</li>
<li>容错<ul>
<li>如何保障系统在出现部分失效的情况下继续正常运行</li>
</ul>
</li>
<li>不同的部署场景<ul>
<li>集群、广域分布、传感网络</li>
</ul>
</li>
<li>实现<ul>
<li>如何最大化并行，突破性能瓶颈，平衡负载</li>
</ul>
</li>
</ul>
<h3 id="Applications-and-Emerging"><a href="#Applications-and-Emerging" class="headerlink" title="Applications and Emerging"></a>Applications and Emerging</h3><ul>
<li>Mobile systems(移动系统)<ul>
<li>Wireless communication(无线通信): unit disk model(磁盘单元); broadcast medium(MAC，广播媒体), power management(能源管理) etc.</li>
<li>CS perspective: routing(路由), location management(位置管理), channel allocation(信道分配), localization(定位) and position estimation(位置估计), mobility management(移动管理)</li>
<li>Base station model(基站模型)(cellular model，蜂窝模型)</li>
<li>Ad-hoc network model(rich in distributed garph theory problems)</li>
</ul>
</li>
<li>Sensor networks(传感器网络): Processor with electro-mechanical interface(机电接口)</li>
<li>Ubiquitous or pervasive computing(普适计算)<ul>
<li>Processors embedded in and seamlessly pervading environment(嵌入并无缝渗透环境的处理器)</li>
<li>Wireless sensor and actuator mechanisms(执行机制); self-organizing(自组织); network-centric(网络中心化), resource-constrained(资源受限)</li>
<li>E.g., intelligent home, smart workplace</li>
</ul>
</li>
<li>Peer-to-peer computing(点对点计算):<ul>
<li>No hierarchy(没有等级制度); symmetric role(对称角色); self-organizing(自组织); efficient object storage and lookup(高效的对象存储和查找); scalable(可扩展性); dynamic reconfig(动态重新配置)</li>
</ul>
</li>
<li>Publish/subscribe(发布和订阅), content distribution(内容分发)<ul>
<li>Filtering information to extract that of interest(过滤信息，只提取自己感兴趣的)</li>
</ul>
</li>
<li>Distributed agents(分布式代理)<ul>
<li>Processes that move and cooperate to perform specific tasks(处理器移动和协作执行特定的任务); coordination, controlling mobility(控制移动性), software design and interfaces</li>
</ul>
</li>
<li>Distributed data mining(分布式数据挖掘)<ul>
<li>Extract patterns/trends of interest(提取感兴趣的模式/趋势)</li>
<li>Data not available in a single repository(数据在单个存储库不可用)</li>
</ul>
</li>
<li>Grid computing(网格计算)<ul>
<li>Grid of shared computing resources; use idle CPU cycles</li>
<li>Issues: scheduling, QOS guarantees, security of machines and jobs</li>
</ul>
</li>
<li>Security(安全)<ul>
<li>Confidentiality(机密性), authentication(身份验证), availability(可用性) in a distributed setting</li>
<li>Manage wireless, peer-to-peer, grid environments<ul>
<li>Issues: e.g., lack of trust, broadcast media, resource-constrained, lack of structure</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="理解的谬误"><a href="#理解的谬误" class="headerlink" title="理解的谬误"></a>理解的谬误</h2><ul>
<li>The network is reliable(网络不一定是可靠的)</li>
<li>Latency is ZERO(肯定有延迟)</li>
<li>Bandwidth is infinite(带宽是有限的)</li>
<li>The network is secure(网络不一定安全)</li>
<li>Topology doesn’t change(拓扑会动态改变)</li>
<li>There is only one administrator(不止一个管理员)</li>
<li>Transport costs(传输有代价)</li>
<li>The network is nomogeneous(网络有一定规则)</li>
</ul>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式计算模型</title>
    <url>/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="分布式计算模型"><a href="#分布式计算模型" class="headerlink" title="分布式计算模型"></a>分布式计算模型</h1><h2 id="典型分布式系统-Ray"><a href="#典型分布式系统-Ray" class="headerlink" title="典型分布式系统(Ray)"></a>典型分布式系统(Ray)</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Ray.png" alt="img"></p>
<h2 id="Distributed-Program"><a href="#Distributed-Program" class="headerlink" title="Distributed Program"></a>Distributed Program</h2><ul>
<li>a distributed program is composed of a set of asynchronous processes $p_1, p_2, … , p_i, … , p_n$(异步进程的集合)</li>
<li>The processes do not share a global memory and communicate solely by passing messages(消息传递，没有共享内存)</li>
<li>The processes do not share a global clock that is instantaneously accessible to these processes(不共享可以即时访问的全局时钟)</li>
<li>Process execution and message transfer are asynchronous(进程运行和消息收发是异步发)</li>
<li>Without loss of generality(为了不失去一般性), we assume that each process is running on a different processor(假设每个进程运行在不同的处理器上)</li>
<li>Let $C<em>{ij}$  denote the channel(信道) from process $p_i$ to process $p_j$ and let $m</em>{ij}$ denote a message(消息) sent by $p_i$ to $p_j$</li>
<li>The message transmission delay is definite and unpredictable(传输延迟确定的但不可预测，只要传了，延迟就是确定的，但不知道什么时候传，所以是不可预测？)</li>
</ul>
<h2 id="A-Model-of-Distributed-Executions-分布式执行的模型"><a href="#A-Model-of-Distributed-Executions-分布式执行的模型" class="headerlink" title="A Model of Distributed Executions(分布式执行的模型)"></a>A Model of Distributed Executions(分布式执行的模型)</h2><ul>
<li>The execution of a process consists of a sequential execution of its actions(进程由一系列顺序执行的动作组成)</li>
<li>The actions are atomic(动作是原子化的) and the actions of a process are modeled as three types of events, namely, <ul>
<li>internal events, 内部事件</li>
<li>message send events, 消息发送事件</li>
<li>message receive events, 消息接收事件</li>
</ul>
</li>
<li>Let $e_i^x$ denote the $x^{th}$ event at process $p_i$</li>
<li>For a message $m$, let $send(m)$ and $rec(m)$ denote its send and receive events, respectively</li>
<li>The occurrence of events changes the states of respective processes and channels(每个事件的发生会改变对应进程和信道的状态)<ul>
<li>An internal event changes the state of the process at which it occurs(内部事件只影响进程)</li>
<li>A send event changes the state of the process that sends the message and the state of the channel on which the message is sent(发送事件影响发送消息的进程和发送消息的信道)</li>
<li>A receive event changes the state of the process that receives the message and the state of the channel on which the message is received(接收事件影响接收消息的进程和接收消息的信道)</li>
</ul>
</li>
<li>The events at a process are linearly ordered by their order of occurence(一个进程的事件根据发生的顺序能线性排序)</li>
<li>The execution of process $p_i$ produces a sequence of events $e_i^1, e_i^2, … , e_i^x, e_i^{x+1}, …$ and is denoted by $H_i$ where<ul>
<li>$ H_i = (h_i, \rightarrow_i)$</li>
<li>$h_i$ is the set of events produced by $p_i$</li>
<li>binary relation $\rightarrow_i$ defines a linear order on these events, expresses causal dependencies among the events of $p_i$(右箭头表示的是具有因果关系)</li>
</ul>
</li>
<li>The send and the receive events signify the flow of information between processes and establish causal dependency from the sender process to the receiver process(进程之间的发送和接收事件的关系，从发送方到接收方建立因果依赖关系)</li>
<li>A relation $\rightarrow_{msg}$ that captures the causal dependency due to message exchange, is defined as follows. For every message $m$ that is exchanged between two processes, we have<ul>
<li>$send(m)\rightarrow_{msg}\quad rec(m)$</li>
<li>defines causal dependencies between the pairs of corresponding send and receiver events</li>
</ul>
</li>
<li>A space-time diagram Example:<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/The%20space-time%20diagram%20of%20a%20distributed%20execution.png" alt="img"><ul>
<li>The evolution of a distributed execution is depicted by a space-time diagram(时空图).</li>
<li>A horizontal line represents the progress of the process(水平线表示进程的进度), a dot indicates an event(点表示事件), a slant arrow indicates a message transfer(斜箭头表示消息传递)<ul>
<li>Since we assume that an event execution is atomic(hence, indivisible and instantaneous(不可再分以及瞬时)), it is justified to denote it as a dot on a process line</li>
</ul>
</li>
<li>In the Figure, <ul>
<li>for process $p_1$, the second event is a message send event, </li>
<li>the third event is an internal event, </li>
<li>and the fourth event is a message receive event</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Causal-Precedence-Relation-因果过程关系"><a href="#Causal-Precedence-Relation-因果过程关系" class="headerlink" title="Causal Precedence Relation(因果过程关系)"></a>Causal Precedence Relation(因果过程关系)</h3><ul>
<li>The execution of a distributed application results in a set of distributed events produced by the processes(分布式应用的结果由进程产生的分布式事件得到的)</li>
<li>Let $H=\bigcup_i h_i$ denote the set of events executed in a distributed computation(分布式计算中的事件集合)</li>
<li>Define a binary relation $\rightarrow$ on the set $H$ as follows that express causal dependencies between events in the distributed execution <script type="math/tex; mode=display">
\forall e_i^x, \forall e_j^y \in H, e_i^x\rightarrow e_j^y \Leftrightarrow 
  \begin{cases}
    e_i^x\rightarrow_i e_j^y :i.e., (i=j)\bigwedge(x<y)\\
    or\\
    e_i^x\rightarrow_{msg}e_j^y\\
    or\\
    \exists e_k^z\in H : e_i^x\rightarrow e_k^z \bigwedge e_k^z \rightarrow e_j^y
  \end{cases}</script></li>
<li>The causal precedure relation induces an irreflexive partial order(不可弯曲的偏序) on the events of a distributed computation that is denoted as $H=(H,\rightarrow)$</li>
<li>Note that the relation $\rightarrow$ is nothing but Lamport’s “happens before” relation(这个关系就是在…之前发生)</li>
<li>For any two event $e_i$ and $e_j$, if $e_i\rightarrow e_j$, then event $e_j$ is directly or transitively(直接或传递性地) dependent on event $e_i$(Graphically, it means that there exists a path consisting of message arrows and process-line segments(along increasing time) in the space-time diagram that starts at $e_i$ and ends at $e_j$)<ul>
<li>For example, in Figure above, $e_1^1\rightarrow e_3^3$ and $e_3^3\rightarrow e_2^6$</li>
</ul>
</li>
<li>The relation $\rightarrow$ denotes flow of information in a distributed computation and $e_i\rightarrow e_j$ dictates that all the information available at $e_i$ is potentially accessible at $e_j$<ul>
<li>For example, in Figure above, event $e_2^6$ has the knowledge of all other events shown in the figure</li>
</ul>
</li>
<li>For any two events $e_i$ and $e_j$, $e_i \nrightarrow e_j$ denotes the fact that event $e_j$ does not directly or transitively dependent on event $e_i$. That is, event $e_i$ does not causally affect event $e_j$</li>
<li>In this case, event $e_j$ is not aware of the execution of $e_i$ or any event executed after $e_i$ on the same process</li>
<li>For example, in Figure above, $e_1^3 \nrightarrow e_3^3$ and $e_2^4\nrightarrow e_3^1$</li>
<li>For any two events $e_i$ and $e_j$, $e_i\nrightarrow e_j\nRightarrow e_j\nrightarrow e_i$(因为可能$e_j\rightarrow e_i$)</li>
<li>For any two events $e_i$ and $e_j$, $e_i\rightarrow e_j\Rightarrow e_j\nrightarrow e_i$</li>
</ul>
<h3 id="Concurrent-events-并发事件"><a href="#Concurrent-events-并发事件" class="headerlink" title="Concurrent events(并发事件)"></a>Concurrent events(并发事件)</h3><ul>
<li>For any two events $e_i$ and $e_j$, if $e_i\nrightarrow e_j$ and $e_j\nrightarrow e_i$, then events $e_i$ and $e_j$ are said to be concurrent(denoted as $e_i||e_j$，互相没有因果关系)</li>
<li>In the execution of Figure above, $e_1^3||e_3^3$ and $e_2^4||e_3^1$</li>
<li>The relation $||$ is not transitive(并发不是传递性的); that is, $(e_i||e_j)\bigwedge(e_j||e_k)\nRightarrow e_i || e_k$<ul>
<li>For example, in Figure above, $e_3^3||e_2^4$ and $e_2^4 || e_1^5$, however, $e_3^3 \nmid\nmid e_1^5$</li>
</ul>
</li>
<li>For any two events $e_i$ and $e_j$ in a distributed execution, 要不就有因果关系，要不就是并发<ul>
<li>$e_i\rightarrow e_j$</li>
<li>$e_j\rightarrow e_i$</li>
<li>$e_i||e_j$</li>
</ul>
</li>
</ul>
<h3 id="Logical-Concurrency-and-Physical-Concurrency-逻辑并发和物理并发"><a href="#Logical-Concurrency-and-Physical-Concurrency-逻辑并发和物理并发" class="headerlink" title="Logical Concurrency and Physical Concurrency(逻辑并发和物理并发)"></a>Logical Concurrency and Physical Concurrency(逻辑并发和物理并发)</h3><ul>
<li>In a distribued computation, two events are logically concurrent if and only if they do not casually affect each other(互相之间没有因果就是逻辑并发的)</li>
<li>Physical concurrency, on the other hand, has a connotation that the events occur at the same instant in physical time(在同一物理时间的瞬间发生)</li>
<li>Two or more events may be logically concurrent even though they do not occur at the same instant in physical time</li>
<li>However, if processor speed and message delays would have been different, the execution of these events could have very well coincided in physical time</li>
<li>Whether a set of logically concurrent events coincide in the physical time or not, does not change the outcome of the computation(逻辑并发的结果不受物理时间的影响)</li>
<li>Therefore, even though a set of logically concurrent events may not have occured at the same instant in physical time, we can assume that these events occured at the same instant in physical time</li>
</ul>
<h2 id="Models-of-Communication-Networks"><a href="#Models-of-Communication-Networks" class="headerlink" title="Models of Communication Networks"></a>Models of Communication Networks</h2><ul>
<li>There are several models of the service provided by communication networks, namely, </li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO,"></a>FIFO,</h3><ul>
<li>each channel acts as a first-in first-out message queue(先进先出队列) and thus, message ordering is preserved by a channel(消息顺序由信道维护)</li>
</ul>
<h3 id="Non-FIFO"><a href="#Non-FIFO" class="headerlink" title="Non-FIFO,"></a>Non-FIFO,</h3><ul>
<li>a channel acts like a set in which the sender process adds messages and the receiver process removes messages from it in a random order(随机序列)</li>
</ul>
<h3 id="causal-ordering-因果序"><a href="#causal-ordering-因果序" class="headerlink" title="causal ordering(因果序)"></a>causal ordering(因果序)</h3><ul>
<li>is based on Lamport’s “happens before” relation</li>
<li>A system that supports the causal ordering model satisfies the following property:<ul>
<li>CO: For any two messages $m<em>{ij}$ and $m</em>{kj}$, if $send(m<em>{ij})\rightarrow send(m</em>{kj})$, then $rec(m<em>{ij})\rightarrow rec(m</em>{kj})$</li>
<li>This property ensures that causally related messages destined to the same destination are delivered in an order that is consistent with their causality relation(因果相关的信息与其因果关系一致地顺序传递)</li>
</ul>
</li>
<li>Causally ordered delivery of messages implies FIFO message delivery.(Note that $CO \subset FIFO \subset Non-FIFO$，CO是特殊的FIFO，FIFO又是特殊的Non-FIFO)</li>
<li>Causal ordering model considerably simplifies the design of distributed algorithms because it provides a built-in synchronization(内置同步)</li>
</ul>
<h2 id="Global-State-of-a-Distributed-System"><a href="#Global-State-of-a-Distributed-System" class="headerlink" title="Global State of a Distributed System"></a>Global State of a Distributed System</h2><ul>
<li><p>“A collection of the local states of its components, namely, the processes and the communication channels”(全局状态包括进程状态和信道状态)</p>
<ul>
<li>The state of a process is defined by the contents of processor registers, stacks, local memory, etc. and depends on the local context of the distributed application</li>
<li>The state of channel is given by the set of messages in transit in the channel</li>
</ul>
</li>
<li><p>The occurrence of events changes the states of respective processes and channels(状态改变由事件的发生引起)</p>
<ul>
<li>An internal event changes the state of the process at which it occurs(内部事件只影响对应进程)</li>
<li>A send event changes the state of the process that sends the message and the state of the channel on which the message is sent(发送事件除了影响进程还影响信道)</li>
<li>A receive event changes the state of the process that or receives the message and the state of the channel on which the message is received(接收事件除了影响进程还影响信道)</li>
</ul>
</li>
</ul>
<h3 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h3><h4 id="Local-State"><a href="#Local-State" class="headerlink" title="Local State"></a>Local State</h4><ul>
<li>$LS_i^x$ denotes the state of process $p_i$ after the occurrence of event $e_i^x$ and before the event $e_i^{x+1}$(local state)<ul>
<li>$LS_i^0$ denotes the initial state of process $p_i$</li>
<li>$LS_i^x$ is a result of the execution of all the events executed by process $p_i$ till $e_i^x$(之前的所有事件)</li>
</ul>
</li>
<li>Let $send(m) \leq LS_i^x$ denote the fact that $\exists y:1\leq y\leq x :: e_i^y=send(m)$(发送事件早于某个LS状态，说明该状态以前的事件有该发送事件)</li>
<li>Let $rec(m) \nleq LS_i^x$ denote the fact that $\forall y:1\leq y\leq x :: e_i^y\neq rec(m)$(接收时间不早于某个LS状态，说明该状态以前的事件中不包括该接收事件)</li>
</ul>
<h4 id="A-Channel-State-信道状态"><a href="#A-Channel-State-信道状态" class="headerlink" title="A Channel State(信道状态)"></a>A Channel State(信道状态)</h4><ul>
<li>The state of a channel depends upon the states of the process it connects(取决于信道所连接的进程的状态)</li>
<li>Let $SC<em>{ij}^{x, y}$ denote the state of a channel $C</em>{ij}$</li>
<li>The state of a channel is defined as follows:<ul>
<li>$SC_{ij}^{x, y}$ denotes all messages that $p_i$ sent upto event $e_i^x$ and which process $p_j$ had not received until event $e_j^y$(进程i在事件x发送消息，并且进程j在事件y接收到消息)</li>
</ul>
</li>
</ul>
<h4 id="Global-State-全局状态，不太可能，只存在与理论"><a href="#Global-State-全局状态，不太可能，只存在与理论" class="headerlink" title="Global State(全局状态，不太可能，只存在与理论)"></a>Global State(全局状态，不太可能，只存在与理论)</h4><ul>
<li>The global state of a distributed system is a collection of the local states of the processes and the channels(进程本地状态和信道状态的集合)</li>
<li>Notationally, global state $GS$ is defined as,<ul>
<li>$GS={\bigcup<em>iLS_i^{x_i}, \bigcup</em>{j, k}SC_{jk}^{y_j, z_k}}$</li>
</ul>
</li>
<li>For a global state to be meaningful, the states of all the components of the distributed system must be recorded at the same instant(分布式系统中的所有组件的状态需要在相同的时刻记录)</li>
<li>This will be possible if the local clocks at processes were perferctly synchronized or if there were a global system clock that can be instantaneously read by the process(However, both are impossible)(如果要实现的话，要求时钟完美同步或者存在一个全局系统的时钟可以被进程即时读取)</li>
</ul>
<h4 id="A-Consistent-Global-State-一致的全局状态"><a href="#A-Consistent-Global-State-一致的全局状态" class="headerlink" title="A Consistent Global State(一致的全局状态)"></a>A Consistent Global State(一致的全局状态)</h4><ul>
<li>Even if the state of all the components is not recorded at the same instant, such a state will be meaningful provided every message that is recorded as received is also recorded as sent(要求每个接收事件都有对应的发送事件)</li>
<li>Basic idea is that a state should not violate causality(不能违反因果律)<ul>
<li>an effect should not be present without its cause. A message cannot be received if it was not sent.(没有发送不可能有接收)</li>
</ul>
</li>
<li>Such states are called consistent global states and are meaningful global states.</li>
<li>Inconsistent global states are not meaningful in the sense that a distributed system can never be in an inconsistent state(分布式系统永远不可能处于不一致状态).</li>
<li>A global state $GS={\bigcup<em>iLS_i^{x_i}, \bigcup</em>{j, k}SC_{jk}^{y_j, z_k}}$ is a consistent global state iff(if and only if):<ul>
<li>$\forall m<em>{ij}:send(m</em>{ij})\nleq LS<em>i^{x_i} \Leftrightarrow m</em>{ij} \notin SC<em>{ij}^{x_i, y_j}\bigwedge rec(m</em>{ij})\nleq LS_j^{y_j}$(发送的消息要不还在信道中，要不就已经被接收，不能出现有接收但没发送)</li>
<li>channel state $SC_{ij}^{y_i, z_k}$ and process state $LS_j^{z_k}$ must not include any message that process $p_i$ sent after executing event $e_i^{x_i}$</li>
</ul>
</li>
<li>Example<ul>
<li>A global state $GS<em>1={LS_1^1, LS_2^3, LS_3^3, LS_4^2}$ is inconsistent, because the state of $p_2$ has recorded the receipt of message $m</em>{12}$, however, the state of $p_1$ has not recorded its send</li>
<li>A global state $GS<em>2$ consisting of local states ${LS_1^2, LS_2^4, LS_3^4, LS_4^2}$ is consistent, all the channels are empty except $C</em>{21}$ that contains message $m_{21}$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/The%20space-time%20diagram%20of%20a%20distributed%20execution2.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="Cuts-of-a-Distributed"><a href="#Cuts-of-a-Distributed" class="headerlink" title="Cuts of a Distributed"></a>Cuts of a Distributed</h2><ul>
<li>In the space-time diagram of a distributed computation, a cut is a zigzag line(锯齿线) joining one arbitrary point on each process line(连接每个进程线上任意一点)</li>
<li>A cut slices the space-time diagram, and thus the set of events in the distributed computation, into a <code>PAST</code> and a <code>FUTURE</code>.(cut将时空图分为过去和将来)<ul>
<li>The <code>PAST</code> contains all the events to the left of the cut </li>
<li>The <code>FUTURE</code> contains all the events to the right of the cut.</li>
<li>For a cut <code>C</code>, let <code>PAST(C)</code> and <code>FUTURE(C)</code> denote the set of events in the <code>PAST</code> and <code>FUTURE</code> of <code>C</code>, respectively.</li>
</ul>
</li>
<li>Every cut corresponds to a global state and every global state can be graphically represented as a cut in the computation’s space-time diagram.(每个cut对应一个全局状态，每个全局状态都可以在计算的时空图中以图形的方式表示cut)<ul>
<li>Cuts in a space-time diagram provide a powerful graphical aid in representing and reasoning about global states of a computation.</li>
<li>In a consistent cut, every message received in the PAST of the cut was sent in the PAST of that cut. (In Figure 2.3, cut C2 is a consistent cut. 过去接收到的消息只能是过去发送的)</li>
<li>All messages that cross the cut from the PAST to the FUTURE are in transit in the corresponding consistent global state.(未来收到的消息可能是过去发送的，也可能是未来发送的)</li>
<li>A cut is inconsistent if a message crosses the cut from the FUTURE to the PAST. (In Figure 2.3, cut C1 is an inconsistent cut.)(但是未来发送的消息不可能在过去被接收)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Illustration%20of%20cuts%20in%20a%20distributed%20exection.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="Past-and-Future-Cones-of-an-Event"><a href="#Past-and-Future-Cones-of-an-Event" class="headerlink" title="Past and Future Cones of an Event"></a>Past and Future Cones of an Event</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Illustration%20of%20past%20and%20future%20cones.png" alt="img"></p>
<h3 id="Past-Cone-of-an-Event-事件因果关系的因"><a href="#Past-Cone-of-an-Event-事件因果关系的因" class="headerlink" title="Past Cone of an Event(事件因果关系的因)"></a>Past Cone of an Event(事件因果关系的因)</h3><ul>
<li>An event $e_j$ could have been affected only by all events $e_i$ such that $e_i\rightarrow e_j$</li>
<li>In this situation, all the information available at $e_i$ could be made accessible at $e_j$</li>
<li>All such events $e_i$ belong to the past of $e_j$<ul>
<li>Let $Past(e_j)$ denote all events in the past of $e_j$ in a computation $(H, \rightarrow)$. Then, <ul>
<li>$Past(e_j) = {e_i\mid \forall e_i\in H, e_i\rightarrow e_j}$</li>
<li>$Past(e_j)$ represents all events on the past light cone that affect $e_j$  </li>
</ul>
</li>
</ul>
</li>
<li>Let $Past_i(e_j)$ be the set of all those events of $Past(e_j)$ that are on process $p_i$<ul>
<li>$Past_i(e_j)$ is a totally ordered set(顺序集), ordered by the relation $\rightarrow_i$, whose maximal element is denoted by $max(Past_i(e_j))$<ul>
<li>$max(Past_i(e_j))$ is the <strong>latest event</strong> at process $p_i$ that affected event $e_j$</li>
</ul>
</li>
<li>Let $Max_Past(e<em>j) = \bigcup</em>{(\forall i)} {max(Past_i(e_j))}$(所有进程中的latest event)<ul>
<li>$Max_Past(e_j)$ consists of the latest event at every process that affected event $e_j$ and is referred to as the surface of the past cone of $e_j$(past cone的latest平面)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Future-Cone-of-an-Event-事件因果关系中的果"><a href="#Future-Cone-of-an-Event-事件因果关系中的果" class="headerlink" title="Future Cone of an Event(事件因果关系中的果)"></a>Future Cone of an Event(事件因果关系中的果)</h3><ul>
<li>The future of an event $e_j$, denoted by $Future(e_j)$, contains all events $e_i$ that are causally affected by $e_j$</li>
<li>In a computation $(H, \rightarrow)$, $Future(e_j)$ is defined as:<ul>
<li>$Future(e_j) = {e_i\mid \forall e_i \in H, e_j\rightarrow e_i}$</li>
</ul>
</li>
<li>Define $Future_i(e_j)$ as the set of those events of $Future(e_j)$ that are on process $p_i$<ul>
<li>define $min(Future_i(e_j))$ as the <strong>first event</strong> on process $p_i$ that is affected by $e_j$</li>
<li>Define $Min<em>Future(e_j)$ as $\bigcup</em>{(\forall i)}{min(Future_i(e_j))}$, which consists of the first event at every process that is causally affected by event $e_j$(所有进程中的first event)</li>
<li>$Min_Future(e_j)$ is referred to as the surface of the future cone of $e_j$(事件j的future cone平面)</li>
<li>All events at a process $p_i$ that occurred after $max(Past_i(e_j))$ but before $min(Future_i(e_j))$ are concurrent with $e_j$(与事件j无因果关系)</li>
<li>Therefore, all and only those events of computation $H$ that belong to the set “$H - Past(e_j) - Future(e_j)$” are concurrent with event $e_j$(所有事件去掉有因果关系的得到的便是并发的事件)</li>
</ul>
</li>
</ul>
<h2 id="Model-of-Process-Communications"><a href="#Model-of-Process-Communications" class="headerlink" title="Model of Process Communications"></a>Model of Process Communications</h2><ul>
<li>There are two basic models of process communications(进程通信)<ul>
<li>synchronous communication model(同步通信模型，阻塞的)<ul>
<li>a blocking type where on a message send, the sender process blocks until the message has been received by the receiver process</li>
<li>The sender process resumes execution only after it learns that the receiver process has accepted the message</li>
<li>Thus, the sender and the receiver processes must synchronize to exchange a message</li>
</ul>
</li>
<li>asynchronous communication models of process communicatiion(异步通信模型，非阻塞的)<ul>
<li>a non-blocking type where the sender and the receiver do not synchronize to exchange a message</li>
<li>After having sent a message, the sender process does not wait for the message to be delivered to the receiver process</li>
<li>The message is bufferred by the system(消息需要操作系统进行缓存) and is delivered to the receiver process when it is ready to accept the message</li>
</ul>
</li>
</ul>
</li>
<li>Neither of the communication models is superior to the other.(两者各有优劣)<ul>
<li>Asynchronous communication provides higher parallelism because the sender process can execute while the message is in transit to the receiver(异步提供更高的并行性)<ul>
<li>However, a buffer overflow may occur if a process sends a large number of message in a burst to another process(可能会缓存溢出)</li>
<li>Thus, an implementation of asynchronous communication requires more complex buffer management(异步系统要求更复杂的缓存管理)</li>
<li>In addition, due to higher degree of parallelism and non-determinism(更高的并行性和更高的非确定性), it is much more difficult to design, verify, and implement distributed algorithms for asynchronous communications(难以为异步通信设计、验证、实现分布式算法)</li>
</ul>
</li>
<li>Synchronous communication is simpler to handle and implement(同步通信更简单管理和实现)<ul>
<li>However, due to frequent blocking, it is likely to have poor performance and is likely to be more prone to deadlocks(频繁地阻塞，性能更差，更可能出现死锁)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑时间</title>
    <url>/2024/09/29/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-29-%E9%80%BB%E8%BE%91%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="逻辑时间"><a href="#逻辑时间" class="headerlink" title="逻辑时间"></a>逻辑时间</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>The concept of causality between events(事件的因果) is fundamental to the design and analysis of parallel and distributed computing and operating systems<ul>
<li>Usually causality is tracked using physical time, but in distributed systems, it is not possible to have a global physical time(分布式系统中很难使用统一的全局物理时钟)</li>
<li>As asynchronous distributed computations make progress in spurts, the logical time is sufficient to capture the fundamental monotonicity property associated with causality in distributed systems(逻辑时间足以捕捉分布式系统中与因果关系相关的基本单调性)</li>
</ul>
</li>
<li>three ways to implement logical time <ul>
<li>scalar time(标量时间)</li>
<li>vector time(矢量时间)</li>
<li>matrix time(矩阵时间)</li>
</ul>
</li>
<li>Causality among events in a distributed system is a powerful concept in reasoning, analyzing, and drawing inferences about a computation</li>
<li>The knowledge of the causal precedence relation among the events of processes helps solve a variety of problems in distributed systems, such as distributed algorithms design, tracking of dependent events, knowledge about the progress of a computation, and concurrency measures(因果进程关系很重要)</li>
</ul>
<h2 id="A-Framework-for-a-System-of-Logical-Clocks"><a href="#A-Framework-for-a-System-of-Logical-Clocks" class="headerlink" title="A Framework for a System of Logical Clocks"></a>A Framework for a System of Logical Clocks</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><h4 id="Logical-clock"><a href="#Logical-clock" class="headerlink" title="Logical clock"></a>Logical clock</h4><ul>
<li>A system of logical clocks consists of a time domian $T$(逻辑时钟组成的系统)</li>
<li>a logical clock $C$<ul>
<li>$C$ is a function that maps an event $e$ in a distributed system to an element in the time domain $T$(一个事件映射一个逻辑时钟的时间戳), denoted as $C(e)$ and called the timestamp of $e$, and is defined as follows;<ul>
<li>$C:\Eta \rightarrowtail T$</li>
</ul>
</li>
<li>such that the following property is satisfied:<ul>
<li>for two events $e_i$ and $e_j$, $e_i\rightarrow e_j \Rightarrow C(e_i) &lt; C(e_j)$(互为因果的两个事件，因的逻辑时间应该比果的逻辑时间小)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Relation-“-lt-”"><a href="#Relation-“-lt-”" class="headerlink" title="Relation “&lt;”"></a>Relation “&lt;”</h4><ul>
<li>Elements of $T$ form a partically ordered set(部分有序集合) over a relation $&lt;$<ul>
<li>Relation $&lt;$ is called the “happened before” or “causal precedure”(在…前发生或因果序列). This relation is analogous to the earlier than relation provided by the physical time</li>
</ul>
</li>
</ul>
<h4 id="The-Clock-Consistency-Condition"><a href="#The-Clock-Consistency-Condition" class="headerlink" title="The Clock Consistency Condition"></a>The Clock Consistency Condition</h4><ul>
<li>This monotonicity property is called the clock consistency condition(时钟一致性的条件)<ul>
<li>When $T$ and $C$ satisfy the following condition, for two events $e_i$ and $e_j$, $e_i\rightarrow e_j \Leftrightarrow C(e_i) &lt; C(e_j)$, the system of clocks is said to be strongly consistent(强一致性，只有向右箭头的话只是弱一致性)</li>
</ul>
</li>
</ul>
<h3 id="Implementing-Logical-Clocks"><a href="#Implementing-Logical-Clocks" class="headerlink" title="Implementing Logical Clocks"></a>Implementing Logical Clocks</h3><ul>
<li>Implementation of logical clocks requires addressing two issues(解决两个问题)<ul>
<li>data structures</li>
<li>protocol</li>
</ul>
</li>
<li>Systems of logical clocks differ in their representation of logical time and also in the protocol to update the logical clocks(不同的逻辑时钟系统是逻辑时钟的表达(数据结构)和如何更新逻辑时钟的协议不同)</li>
</ul>
<h4 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h4><ul>
<li>data structures local to every process to represent logical time(每个进程的本地数据结构，用于表示逻辑时间)<ul>
<li>Each process $p_i$ maintains data structure that allow it the following two capabilities:</li>
<li>A logical local clock(逻辑本地时间): denoted by $lc_i$, which helps process $p_i$ measure its own progress(用于进程估量自己)</li>
<li>A logical global clock(逻辑全局时间): denoted by $gc_i$, which is a representation of process $p_i$’s local view of the logical global time.(用于进程自己估量全局)</li>
<li>Typically, $lc_i$ is a part of $gc_i$</li>
</ul>
</li>
</ul>
<h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><ul>
<li>a protocol to update the data structures to ensure the consistency condition(更新数据结构的数据和确保一致性条件的协议)<ul>
<li>The protocol ensures that a process’s logical clock, and thus its view of the global time, is managed consistently(一致地管理逻辑时钟和全局时间). The protocol consists of the following two rules:<ul>
<li>R1: This rule governs how the logical local clock is updated by a process when it executes an event(进程在执行事件的时候如何更新逻辑本地时间)</li>
<li>R2: This rule governs how a process updates its logical global clock to update its view of the global time and global progress(进程更新全局逻辑时钟，以更新全局时间和全局进程的视图)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Scalar-Time-标量时间-Lamport’s-Logical-Clocks"><a href="#Scalar-Time-标量时间-Lamport’s-Logical-Clocks" class="headerlink" title="Scalar Time(标量时间, Lamport’s Logical Clocks)"></a>Scalar Time(标量时间, Lamport’s Logical Clocks)</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><ul>
<li>Proposed by Lamport in 1978 as an attempt to totally order events in a distributed system(尝试对事件进行完全排序)</li>
<li>Time domain is the set of non-negative integers(时间域是非负整数的集合)</li>
<li>The logical local clock of a process $p_i$, and its local view of the global time are squashed into one integer variable $C_i$(本地角度对全局时间的看法)</li>
<li>Rules R1 and R2 to update the clocks are as follows:<ul>
<li>R1: Before executing an event(send, receive, or internal), process $p_i$ executes the following:(执行事件之前对时间进行增加)<ul>
<li>$C_i := C_i + d ; (d &gt; 0)$</li>
<li>In general, every time R1 is executed, $d$ can have a different value; however, typically $d$ is kept at 1(通常是加1)</li>
</ul>
</li>
<li>R2: Each message piggybacks the clock value of its sender at sending time.(每条信息都附带了它的发送者在发送时的时钟值) When a process $p<em>i$ receives a message with timestamp $C</em>{msg}$, it executes the following actions:(选取本地的时间戳和接收到的消息中的时间戳中更大的作为新的本地时间戳)<ul>
<li>$C<em>i = max(C_i, C</em>{msg})$</li>
<li>Execute R1(再更新后执行一次R1，因为接收到的消息是在OS层的，要交付给应用层的过程中需要触发事件)</li>
<li>Deliver the message<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/The%20space-time%20diagram%20of%20a%20distributed%20execution_scalar.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Basic-Properties"><a href="#Basic-Properties" class="headerlink" title="Basic Properties"></a>Basic Properties</h4><ul>
<li>Consistency Property(一致性的特性)<ul>
<li>Scalar clocks satisfy the monotonicity and hence the consistency property<ul>
<li>for two events $e_i$ and $e_j$: $e_i\rightarrow e_j \Rightarrow C(e_i) &lt; C(e_j)$(弱一致性，因为反之不成立)</li>
</ul>
</li>
</ul>
</li>
<li>No Strong Consistency(非强一致性)<ul>
<li>The system of scalar clocks is not strongly consistent, that is for two events $e_i$ and $e_j$, $C(e_i) &lt; C(e_j)\nRightarrow e_i\rightarrow e_j$(无法根据逻辑时间的顺序推导出因果顺序)</li>
<li>The reason that scalar clocks are not strongly consistent is that the logical local clock and logical global clock of a process are squashed into one(进程的逻辑本地时钟和逻辑全局时钟压缩在一维标量), resulting in the loss causal dependency information among events at different processes(会出现因果依赖信息的损失)</li>
</ul>
</li>
<li>Total Ordering(完全排序)<ul>
<li>Scalar clocks can be used to totally order events in a distributed system</li>
<li>The main problem in totally ordering events is that two or more events at different processes may have identical timestamp(但也存在问题：在不同的进程中可能会有相同时间戳的事件)</li>
<li>A tie-breaking mechanism(平局打破机制) is needed to order such events. A tie is broken as follows:<ul>
<li>Process identifiers are linearly ordered and tie among events with identical scalar timestamp is broken on the basis of their process identifiers(具有相同标量时间戳的事件之间根据其所在进程的标识符来区分，标识符是线性排序的)<ul>
<li>The lower the process identifier in the ranking, the higher the priority(进程标识符越小有越高的优先权)</li>
</ul>
</li>
<li>The timestamp of an event is denoted by a tuple $(t, i)$ where $t$ is its time of occurence and $i$ is the identity of the process where it occurred(事件的时间戳表示需要加上进程的编号)</li>
<li>The total order relation $\prec$ on two events $x$ and $y$ with timestamps $(h, i)$ and $(k, j)$, respectively, is defined as follows:<ul>
<li>$x \prec y \Leftrightarrow (h&lt;k\quad or \quad (h = k\quad and\quad i &lt; j))$<ul>
<li>时间戳不同比大小，小的肯定排前面</li>
<li>时间戳相同，则比较进程号的大小，进程号小的排前面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Event Counting(事件计数，前提是累加值为1)<ul>
<li>If the increment value $d$ is always 1, the scalar time has the following interesting property: <ul>
<li>if event $e$ has a timestamp $h$, then $h-1$ represents the minimum logical duration(最小的逻辑持续), counted in units of events(前面事件的数量), required before producing the event e(or call it the height of the event e，事件e的高度)<ul>
<li>$h-1$ events have been produced sequentially(h-1个事件线性产生) before the event e regardless of the processes that produced these events(无论产生的顺序如何，这只是个整体集合)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Vector-Time-Logical-Clocks"><a href="#Vector-Time-Logical-Clocks" class="headerlink" title="Vector Time(Logical Clocks)"></a>Vector Time(Logical Clocks)</h3><ul>
<li>The system of vector clocks was developed independently by Fidge, Mattern and Schmuck</li>
<li>In the system of vector clocks, the time domain is represented by a set of n-dimensional non-negative integer vectors(时间域用一系列n维的非负整数向量表示)</li>
<li>Each process $p_i$ maintains a vector $vt_i[1…n]$, where <ul>
<li>$vt_i[i]$ is the local logical clock of $p_i$ and describes the logical time progress at process $p_i$(真正的本地逻辑时间)</li>
<li>$vt_i[j]$ represents process $p_i$’s latest knowledge of process $p_j$ local time(本地视角下其他进程的逻辑时间)<ul>
<li>If $vt_i[j] = x$, then process $p_i$ knows that local time at process $p_j$ has progressed till $x$</li>
</ul>
</li>
</ul>
</li>
<li>The entire vector $vt_i$ constitutes $p_i$’s view of the global logical time and is used to timestamp events</li>
<li>Process $p_i$ uses the following two rules R1 and R2 to update its clock:(和标量时间的更新方法是类似的)<ul>
<li>R1: Before executing an event, process $p_i$ updates its local logical time as follows:(执行事件之前对逻辑时间进行累加)<ul>
<li>$vt_i[i]:=vt_i[i]+d (d &gt; 0)$</li>
</ul>
</li>
<li>R2: Each message $m$ is piggybacked with the vector clock $vt$ of the sender process at sending time. On the receipt of such a message $(m, vt)$, process $p_i$ executes the following sequence of actions:<ul>
<li>Update its global logical time as follows:<ul>
<li>$1\leq k\leq n : vt_i[k]:=max(vt_i[k], vt[k])$</li>
<li>Execute R1</li>
<li>Deliver the message $m$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>The timestamp of an event is the value of the vector clock of its process when the event is executed(一个事件的时间戳是所在进程的向量时钟在事件被执行时的值)<ul>
<li>Initially, a vector clock is [0, 0, 0, …, 0]</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Evolution%20of%20vector%20time.png" alt="img"></p>
<h4 id="Comparing-Vector-Timestamps-比较两个向量时间戳"><a href="#Comparing-Vector-Timestamps-比较两个向量时间戳" class="headerlink" title="Comparing Vector Timestamps(比较两个向量时间戳)"></a>Comparing Vector Timestamps(比较两个向量时间戳)</h4><ul>
<li>The following relations are defined to compare two vector timestamps, $vh$ and $vk$<ul>
<li>$vh = vk \Leftrightarrow \forall x: vh[x] = vk[x]$(相等)</li>
<li>$vh \leq vk \Leftrightarrow \forall x: vh[x] \leq vk[x]$(小于等于)</li>
<li>$vh &lt; vk \Leftrightarrow vh\leq vk$ and $\exists x: vh[x] &lt; vk[x]$(小于)</li>
<li>$vh \mid\mid vk \Leftrightarrow \neg (vh &lt; vk) \bigwedge \neg(vk &lt; vh)$(并发，则互相没有大小关系)</li>
</ul>
</li>
<li>If the process at which an event occurred is known, the test to compare two timestamps can be simplified as follows:<ul>
<li>if events $x$ and $y$ respectively occurred at processes $p_i$ and $p_j$ and are assigned timestamps $vh$ and $vk$, respectively, then<ul>
<li>$x \rightarrow y \Leftrightarrow vh[i] \leq vk[i]$(x和y有因果关系，且x为因，y为果。则x发生时所在进程的逻辑时间不大于y发生时所在进程的逻辑时间)</li>
<li>$x\mid\mid y \Leftrightarrow vh[i] &gt; vk[i] \bigwedge vh[j] &lt; vk[j]$(事件x和事件y是并发的，x不晚于y，y也不晚于x)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Properties-of-Vector-Time"><a href="#Properties-of-Vector-Time" class="headerlink" title="Properties of Vector Time"></a>Properties of Vector Time</h4><ul>
<li>Isomorphism(同构性，即事件的因果关系和向量时间的比较关系等价)<ul>
<li>If events in a distributed system are timestamped using a system of vector clocks, we have the following property:<ul>
<li>If two events $x$ and $y$ have timestamps $vh$ and $vk$, respectively, then:<ul>
<li>$x\rightarrow y \Leftrightarrow vh &lt; vk$</li>
<li>$x\mid\mid y \Leftrightarrow vh\mid\mid vk$</li>
</ul>
</li>
</ul>
</li>
<li>Thus, there is an isomorphism between the set of partially ordered events produced by a distributed computation and their vector timestamps(部分有序的事件和它们的向量时间戳同构)</li>
</ul>
</li>
<li>Strong Consistency(强一致性)<ul>
<li>The system of vector clocks is strongly consistent; thus, by examining the vector timestamp of two events, we can determine if the events are causally related(检测两个事件的向量时间戳，可以确定事件是否存在因果联系)</li>
<li>However, Charron-Bost showed that the dimension of vector clocks cannot be less than $n$, the total number of processes in the distributed computation, for this property to hold(但是向量时钟必须有进程个数的维度大小)</li>
</ul>
</li>
<li>Event Counting<ul>
<li>If $d=1$ (in rule R1), then the $i^{th}$ component of vector clock at process $p_i$, $vt_i[i]$, denotes the number of events that have occurred at $p_i$ until that instant(发生了多少个事件可以看向量时间戳中对应进程的维度部分)</li>
<li>So, if an event $e$ has timestamp $vh$, $vh[j]$ denotes the number of events executed by process $p_j$ that causally precedure $e$. Clearly, $\Sigma vh[j] - 1$ represents the total number of events that causally precede $e$ in the distributed computation</li>
</ul>
</li>
</ul>
<h4 id="Efficient-Implementations-of-Vector-Clock"><a href="#Efficient-Implementations-of-Vector-Clock" class="headerlink" title="Efficient Implementations of Vector Clock"></a>Efficient Implementations of Vector Clock</h4><ul>
<li>If the number of processes in a distributed computation is large, then vector clocks will require piggybacking of huge amount of information in messages(如果分布式计算中的进程数量很多，那么在传递消息的时候需要附带很多的向量时间戳信息)</li>
<li>The message overhead grows linearly with the number of processors in the system and when there are thousands of processors in the system, the message size becomes huge even if there are only a few events occurring in few processors(消息开销随着系统中的处理器的数量线性增长)</li>
<li>We discuss an efficient way to maintain vector clocks</li>
<li>Charron-Bost showed that if vector clocks have to satisfy the strong consistency property, then in general vector timestamps must be at least of size $n$, the total number of processes</li>
<li>However, optimizations are possible and next, and we discuss a technique to implement vector clocks efficiently</li>
</ul>
<h4 id="Singhal-Kshemkalyani’s-Differential-Technique-差分优化技术"><a href="#Singhal-Kshemkalyani’s-Differential-Technique-差分优化技术" class="headerlink" title="Singhal-Kshemkalyani’s Differential Technique(差分优化技术)"></a>Singhal-Kshemkalyani’s Differential Technique(差分优化技术)</h4><ul>
<li>Singhal-Kshemkalyani’s differential technique is based on the observation that between successive message sends to the same process, only a few entires of the vector clock at the sender process are likely to change(在向同一进程发送的连续消息之间，发送方进程中只有少量的向量时钟发生变化)</li>
<li>When a process $p_i$ sends a message to a process $p_j$, it piggybacks only those entires of its vector clock that differ since the last message sent to $p_j$(进程i发给进程j消息的时候，附带的只有那些与前一次发送时向量时钟不同的部分)<ul>
<li>If entries $i<em>1, i_2, …, i</em>{n<em>1}$ of the vector clock at $p_i$ have changed to $v_1, v_2, …,v</em>{n_1}$, respectively, since the last message sent to $p_j$, then process $p_i$ piggybacks a compressed timestamp of the form:<ul>
<li>${(i<em>1, v_1), (i_2, v_2), …, (i</em>{n<em>1}, v</em>{n_1})}$ to the next message to $p_j$</li>
</ul>
</li>
</ul>
</li>
<li><p>When $p_j$ receives this message, it updates its vector clock as follows:(接收到后根据tuple进行更新)</p>
<ul>
<li>$vt_i[i_k] = max(vt_i[i_k], v_k)$ for $k=1, 2, …, n_1$</li>
</ul>
</li>
<li><p>Thus this technique cuts down the message size, communication bandwidth and buffer (to store message) requirements</p>
</li>
<li>In the worst of case, every element of the vector clock has been updated at $p_i$ since the last message to process $p_j$, and the next message from $p_i$ to $p_j$ will need to carry the entire vector timestamp of size $n$</li>
<li><p>However, on the average the size of the timestamp on a message will be less than $n$</p>
</li>
<li><p>Implementation of this technique requires each process to remember the vector timestamp in the message last sent to every other process</p>
<ul>
<li>Direct implementation of this will result in $O(n^2)$ storage overhead at each process</li>
</ul>
</li>
<li>Singhal and Kshemkalyani developed a clever technique that cuts down this storage overhead at each process to $O(n)$. The technique works in the following manner<ul>
<li>Process $p_i$ maintains the following two additional vectors:<ul>
<li>$LS_i[1…n]$: (‘Last Sent’)<ul>
<li>$LS_i[j]$ indicates the value of $vt_i[i]$ when process $p_i$ last sent a message to process $p_j$</li>
</ul>
</li>
<li>$LU_i[1…n]$: (‘Last Update’)<ul>
<li>$LU_i[j]$ indicates the value of $vt_i[i]$ when process $p_i$ last updated the entry $vt_i[j]$</li>
</ul>
</li>
<li>Clearly, $LU_i[i] = vt_i[i]$ at all times and $LU_i[j]$ needs to be updated only when the receipt of a mesage cause $p_i$ to update entry $vt_i[j]$.(LU只在接收消息的时候更新)</li>
<li>Also, $LS_i[j]$ needs to be updated only when $p_i$ sends a message to $p_j$(LS只在发送消息的时候更新)</li>
</ul>
</li>
</ul>
</li>
<li>Since the last communication from $p_i$ to $p_j$, only those elements of vector clock $vt_i[k]$ have changed for which $LS_i[j] &lt; LU_i[k]$ holds</li>
<li>Hence, only these elements need to be sent in a message from $p_i$ to $p_j$. When $p_i$ sends a message to $p_j$, it sends only a set of tuples<ul>
<li>${(x, vt_i[x])\mid LS_i[j] &lt; LU_i[x]}$</li>
<li>as the vector timestamp to $p_j$, instead of sending a vector of $n$ entries in a message</li>
</ul>
</li>
<li>Thus the entire vector of size $n$ is not sent along with a message. Instead, only the elements in the vector clock that have changed since the last message send to that process are sent in the format ${(p_1, latest_value), (p_2, latest_value), …}$, where $p_i$ indicates that the $p_i^{th}$ component of the vector clock has changed(在LS和LU找不同，发送的消息前者是不同的位置，后者是要更新的值)</li>
<li>This technique requires that the communication channels follow FIFO discipline for message delivery(消息传输遵守FIFO先进先出)</li>
<li>This technique substantially reduces the cost of maintaining vector clocks in large systems, especially if the process interations exhibit temporal or spatial localities(降低在大型系统中维护向量时钟的成本，特别是进程交互包含了时空位置)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Vector%20clocks%20progress%20in%20Singhal-Kshemkalyani%20technique.png" alt="img"></p>
<h3 id="Matrix-Time-Logical-Clocks"><a href="#Matrix-Time-Logical-Clocks" class="headerlink" title="Matrix Time(Logical Clocks)"></a>Matrix Time(Logical Clocks)</h3><ul>
<li>In a system of matrix clocks, the time is represented by a set of $n\times n$ matrices of non-negative integers</li>
<li>A process $p_i$ maintains a matrix $mt_i[1..n, 1..n]$, where:<ul>
<li>$mt_i[i, i]$ denotes the local logical clock of $p_i$ and tracks the progress of the computation at process $p_i$(进程i本地的逻辑时钟)</li>
<li>$mt_i[i, j]$ denotes the latest knowledge that process $p_i$ has about the local logical clock, $mt_j[j, j]$, of process $p_j$(进程i最近获得的关于其他进程的本地逻辑时钟，就相当于是向量时钟vector time)</li>
<li>$mt_i[j, k]$ represents the knowledge that process $p_i$ has about the latest knowledge that $p_j$ has about the local logical clock, $mt_k[k, k]$, of $p_k$(进程i最近获得的关于其他进程对再其他进程逻辑时钟)</li>
<li>The entire matrix $mt_i$ denotes $p_i$’s local view of the global logical time(整个矩阵时间表示的是进程对全局逻辑时钟的本地视角)</li>
</ul>
</li>
<li>Process $p_i$ uses the following rules R1 and R2 to update its clock:(更新规则)<ul>
<li>R1: Before executing an event, process $p_i$ updates its local logical time as follows:(执行事件之前更新本地的逻辑时钟)<ul>
<li>$mt_i[i, i] := mt_i[i, i] + d \quad (d &gt; 0)$</li>
</ul>
</li>
<li>R2: Each message $m$ is piggybacked with matrix time $mt$. When $p_i$ receives such a message $(m, mt)$ from a process $p_j$, $p_i$ executes the following sequence of actions:(接收消息之后更新全局逻辑时间，和标量向量时钟类似)<ul>
<li>Update its global logical time as follows:<ul>
<li>a. $1\leq k\leq n: mt_i[i, k]:=max(mt_i[i, k], mt[j, k])$<ul>
<li>That is, update its row $mt_i[i, *]$with the $p_j$’s row in the received timestamp, $mt$.(先更新本地视角的逻辑时钟)</li>
</ul>
</li>
<li>b. $1\leq k, l\leq n : mt_i[k, l]:=max(mt_i[k, l], mt[k, l])$(更新非本地视角的全局逻辑时钟，而且只需要更新所收消息进程编号之前的)</li>
</ul>
</li>
<li>Execute R1</li>
<li>Deliver message $m$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Evolution%20of%20matrix%20time.png" alt="img"></p>
<ul>
<li>Let us consider the following events:<ul>
<li>$e_i^m$ which is the $(x_i^m)^{th}$ event at process $p_i$<ul>
<li>$e_k^1$ and $e_k^2$ which are the $(x_k^1)^{th}$ and $(x_k^2)^{th}$ event at process $p_k$</li>
<li>$e_j^1$ and $e_j^2$ which are the $(x_j^1)^{th}$ and $(x_j^2)^{th}$ event at process $p_j$</li>
</ul>
</li>
<li>$mt_e$ denote the matrix timestamp associated with event $e$</li>
</ul>
</li>
<li>Due to message $m_4$, $e_k^2$ is the last event of $p_k$ that causally precedes $e$, therefore, we have $mt_e[i, k] = mt_e[k, k] = x_k^2$<ul>
<li>Likewise, $mt_e[i, j] = mt_e[j, j] = x_j^2$</li>
</ul>
</li>
<li>The last event of $p_k$ known by $p_j$, to the knowledge of $p_i$ when it executed event, is e_k^1. Therefore, $mt_e[j, k] = x_k^1$<ul>
<li>Likewise, $mt_e[k. j] = x_j^1$</li>
</ul>
</li>
</ul>
<h4 id="Basic-Properties-1"><a href="#Basic-Properties-1" class="headerlink" title="Basic Properties"></a>Basic Properties</h4><ul>
<li>Vector $mt_i[i, .]$ contains all the properties of vector clocks(矩阵时钟在进程编号一行表示的就是向量时钟)</li>
<li>In addition, matrix clocks have the following property:<ul>
<li>$min_k(mt_i[k, l]) \geq t \Rightarrow process\quad p_i$ knows that every other process $p_k$ knows that $p_l$’s local time has progressed till $t$(在进程i的视角下，进程k所知道的直到时间t进程l所对应的逻辑时间)<ul>
<li>If this is true, it is clear that process $p_i$ knows that all other processes know that $p_l$ will never send information with a local time $\leq t$(如果不等式成立，则说明进程i知道其他所有的进程都知道进程l在时间t之前根本没有发送过任何消息)</li>
<li>In many applications, this implies that processes will no longer require from $p_l$ certain information and can use this fact to discard obsolete information(意味着可以丢弃关于进程l的消息，因为不太需要)</li>
</ul>
</li>
</ul>
</li>
<li>If $d$ is always 1 in the rule R1, then $mt_i[k, l]$ denotes the number of events occurred at $p_l$ and known by $p_k$ as far as $p_i$’s knowledge is concerned(如果d为1，则这个逻辑时间为执行的事件数)</li>
</ul>
<h3 id="Virtual-Time-虚拟时间"><a href="#Virtual-Time-虚拟时间" class="headerlink" title="Virtual Time(虚拟时间)"></a>Virtual Time(虚拟时间)</h3><ul>
<li>参考论文: <a href="https://cobweb.cs.uga.edu/~maria/pads/papers/p404-jefferson.pdf">Virtual Time </a></li>
</ul>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>主要用于进行事务处理(电商系统、数据库系统)</li>
<li>Virtual time system is a paradigm for organizing and synchronizing distributed systems</li>
<li>The implementation of virtual time using Time Warp mechanism works on the basis of an optimistic assumption(乐观假设)<ul>
<li>Time Warp relies on the general lookahead-rollback mechanism(往前回滚) where each process executes without regard to other processes having synchronization conflicts(不需要考虑与其他进程是否有同步矛盾)</li>
<li>If a conflict is discovered, the offending processes are rolled back to the time just before the conflict and executed forward along the revised path(出错就回滚)</li>
<li>Detection of conflicts and rollbacks are transparent to users</li>
<li>optimistic assumption: synchronization conflicts and thus rollbacks generally occurs rarely(理想情景是冲突和回滚很少发生)</li>
</ul>
</li>
</ul>
<h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h4><ul>
<li>Virtual time is a global, one dimensional, temporal coordinate system on a distributed computation to measure the computational progress and to define synchronization<ul>
<li>A virtual time system is a distributed system executing in coordination with an imaginary virtual clock that uses virtual time(使用想象的虚拟时钟记录虚拟时间)<ul>
<li>these local virtual clocks are loosely synchronized</li>
<li>these local virtual clocks move forward to higher virtual times, and occasionaly move backwards</li>
</ul>
</li>
<li>Virtual times are real values that are totally ordered by the less than relation “$&lt;$”(递增序)</li>
</ul>
</li>
<li>Processes run concurrently and communicate with each other by exchanging messages(进程并行运行，通过互相通信交换消息)<ul>
<li>Every message is characterized by four values:<ul>
<li>Name of the sender(发送者名字)</li>
<li>Virtual send time(虚拟发送时间)<ul>
<li>the virtual time at the sender when the message is sent</li>
</ul>
</li>
<li>Name of the receiver(接收者的名字)</li>
<li>Virtual receive time(虚拟接收时间)<ul>
<li>the virtual time when the message must be received(are processed)by the receiver(发送者指定的该消息最晚被接收处理的时间，是一个期望时间)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Virtual time systems are subject to two semantic rules similar to Lamport’s clock conditions:<ul>
<li>Rule1: Virtual send time of each message &lt; virtual receive time of that message(发送时间肯定比接收时间早)</li>
<li>Rule2: Virtual time of each event in a process &lt; Virtual time of next event in that process(前一个事件的虚拟时间肯定比后一个的早)</li>
</ul>
</li>
<li>The above two rules imply that a process sends all messages in increasing order of virtual send time and a process receives(and processes) all messages in the increasing order of virtual receive time(发送消息事件的虚拟时间是递增的，接收消息事件的虚拟时间也应该是递增的)<ul>
<li>A problem arises when a message arrives at process late, that is, the virtual receive time of the message is less than the local virtual time at the receiver process when the message arrives(消息到得晚了，因为消息携带的期望接收时间比接收者接收消息时的本地虚拟时间更小，即消息错过了)</li>
</ul>
</li>
<li>Causality of events is an important concept in distributed systems and is also a major constraint in the implementation of virtual time(事件的因果关系)<ul>
<li>It is important an event that causes another should be completely executed before the caused event can be processed(因事件必须在果事件发生前结束)</li>
<li>The constraint in the implementation of virtual time can be stated as follows: “If an event A causes event B, then the execution of A and B must be scheduled in real time so that A is completed before B starts.<ul>
<li>events with virtual time $&lt; ‘t’$ complete before the starting of events at time ‘t’</li>
<li>events with virtual time $&gt; ‘t’$ will start only after events at time ‘t’ are complete</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><ul>
<li>Virtual time systems are not all isomorphic, it may be either discrete or continuous(虚拟时间可以是离散或连续的)</li>
<li>Virtual time may be only partially ordered(部分有序，因为有回滚?)</li>
<li>Virtual time may be related to real time or may be independent of it(可以用真实时钟作为虚拟时间，也可以不用)</li>
<li>Virtual time systems may be visible to programmers and manipulated explicitly as values, or hidden and manipulated implicity according to some system-defined discipline(程序员可见且显示赋值控制，或者隐式的由系统规则决定)</li>
<li>Virtual times associated with events may be explicitly caculated by user programs or they may be assigned by fixed rules(程序计算或者按规则固定分配)</li>
</ul>
<h4 id="Time-Warp-Mechanism"><a href="#Time-Warp-Mechanism" class="headerlink" title="Time Warp Mechanism"></a>Time Warp Mechanism</h4><ul>
<li>virtual receive time of message is considered as its timestamp</li>
<li>The necessary and sufficient conditions for the correct implementation of virtual time are that each process must handle incoming messages in timestamp order(正确实现虚拟时间的充要条件: 每个进程必须将接收到的消息按时间戳排序，递增序)<ul>
<li>This is highly undesirable and restrictive because process speeds and message delays are likely to highly variable. It natural for some processes to get ahead in virtual time of other processes(进程速度和消息延迟不同，因此很难满足充要条件)</li>
</ul>
</li>
<li>It is impossible for a process on the basis of local information alone to block and wait for the message with the next timestamp(不能仅依赖本地的虚拟时间)<ul>
<li>When a process executes a message, it is very difficult for it determine whether a message with an earlier timestamp will arrive later(central problem, 如何确定要处理的消息没有超时)<ul>
<li>It is always possible that a message with earlier timestamp arrives later</li>
</ul>
</li>
</ul>
</li>
<li>Time Warp Mechanism assumes that message communication is reliable, and messages may not be delivered in FIFO order(传输消息可靠，即不会丢包，但可能不会有序接收)</li>
<li>local control mechanism: insures that events are executed and messages are processed in the correct order(本地控制机制保证事件执行和消息处理顺序是正确的)<ul>
<li>There is no global virtual clock variable in this implementation, each process has a local virtual clock variable(各自进程持有本地虚拟时钟，没有全局的虚拟时钟)</li>
<li>The local virtual clock of a process doesn’t change during an event at that process but it chages only between events(虚拟时钟只在事件之间进行更新，即事件执行过程中不能更新时钟)</li>
<li>On the processing of next message from the input queue(接收队列), the process increases its local clock to the timestamp of the message (接收并处理消息的时候，将本地时钟更新为所接受消息携带的虚拟接收时间，这个时间是一个期望时间，发送者期望接收者接收消息的时间，或者说是最晚被接收的时间)<ul>
<li>When a message is sent, the virtual send time is copied from the sender’s virtual clock while the name of the receiver and virtual receive time are assigned based on application specific context</li>
</ul>
</li>
<li>At any instant, the value of virtual time may differ for each process but the value is transparent to other processes in the system(任何时刻，进程的虚拟时间可能和其他进程的虚拟时间不同，且是透明的，其他进程并不知道)</li>
<li>All arriving messages at a process are stored in an input queue in the increasing order of timestamps (receive times).(所有的接收消息会在队列中按照各自携带的虚拟接收时间排序，递减序)</li>
<li>The semantics of virtual time demands that incoming messages be received by each process strictly in the timestamp order.<ul>
<li>But processes will receive late messages due to factors such as different computation rates of processes and network delays.</li>
</ul>
</li>
<li>Runtime representation of a process is composed of the following:<ul>
<li>Process name: Virtual spaces coordinate which is unique in the system(唯一标识)</li>
<li>Local virtual clock: Virtual time coordinate</li>
<li>State: Data space of the process including execution stack, program counter and its own variables(用于后面回滚恢复的记忆上下文)</li>
<li>State queue: Contains saved copies of process’s recent states as roll back with Time warp mechanism requires the state of the process being saved(最近执行过的事件的状态副本队列)</li>
<li>Input queue: Contains all recently arrived messages in order of virtual receive time. Processed messages from the input queue are not deleted as they are saved in the output queue with a negative sign (antimessage) to facilitate future roll backs.(输入队列，执行完后建立个副本，并将标记取反放到输出队列作为回滚的备份)<ul>
<li>Whenever a process sends a message, a copy of the message is transmitted to receiver’s input queue and a negative copy (antimessage) is retained in the sender’s output queue for use in sender rollback.</li>
</ul>
</li>
<li>Output queue: Contains negative copies of messages the process has recently sent in virtual send time order. They are needed in case of a rollback.</li>
</ul>
</li>
<li>When a message arrives at the input queue of a process with timestamp greater than virtual clock time of its destination process, it is simply enqueued.</li>
<li>When the destination process’ virtual time is greater than the virtual time of message received, the process must do a rollback.(接收消息的期望时间比当前进程的虚拟时间小，说明超时了，就要回滚)</li>
<li>Antimessages: For every message, there exists an antimessage that is the same in content but opposite in sign(内容一样，但标记相反，例如是正负标记)<ul>
<li>Whenever a message and its antimessage appear in the same queue no matter in which order they arrived, they immediately annihilate each other resulting in shortening of the queue by one message.(标记相反的相同消息出现在同一个队列，会被抵消掉，当作无事发生)</li>
<li>Advantages:<ul>
<li>It is extremely robust and works under all possible circumstances.(很稳定)</li>
<li>It is free from deadlocks as there is no blocking.(不会死锁，因为没有阻塞)</li>
<li>It is also free from domino effects.(不会有多米诺骨牌效应，即不会一个出错连带所有出错，因为可以级联回滚)</li>
<li>In the worst case, all processes in system roll back to same virtual time as original one did and then proceed forward again.(最糟糕的情况也不过是重新来过，不会崩)</li>
</ul>
</li>
</ul>
</li>
<li>Rollback Mechanism(回滚机制)<ul>
<li>Search the ”State queue” for the last saved state with timestamp that is less than the timestamp of the message received and restore it.(查找状态队列中比出错时间戳更早的最后保存状态)</li>
<li>Make the timestamp of the received message as the value of the local virtual clock and discard from the state queue all states saved after this time. Then the resume execution forward from this point.(将虚拟接收时间作为当前的本地虚拟时间，丢掉状态队列中在此时间之后执行的所有结果，重新从这个时间点执行)</li>
<li>Now all the messages that are sent between the current state and earlier state must be “unsent”. This is taken care of by executing a simple rule: “To unsend a message, simply transmit its antimessage.”(所有在丢弃掉的事件中发送的消息都应该撤回，也就是发送一个该消息的反消息antimessage)</li>
<li>Depending on the timing, there are several possibilities at the receiver’s end:<ul>
<li>The original (positive) message has arrived but not yet been processed at the receiver. The negative message causes no rollback, however, it annihilates with the positive message leaving the receiver with no record of that message.(消息还没来得及被执行就收到了负责撤回的负消息，直接抵消，无事发生)</li>
<li>The original positive message has already been partially or completely processed by the receiver. The negative message causes the receiver to roll back to a virtual time when the positive message was received.(要被撤回的消息正在执行或已完成执行，则触发回滚，然后嵌套过程，有可能又触发其他回滚——级联回滚)</li>
<li>A negative message can also arrive at the destination before the positive one. In this case, it is enqueued and will be annihilated when positive message arrives. (撤回的消息比消息本身到的还快，这个和链路情况有关，是可能会发生的。那就把该消息放在输入队列里等待正消息的到来，然后相互抵消)<ul>
<li>If it is negative message’s turn to be executed at a processs’ input queqe, the receiver may take any action like a no-op. Any action taken will eventually be rolled back when the corresponding positive message arrives.(如果在正消息到来前就轮到执行负消息了，可以让进程执行空操作no-op，但时间戳还是会被更新，就会导致正消息到来后触发回滚，这种情况会浪费计算资源)</li>
<li>An optimization would be to skip the antimessage from the input queue and treat it as a no-op, and when the corresponding positive message arrives, it will annihilate the negative message, and inhibit any rollback.(可以采用跳过该消息的方式，就是空操作也不更新时间，直接往后处理，就不会需要回滚了)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>global control mechanism: take care of global issues such as global progress, termination detection, I/O error handling, flow control(全局控制机制关注整个过程的问题，例如中断检测，I/O错误管理和流量控制)</li>
</ul>
<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><ul>
<li>In Lamport’s logical clock, an artificial clock is created one for each process with unique labels from a totally ordered set in a manner consistent with partial order(逻辑时钟是为每一个进程给一个时钟，全局看逻辑时间是偏序的)<ul>
<li>all clocks are conservatively maintained so that they never violate causality, a process advances its clock as soon as it learns of new causal dependency(保守地推进时间，天然保证了因果性，)</li>
</ul>
</li>
<li>In virtual time, the reverse of the above is done by assuming that every event is labeled with a clock value from a totally ordered virtual time scale satisfying Lamport’s clock conditions(虚拟时间是每个进程的每个事件单独给一个时钟值标注，这个标注与前面的标注是没有逻辑关系的，例如直接记录为事件发生的物理时钟，从全局看时钟就是全序的)<ul>
<li>clocks are optimistically advanced and corrective actions are taken whenever a violation is detected(虚拟时钟乐观推进，只在出问题的时候用机制纠正问题)</li>
</ul>
</li>
</ul>
<h3 id="Physical-Clock-Synchronization-NTP"><a href="#Physical-Clock-Synchronization-NTP" class="headerlink" title="Physical Clock Synchronization: NTP"></a>Physical Clock Synchronization: NTP</h3><ul>
<li>当任务要求使用高精度时间分辨率时，不能使用逻辑时钟，而要用到物理时钟</li>
<li>Clocks that must not only be synchronized with each other but also have to adhere to physical time are termed physical clocks(互相同步且需要遵守物理时间)</li>
</ul>
<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><ul>
<li>In centralized systems, there is only single clock. A process gets the time by simply issuing a system call to the kernel(一个系统一个时钟，向内核发起系统调用就能获得时间)</li>
<li>In distributed systems, there is no global clock or common memory. Each processor has its own internal clock and its own notion of time(分布式系统没有全局时钟或共享的内存，每个进程都有自己的时钟和自己对时钟的度量)</li>
<li>These clocks can easily drift seconds per day, accumulating significant errors over time(每天都会偏移几秒钟，随时间会累计成非常大的错误)</li>
<li>Also, because different clocks tick at different rates, they may not remain always synchronized although they might be synchronized when they start. (不同进程的时钟会有不同的速率，所以难以同步)<ul>
<li>This clearly poses serious problems to applications that depend on a synchronized notion of time</li>
</ul>
</li>
<li>For most applications and algorithms that run in a distributed system, we need to know time in one or more of the following contexts:<ul>
<li>The time of the day at which an event happened on a specific machine in the network.(事件发生的时间)</li>
<li>The time interval between two events that happened on different machines in the network.(在不同机器上发生的两个事件的时间间隔)</li>
<li>The relative ordering of events that happened on different machines in the network.(不同机器上发生的事件的相对顺序)</li>
</ul>
</li>
<li>Unless the clocks in each machine have a common notion of time, time-based queries cannot be answered(除非机器拥有相同的时间度量，否则基于时间的请求不会被响应)</li>
<li>Clock synchronization has a significant effect on many problems like secure systems, fault diagnosis and recovery, scheduled operations, database systems, and real-world clock values(时间同步很重要)</li>
</ul>
<h4 id="Clock-synchronization"><a href="#Clock-synchronization" class="headerlink" title="Clock synchronization"></a>Clock synchronization</h4><ul>
<li>Clock synchronization is the process of ensuring that physically distributed processors have a common notion of time(时间同步是让物理上的分布式进程拥有相同时间度量的过程)</li>
<li>Due to different clocks rate, the clocks at various sites may diverge with time and periodically a clock synchronization must be performed to correct this clock skew in distributed systems</li>
<li>Clocks are synchronized to an accurate real-time standard like UTC(Universal Coordinated Time)</li>
</ul>
<h4 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h4><ul>
<li>Let $C_a$ and $C_b$ be any two clocks<ul>
<li>Time: The time of a clock in a machine $p$ is given by the function $C_p(t)$, where $C_p(t)=t$ for a perfect clcok(没有偏差的时钟)</li>
<li>Frequency: Frequency is the rate at which a clock progresses. The frequency at time $t$ of clock $C_a$ is $C’_a(t)$(频率是时钟的变化率，是时间函数的导数)</li>
<li>Offset: Clock offset is the difference between the time reported by a clock and the real time. The offset of the clock $C_a$ is given by $C_a(t)-t$. The offset of clock $C_a$ relative to $C_b$ at time $t\geq0$ is given by $C_a(t)-C_b(t)$(时钟偏移是时钟之间的差值)</li>
<li>Skew(倾斜): The skew of a clock is the difference in the frequencies of the clock and the perfect clock. The skew of a clock $C_a$ relative to clock $C_b$ at time t is $(C’_a(t)-C’_b(t))$. If the skew is bounded by $\rho$, then as per Equation(1), clock values are allowed to diverge at a arte in the range of $1-\rho$ to $1+\rho$(时钟倾斜是时钟频率的差值，通常要限定在一个范围$\rho$内)<ul>
<li>a timer(clock) is said to be working within its specification if(where constant $\rho$ is the maximum skew rate specified by the manufacturer(制造商))</li>
<li>$1-\rho \leq \frac{dC}{dt}\leq 1+\rho$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/repect%20to%20UTC.png" alt="img"></li>
</ul>
</li>
<li>Drift(rate, 漂移): The drift of clock $C_a$ is the second derivative of the clock value with respect to time(漂移是对速度的变化率的度量，所以是时间的二阶导), namely, $C’’_a(t)$. The drift of clock $C_a$ relativ eto clock $C_a$ at time $t$ is $C’’_a(t)-C’’_b(t)$</li>
</ul>
</li>
</ul>
<h4 id="The-Network-Time-Protocol-NTP"><a href="#The-Network-Time-Protocol-NTP" class="headerlink" title="The Network Time Protocol(NTP)"></a>The Network Time Protocol(NTP)</h4><ul>
<li>is widely used for clock synchronization on the Internet uses the The Offset Delay Estimation method(使用偏移延迟的估算方法，进行时钟同步)</li>
<li>The design of NTP involves a hierarchical tree of time servers(分层树结构)<ul>
<li>The primary server at the root synchronizes with the UTC(根节点是拥有UTC时间的服务器)</li>
<li>The next level contains secondary servers, which act as a backup to the primary server(下一层是上层根节点主服务器的备份)</li>
<li>At the lowest level is the synchronization subnet which has the clients(最底层是拥有客户端的同步子网)</li>
</ul>
</li>
<li>The Offset Delay Estimation method<ul>
<li>a source node cannnot accurately estimate the local time on the target node due to varying message or network delays between the nodes(节点之间有网络和消息延迟，无法准确目标节点的本地时间)</li>
<li>This protocol employs a common pratice of performing several trials and chooses the trial with the minimum delay(协议选定最小延迟作为系统之间的时延，因为更贴近真实的消息传播时延)</li>
</ul>
</li>
<li>Assume clocks A and B are stable and running at the same speed. Let $T_1, T_2, T_3, T_4$ be the values of the four most recent timestamps as shown:<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/offset%20and%20delay%20estimation.png" alt="img"><ul>
<li>Each NTP message includes the latest three timestamps $T_1, T_2$ and $T_3$, while $T_4$ is determined upon arrival</li>
<li>Let $a = T_1-T_3$ and $b=T_2-T_4$</li>
<li>If the delay difference from A to B and from B to A, called differential delay, is small, the clock offset $\theta$ and roundtrip delay $\delta$ of B relative to A at Time $T_4$ are approximately given by the following<ul>
<li>$\theta = \frac{(a+b)}{2}=\frac{T_1-T_3+T_2-T_4}{2}$(由下面两式联立得到)<ul>
<li>$\theta = T_1-(T_3 + \frac{\delta}{2})$</li>
<li>$\theta = T_4-(T_2 + \frac{\delta}{2})$</li>
</ul>
</li>
<li>$\delta = a-b=T_1-T_3-(T_2-T_4)=(T_4-T_3)-(T_2-T_1)$(消息在A待的时间减去在B待的时间就是在信道中传输的时间)</li>
</ul>
</li>
</ul>
</li>
<li>Thus both peers A and B can independently calculate delay and offset using a single bidirectional messages stream<ul>
<li>A pair of servers in symmetric mode exchange pairs of timing messages<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Timing%20diagram.png" alt="img"></li>
<li>A store of data is then built up about the relationship between the two servers(pairs of offset and delay). Specifically, assume that each peer maintains pairs $(O_i, D_i)$, where <ul>
<li>$O_i$: measure of offset ($\theta$)</li>
<li>$D_i$: transmission delay of two messages ($\delta$)</li>
</ul>
</li>
<li>The offset corresponding to the minimum delay is chosen. Specifically, the delay and offset are calculated as follows.(用最小延迟作为偏移，不以最小延迟为偏移可能导致偏移偏大、偏小或无影响，取决于两个时钟的快慢关系) </li>
<li>Assume that message $m$ takes time $t$ to transfer and $m’$ takes $t’$ to transfer</li>
<li>The offset between A’s clock and B’s clock is $O$. If A’s local clock time is $A(t)$ and B’s local clock time is $B(t)$, <ul>
<li>$A(t)=B(t)+O$</li>
<li>$T<em>{i-2}=T</em>{i-3}+t+O$</li>
<li>$T<em>i=T</em>{i-1}-O+t’$</li>
</ul>
</li>
<li>Assuming $t=t’$, the offset $O_i$ can be estimated as:<ul>
<li>$O<em>i=(T</em>{i-2}-T<em>{i-3}+T</em>{i-1}-T{i})/2$</li>
</ul>
</li>
<li>The round-trip delay is estimated as:<ul>
<li>$D<em>i=(T_i-T</em>{i-3})-(T<em>{i-1}-T</em>{i-2})$</li>
</ul>
</li>
<li>The eight most recent pairs of $(O_i, D_i)$ are retained</li>
<li>The value of $O_i$ that corresponds to minimum $D_i$ is chosen to estimate $O$</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>全局状态及快照算法</title>
    <url>/2024/10/25/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-10-25-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="全局状态及快照算法"><a href="#全局状态及快照算法" class="headerlink" title="全局状态及快照算法"></a>全局状态及快照算法</h1><h2 id="System-model"><a href="#System-model" class="headerlink" title="System model"></a>System model</h2><ul>
<li>The system consists of a collection of $n$ processes $p_1, p_2, …, p_n$ that are connected by channels</li>
<li>There are no globally shared memory and physical global clock and processes communicate by passing messages through communication channels with unpredicatable message delays<ul>
<li>$C<em>{ij}$ denotes the channel from process $p_i$ to process $p_j$ and its state is denoted by $SC</em>{ij}$<ul>
<li>For a channel $C_{ij}$, the following set of messages can be defined based on the local states of the processes $p_i$ and $p_j$</li>
<li>Transit: $transit(LS<em>i, LS_j)={m</em>{ij}|send(m<em>{ij}\in LS_i \wedge rec(m</em>{ij})\notin LS_j}$(发送端发送了，但接收端没接收，说明消息在信道)</li>
</ul>
</li>
</ul>
</li>
<li>The actions performed by a process are modeled as three types of events: <ul>
<li>Internal events, </li>
<li>the message send event</li>
<li>the message receive event</li>
</ul>
</li>
<li>For a message $m<em>{ij}$ that is sent by process $p_i$ to process $p_j$, let $send(m</em>{ij})$ and $rec(m_{ij})$ denote its send and receive events</li>
<li>At any distant, the state of process $p_i$, denoted by $LS_i$, is a result of the sequence of all the events executed by $p_i$ till that instant(进程的状态是之前所有执行过的事件)<ul>
<li>For an event $e$ and a process state $LS_i, e\in LS_i$ iff $e$ belongs to the sequence of events that have taken process $p_i$ to state $LS_i$</li>
<li>For an event $e$ and a process state $LS_i, e\notin LS_i$, iff $e$ does not belong to the sequence of events that have taken process $p_i$ to state $LS_i$</li>
</ul>
</li>
</ul>
<h3 id="Models-of-communication"><a href="#Models-of-communication" class="headerlink" title="Models of communication"></a>Models of communication</h3><ul>
<li>In FIFO model, each channel acts as a first-in first-out message queue and thus, message ordering is preserved by a channel(FIFO消息是有序到达)</li>
<li>In non-FIFO model, a channel acts like a set in which the sender process adds messages and the receiver process removes messages from it in a random order.(non-FIFO消息是无序到达)</li>
<li>A system that supports causal delivery of messages satisfies the following property: <ul>
<li>“For any two messages $m<em>{ij}$ and $m</em>{kj}$, if $send(m<em>{ij})\rightarrow send(m</em>{kj})$, then $rec(m<em>{ij}) −→ rec(m</em>{kj})$”</li>
<li>因果序，先发和后发有因果序，则先发的会先收，且和后收有因果序</li>
</ul>
</li>
</ul>
<h2 id="Consistent-global-state"><a href="#Consistent-global-state" class="headerlink" title="Consistent global state"></a>Consistent global state</h2><ul>
<li>The global state of a distributed system is a collection of the local states of the processes and the channels<ul>
<li>Notationally, global state $GS$ is defined as<ul>
<li>$GS={\bigcup<em>i LS_i, \bigcup</em>{i, j}SC_{ij}}$(所有的进程状态和所有的信道状态)</li>
</ul>
</li>
</ul>
</li>
<li>A global state $GS$ is a consistent global state iff it satisfies the following two conditions:<ul>
<li>$C1: send(m<em>{ij})\in LS_i \Rightarrow m</em>{ij}\in SC<em>{ij} \bigoplus rec(m</em>{ij})\in LS_j$, ($\bigoplus$ is Ex-OR operator, 异或)(发出去的消息要么被接收要么在信道，不可能同时在接收方和信道，也不可能都不在)</li>
<li>$C2: send(m<em>{ij})\notin LS_i \Rightarrow m</em>{ij}\notin SC<em>{ij}\wedge rec(m</em>{ij})\notin LS_j$(没发的消息不可能出现在接收方和信道)</li>
</ul>
</li>
</ul>
<h3 id="Interpretation-in-terms-of-cuts"><a href="#Interpretation-in-terms-of-cuts" class="headerlink" title="Interpretation in terms of cuts"></a>Interpretation in terms of cuts</h3><ul>
<li>(从剪切的角度解释，看<a href="https://zjn-astonishe.github.io/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/">分布式计算模型</a>)</li>
<li>A cut in a space-time diagram is a line joining an arbitrary point on each process line that slices the space-time diagram into a <code>PAST</code> and a <code>FUTURE</code></li>
<li>A consistent global state corresponds to a cut in which every message received in the <code>PAST</code> of the cut was sent in the <code>PAST</code> of that cut(在过去接收的只能是在过去发送的), and such a cut is known as a consistent cut</li>
</ul>
<h3 id="Issues-in-recording-a-global-state"><a href="#Issues-in-recording-a-global-state" class="headerlink" title="Issues in recording a global state"></a>Issues in recording a global state</h3><ul>
<li>How to distinguish between the messages to be recorded in the snapshot from those not to be recorded(区分记录在快照的消息和未记录的消息)<ul>
<li>Any message that is sent by a process before recording its snapshot, must be recorded in the global snapshot (from C1).(在快照前发送的消息必须在快照中记录，无论是信道还是接收方)</li>
<li>Any message that is sent by a process after recording its snapshot, must not be recorded in the global snapshot (from C2).(在快照后发送的消息不能出现在快照中)</li>
</ul>
</li>
<li>How to determine the instant when a process takes its snapshot(如何确定何时该进行快照)<ul>
<li>A process $p<em>j$ must record its snapshot before processing a message $m</em>{ij}$ that was sent by process $p_i$ after recording its snapshot.(在发送进程快照后才发送的消息，接收进程必须在接收后处理该消息之前进行快照)</li>
</ul>
</li>
</ul>
<h2 id="Snapshot-algorithms"><a href="#Snapshot-algorithms" class="headerlink" title="Snapshot algorithms"></a>Snapshot algorithms</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Snapshot%20algorithms.png" alt="img"></p>
<h3 id="Chandy-Lamport-algorithm-For-FIFO-channels"><a href="#Chandy-Lamport-algorithm-For-FIFO-channels" class="headerlink" title="Chandy-Lamport algorithm(For FIFO channels)"></a>Chandy-Lamport algorithm(For FIFO channels)</h3><ul>
<li>uses a control message, called a <code>marker</code> whose role in a FIFO system is to separate messages in the channels(<code>marker</code>用于分离信道中的消息)</li>
<li>After a site has recorded its snapshot(记录快照后), it sends a <code>marker</code>, along all of its outgoing channels before sending out any more messages(发送更多消息前，沿着所有的传出信道发送<code>marker</code>)</li>
<li>A marker separates the messages in the channel into those to be included in the snapshot from those not to be recorded in the snapshot.(分为在快照中的消息和不在快照中的消息)</li>
<li>A process must record its snapshot no later than when it receives a marker on any of its incoming channels.(进程必须在其任何传入信道接收<code>marker</code>后处理<code>marker</code>前记录自己的快照)</li>
</ul>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><ul>
<li>The algorithm can be initiated by any process by executing the “Marker Sending Rule” by which it records its local state and sends a <code>marker</code> on each outgoing channel(任何一个进程都能作为发起者)</li>
<li>A process executes the “Marker Receiving Rule” on receiving a marker. If the process has not yet recorded its local state, it records the state of the channel on which the marker is received as empty and executes the “Marker Sending Rule” to record its local state.(所有如果在处理<code>marker</code>的时候没有保存本地快照，则相当于没有收到此<code>marker</code>，然后自己执行Marker Sending Rule，此前传<code>marker</code>的进程也会收到该进程的<code>marker&#39;</code>，则会再发一遍)</li>
<li>The algorithm terminates after each process has received a marker on all of its incoming channels.(如果每个进程在所有的传入信道都接收到了<code>marker</code>则算法终止)<ul>
<li>All the local snapshots get disseminated to all other processes and all the processes can determine the global state.(所有本地快照都会传播到所有其他进程，因此所有进程都可以确定全局状态。)</li>
</ul>
</li>
</ul>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Marker Sending Rule for process i</span><br><span class="line">1- Process i records its state</span><br><span class="line">2- For each outgoing channel C on which a marker has not been sent, i sends a marker along C, before i sends further messages along C</span><br><span class="line"></span><br><span class="line">Marker Receiving Rule for process j</span><br><span class="line">On receiving a marker along channel C:</span><br><span class="line">    if j has not recorded its state then</span><br><span class="line">        Record the state of C as the empty set</span><br><span class="line">        Follow the &quot;Marker Sending Rule&quot;</span><br><span class="line">    else</span><br><span class="line">        Record the state of C as the set of messages</span><br><span class="line">        received along C after j&#x27;s state was recorded</span><br><span class="line">        and before j received the marker along C</span><br></pre></td></tr></table></figure>
<h4 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h4><ul>
<li>Due to FIFO property of channels, it follows that no message sent after the marker on that channel is recorded in the channel state. Thus, condition $C2$ is satisfied(FIFO的特性，使得marker后发送的消息不会被记录，满足$C2$规则)</li>
<li>When a process $p<em>j$ receives message $m</em>{ij}$ that precedes the marker on channel $C<em>{ij}$($p_j$从信道$C</em>{ij}$收到在marker之前的$m_{ij}$后), it acts as follows: <ul>
<li>If process $p<em>j$ has not taken its snapshot yet, then it includes $m</em>{ij}$ in its recorded snapshot. (如果$p<em>j$还没进行快照，那么在后面进行快照的时候，需要包括$m</em>{ij}$)</li>
<li>Otherwise, it records $m<em>{ij}$ in the state of the channel $C</em>{ij}$. Thus, condition C1 is satisfied(否则把$m<em>{ij}$记录在信道$C</em>{ij}$的状态中，满足$C1$规则)</li>
</ul>
</li>
<li>$C1$和$C2$都满足，因此该算法是正确的</li>
</ul>
<h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><ul>
<li>The recoding part of a single instance of the algorithm requires $O(e)$ messages(该算法整个过程需要$O(e)$条消息，因为每个进程需要向各个信道都发marker，$e$表示的是消息信道的数量) and $O(d)$ time($d$表示网络的直径，表明的是marker传输的最长距离), where $e$ is the number of edges in the network and $d$ is the diameter of the network</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul>
<li>The recorded global state may not correspond to any of the global states that occurred during the computation.(记录的全局状态可能不对应于计算期间发生的任何全局状态)</li>
<li>This happens because a process can change its state asynchronously before the markers it sent are received by other sites and the other sites record their states.(进程可以在发送的marker被其他站点接收之前异步更改其自己的状态，并且其他站点记录自身的状态。其实就是说记录的状态被发出去后，发送者会继续运行，其他站点记录状态后记录在全局快照中，也会继续运行。全局状态的快照是由不同的异步局部状态组成的)<ul>
<li>But the system could have passed through the recorded global states in some equivalent executions.(虽然全局状态快照的情景没有同时发生，但异步发生过)</li>
<li>The recorded global state is a valid state in an equivalent execution and if a stable property (i.e., a property that persists) holds in the system before the snapshot algorithm begins, it holds in the recorded global snapshot.(记录的全局状态是等效执行的有效状态，如果在快照算法开始之前系统中保持稳定的属性(持久属性)，则将保持在记录的全局快照中)</li>
<li>Therefore, a recorded global state is useful in detecting stable properties(记录的全局状态在检测平稳的特点是有用的)</li>
</ul>
</li>
</ul>
<h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ul>
<li>In a non-FIFO system, a marker cannot be used to delineate messages into those to be recorded in the global state from those not to be recorded in the global state.(消息到达不按顺序，则无法划分记录在全局状态中的消息和不需要记录在全局状态中的消息)<ul>
<li>In a non-FIFO system, either some degree of inhibition or piggybacking of control information on computation messages to capture out-of-sequence messages.(只能通过某种程度的抑制或在计算消息上附加控制消息来捕获乱序消息)</li>
</ul>
</li>
</ul>
<h3 id="Spezialetti-Kearns-algorithm-For-FIFO-channels"><a href="#Spezialetti-Kearns-algorithm-For-FIFO-channels" class="headerlink" title="Spezialetti-Kearns algorithm(For FIFO channels)"></a>Spezialetti-Kearns algorithm(For FIFO channels)</h3><ul>
<li>There are two phases in obtaining a global snapshot(两个阶段获取全局快照): <ul>
<li>locally recording the snapshot at every process(每个进程本地记录快照) </li>
<li>distributing the resultant global snapshot to all the initiators(每个进程将生成的全局快照分发)</li>
</ul>
</li>
</ul>
<h4 id="Efficient-snapshot-recording-高效记录快照"><a href="#Efficient-snapshot-recording-高效记录快照" class="headerlink" title="Efficient snapshot recording(高效记录快照)"></a>Efficient snapshot recording(高效记录快照)</h4><ul>
<li>In the Spezialetti-Kearns algorithm, a markers carries the identifier of the initiator of the algorithm. Each process has a variable master to keep track of the initiator of the algorithm.(marker携带算法发起者的标识符，每个进程都由一个变量主控器来跟踪算法的发起者)</li>
<li>A key notion used by the optimizations is that of a region in the system. A region encompasses all the processes whose master field contains the identifier of the same initiator.(优化使用的一个关键概念是系统中的区域，每个区域包含的所有进程，都有包含同一启动器标识符的主字段)<ul>
<li>When the initiator’s identifier in a marker received along a channel is different from the value in the master variable, the sender of the marker lies in a different region.(当随着信道接收到的marker中的启动器的标识符与主变量中的值不同时，标识符的发送者处于不同的区域)</li>
<li>The identifier of the concurrent initiator is recorded in a local variable id-border-set.(并发启动器的标识符记录在局部变量中的id-border-set)</li>
</ul>
</li>
<li>The state of the channel is recorded just as in the Chandy-Lamport algorithm(including those that cross a border between regions, 包括跨越区域边界的信道).</li>
<li>Snapshot recording at a process is complete after it has received a marker along each of its channels.(进程的快照记录在沿其每个信道接收到标识符后完成)</li>
<li>After every process has recorded its snapshot, the system is partitioned into as many regions as the number of concurrent initiations of the algorithm.(每个进程记录其快照后，系统被划分为算法并发启动次数一样多的区域)</li>
<li>Variable id-border-set at a process contains the identifiers of the neighboring regions.(进程中的变量id-border-set包含相邻区域的标识符)</li>
</ul>
<h4 id="Efficient-dissemination-of-the-recorded-snapshot-高效传播记录的快照"><a href="#Efficient-dissemination-of-the-recorded-snapshot-高效传播记录的快照" class="headerlink" title="Efficient dissemination of the recorded snapshot(高效传播记录的快照)"></a>Efficient dissemination of the recorded snapshot(高效传播记录的快照)</h4><ul>
<li>In the snapshot recording phase, a forest of spanning trees is implicitly created in the system. The initiator of the algorithm is the root of a spanning tree and all processes in its region belong to its spanning tree.(在快照的记录阶段，系统中会隐式地创建一个生成森林，该算法的发起者是生成树的根，其区域中的所有进程都属于其生成树)</li>
<li>If $p_i$ receives its first marker from $p_j$ then process $p_j$ is the parent of process $p_i$ in the spanning tree.(进程接收到的第一个marker对应的发送者进程是该进程在生成树的父母节点)</li>
<li>When an intermediate process in a spanning tree has received the recorded states from all its child processes and has recorded the states of all incoming channels, it forwards its locally recorded state and the locally recorded states of all its descendent processes to its parent.(当生成树中的中间进程接收到其所有子进程记录的状态并记录了所有传入信道的状态时，会将其本地记录的状态及其所有子进程的本地记录状态转发给其父进程)</li>
<li>When the initiator receives the locally recorded states of all its descendents from its children processes, it assembles the snapshot for all the processes in its region and the channels incident on these processes.(当启动器从其子进程接收到其所有子进程的本地记录状态时，会为其区域中的所有进程以及这些进程上的信道进行快照)</li>
<li>The initiator exchanges the snapshot of its region with the initiators in adjacent regions in rounds.(发起者在轮次中与相邻区域的发起者交换各自区域的快照)</li>
<li>The message complexity of snapshot recording is $O(e)$ irrespective of the number of concurrent initiations of the algorithm.(快照记录的消息复杂度为$O(e)$，与算法的并发启动次数无关。$e$是传递消息的次数) The message complexity of assembling and disseminating the snapshot is $O(rn^2)$ where $r$ is the number of concurrent initiations.(消息包装和分发的复杂度是$O(rn^2)$，$r$是并发启动的数量，$n$是每个并发启动的子区域包含的进程节点的数量，平方是因为互相交换)</li>
</ul>
<h3 id="Lai-Yang-algorithm-For-non-FIFO-channels"><a href="#Lai-Yang-algorithm-For-non-FIFO-channels" class="headerlink" title="Lai-Yang algorithm(For non-FIFO channels)"></a>Lai-Yang algorithm(For non-FIFO channels)</h3><ul>
<li>The Lai-Yang algorithm fulfills this role of a marker in a non-FIFO system by using a coloring scheme on computation messages(使用涂色方案实现non-FIFO的marker) that works as follows:<ul>
<li>Every process is initially white(进程是初始化为白色) and turns red while taking a snapshot.(快照后变红) The equivalent of the “Marker Sending Rule” is executed when a process turns red.(变红的时候需要执行Marker Sending Rule)</li>
<li>Every message sent by a white (red) process is colored white (red).(什么色的进程发送什么颜色的消息)</li>
<li>Thus, a white (red) message is a message that was sent before (after) the sender of that message recorded its local snapshot.(发送者记录本地快照之前发送的为白色消息，之后发送的为红色消息)</li>
<li>Every white process takes its snapshot at its convenience, but no later than the instant it receives a red message.(每个白色进程都会在该进程方便的时候拍摄快照，但不能迟于它受到其他进程的红色消息的那一刻，最迟可以在接收到红色消息之后，处理红色消息之前)</li>
<li>Every white process records a history of all white messages sent or received by it along each channel(每个白色进程都记录了它沿每个信道发送或接收的所有白色消息的历史记录)</li>
<li>When a process turns red, it sends these histories along with its snapshot to the initiator process that collects the global snapshot(当一个进程变为红色时，会将这些历史记录及其快照发送给收集全局快照的启动器进程initiator)</li>
<li>The initiator process evaluates $transit(LS<em>i, LS_j)$ to compute the state of a channel $C</em>{ij}$ as given below:<ul>
<li>$SC<em>{ij}=$ white messages sent by $p_i$ on $C</em>{ij}$ — white messages received by $p<em>j$ on $C</em>{ij}={send(m<em>{ij})|send(m</em>{ij})\in LS<em>i} - {rec(m</em>{ij})|rec(m_{ij})\in LS_j}$(得到的便是在信道中的消息)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Mattern’s-algorithm-For-non-FIFO-channels"><a href="#Mattern’s-algorithm-For-non-FIFO-channels" class="headerlink" title="Mattern’s algorithm(For non-FIFO channels)"></a>Mattern’s algorithm(For non-FIFO channels)</h3><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><ul>
<li>Mattern’s algorithm is based on vector clocks and assumes a single initiator process(该算法基于向量时钟和假设一个启动器进程) and works as follows:<ul>
<li>The initiator “ticks” its local clock and selects a future vector time $s$ at which it would like a global snapshot to be recorded(启动器根据本地时钟选定一个未来的向量时间$s$，该时间记录全局快照). It then broadcasts this time $s$ and freezes all activity until it receives all acknowledgements of the receipt of this broadcast.(该进程将整个未来向量时间$s$广播出去，然后阻塞该进程，直到收到广播出去的所有确认回复为止)</li>
<li>When a process receives the broadcast, it remembers the value $s$ and returns an acknowledgement to the initiator.(接收到广播的进程，会记住该广播来的值$s$并向发送者，即启动器返回确认)</li>
<li>After having received an acknowledgement from every process, the initiator increases its vector clock to $s$ and broadcasts a dummy message to all processes.(启动器收到所有的进程的确认回复后，启动器将自己的虚拟时钟修改为$s$，然后广播一个dummy消息)</li>
<li>The receipt of this dummy message forces each recipient to increase its clock to a value $\geq s$ if not already $\geq s$.(接收到dummy消息的进程也把自己的时钟修改为$s$)</li>
<li>Each process takes a local snapshot and sends it to the initiator when (just before) its clock increases from a value less than $s$ to a value $\geq s$.(每个进程在将少于$s$的时钟值修改为$s$前，拍摄一个本地快照，并将快照发送给启动器)</li>
<li>The state of $C<em>{ij}$ is all messages sent along $C</em>{ij}$, whose timestamp is smaller than $s$ and which are received by $p_j$ after recording $LS_j$.(信道的状态是时间戳小于s，且在接收进程拍摄快照后才接收的所有消息)</li>
</ul>
</li>
</ul>
<h4 id="Termination-detection-scheme-如何判断算法结束"><a href="#Termination-detection-scheme-如何判断算法结束" class="headerlink" title="Termination detection scheme(如何判断算法结束)"></a>Termination detection scheme(如何判断算法结束)</h4><ul>
<li><p>A termination detection scheme for non-FIFO channels is required to detect that no white messages are in transit(算法结束的条件是没有白消息在传输)</p>
</li>
<li><p>First Method</p>
<ul>
<li>Each process i keeps a counter $cntr_i$ that indicates the difference between the number of white messages it has sent and received before recording its snapshot.(进程都保持一个计数器$cntr_i$，用来表示在拍摄快照之前已经发送的白消息和已经接收到的白消息的差值)</li>
<li>It reports this value to the initiator process along with its snapshot and forwards all white messages, it receives henceforth, to the initiator.(将此值与其快照一起报告给启动器进程，并在此后将后续收到的所有白色消息转发给启动器)</li>
<li>Snapshot collection terminates when the initiator has received $\Sigma_i cntr_i$ number of forwarded white messages(当启动器收到的白消息的数量和计数器$cntr_i$的总和相等时，算法结束)</li>
</ul>
</li>
<li><p>Second Method</p>
<ul>
<li>Each red message sent by a process carries a piggybacked value of the number of white messages sent on that channel before the local state recording.(进程发送的每条红色消息都附带了在本地状态记录之前在该信道上发送的白色消息数量的值)</li>
<li>Each process keeps a counter for the number of white messages received on each channel.(每个进程保持了一个计数器，用来记录每个信道上接收到的白色消息的数量，因为是通常是互相的，所以接收的应该等于发出去的)</li>
<li>A process can detect termination of recording the states of incoming channels when it receives as many white messages on each channel as the value piggybacked on red messages received on that channel.(当一个进程在每个信道上接收到的白色消息与在该信道上接收的红色消息上附带的值一样多时，可以检测到记录传入信道状态的终止)</li>
</ul>
</li>
</ul>
<h3 id="Snapshots-in-a-causal-delivery-system"><a href="#Snapshots-in-a-causal-delivery-system" class="headerlink" title="Snapshots in a causal delivery system"></a>Snapshots in a causal delivery system</h3><ul>
<li>The causal message delivery property CO provides a built-in message synchronization to control and computation messages.(因果消息传递属性CO为控制和计算消息提供了内置的消息同步，即有因果序)<ul>
<li>assume that the underlying system supports causal message delivery</li>
</ul>
</li>
<li>In both these algorithms recording of process state is identical(记录过程状态的算法是相同的) and proceed as follows :<ul>
<li>An initiator process broadcasts a token, denoted as token, to every process including itself.(启动器进程向每个进程广播一个token)</li>
<li>Let the copy of the token received by process $p_i$ be denoted $token_i$.(进程接收到token后都拷贝一个token副本)</li>
<li>A process $p_i$ records its local snapshot $LS_i$ when it receives $token_i$ and sends the recorded snapshot to the initiator.(接收到$token_i$时拍摄其本地快照$LS_i$，并将该记录的快照发送给启动器initiator)</li>
<li>The algorithm terminates when the initiator receives the snapshot recorded by each process.(当启动器接收到每个进程记录的快照后算法终止)</li>
</ul>
</li>
</ul>
<h4 id="Correctness-1"><a href="#Correctness-1" class="headerlink" title="Correctness"></a>Correctness</h4><ul>
<li>For any two processes $p_i$ and $p_j$, the following property is satisfied:<ul>
<li>$send(m<em>{ij})\notin LS_i \Rightarrow rec(m</em>{ij})\notin LS<em>j$(消息$m</em>{ij}$不在进程$p<em>i$的快照$LS_i$中，能推断出接收消息$m</em>{ij}$也不在进程$p_j$的快照$LS_j$中)</li>
<li>This is due to the causal ordering property of the underlying system as explained next<ul>
<li>Let a message $m<em>{ij}$ be such that $rec(token_i)\rightarrow send(m</em>{ij})$($send(m_{ij})\notin LS_i$)</li>
<li>Then $send(token<em>j)\rightarrow send(m</em>{ij})$ and the underlying causal ordering property ensures that $rec(token<em>j)$, at which instant process $p_j$ records $LS_j$, happens before $rec(m</em>{ij})$(进程$p<em>i$先发送$token_j$给进程$p_j$，然后才发送$m</em>{ij}$，所以进程$p<em>j$先收到$token_j$拍摄快照$LS_j$，然后才接收$m</em>{ij}$?)</li>
<li>Thus, $m_{ij}$ whose send is not recorded in $LS_i$, is not recorded as received in $LS_j$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Acharya-Badrinath-algorithm"><a href="#Acharya-Badrinath-algorithm" class="headerlink" title="Acharya-Badrinath algorithm"></a>Acharya-Badrinath algorithm</h4><ul>
<li>Each process $p_i$ maintains arrays $SENT_i[1, …, N]$ and $RECD_i[1, …, N]$(进程$p_i$维护两个数组，一个发送数组，一个接收数组)<ul>
<li>$SENT_i[j]$ is the number of messages sent by process $p_i$ to process $p_j$</li>
<li>$RECD_i[j]$ is the number of messages received by process $p_i$ from process $p_j$</li>
</ul>
</li>
<li>Channel states are recorded as follows:<ul>
<li>When a process $p_i$ records its local snapshot $LS_i$ on the receipt of $token_i$, it includes arrays $RECD_i$ and $SENT_i$ in its local state before sending the snapshot to the initiator(发送给启动器的快照包括发送数组和接收数组)</li>
</ul>
</li>
<li>When the algorithm terminates, the initiator determines the state of channels as follows:(判断算法终止)<ul>
<li>The state of each channel from the initiator to each process is empty(从启动器到每个进程的每个信道都是空的，即没有消息在信道)<ul>
<li>The state of channel from process $p_i$ to process $p_j$ is the set of messages whose sequence numbers are given by ${RECD_j[i]+1, …, SENT_i[j]}$(在两个进程之间信道的消息是根据发送和接收数组确定的，发送数组里有而接收数组里没有的则在信道)</li>
</ul>
</li>
</ul>
</li>
<li>Complexity<ul>
<li>This algorithm requires $2n$ messages and 2 time units for recording and assembling the snapshot, where one time unit is required for the delivery of a message.(遍历所有的各个进程的传入传出信道)</li>
<li>If the contents of messages in channels state are required, the algorithm requires $2n$$ messages and 2 time units additionally.(就是还要遍历所有各个进程的传入传出信道)</li>
</ul>
</li>
</ul>
<h4 id="Alagar-Venkatesan-algorithm"><a href="#Alagar-Venkatesan-algorithm" class="headerlink" title="Alagar-Venkatesan algorithm"></a>Alagar-Venkatesan algorithm</h4><ul>
<li>A message is referred to as old if the send of the message causally precedes the send of the token, Otherwise, the message is referred to as new.(在发送token之前的消息为旧消息，否则为新消息)</li>
<li>When a process receives the token, it takes its snapshot(收到token后拍摄快照), initializes the state of all channels to empty(将所有的信道状态初始化为空), and returns <code>Done</code> message to the initiator(将Done消息返回给启动器). </li>
<li>Now onwards, a process includes a message received on a channel in the channel state only if it is an old message.(当消息是旧消息的时候，进程才会接收到信道上的消息，因为新消息是token发送之后的消息，而收到token后将信道都变为空，即新消息都丢了？)</li>
<li>After the initiator has received <code>Done</code> message from all processes, it broadcasts a Terminate message.(启动器接收到所有进程的Done消息后，广播一个终止消息)<ul>
<li>A process stops the snapshot algorithm after receiving a Terminate message.(非启动器进程则在收到终止消息后终止快照算法)</li>
</ul>
</li>
</ul>
<h3 id="Necessary-and-sufficient-conditions-for-consistent-global-snapshots"><a href="#Necessary-and-sufficient-conditions-for-consistent-global-snapshots" class="headerlink" title="Necessary and sufficient conditions for consistent global snapshots"></a>Necessary and sufficient conditions for consistent global snapshots</h3><h4 id="Consistent-global-snapshots"><a href="#Consistent-global-snapshots" class="headerlink" title="Consistent global snapshots"></a>Consistent global snapshots</h4><ul>
<li>许多应用要求在执行或post martem期间定期记录和分析本地进程状态</li>
<li>进程在执行过程中保存的中间状态称为进程的本地检查点(local checkpoint)</li>
<li>一致的快照由一组同时发生或可能同时发生的本地状态集合组成</li>
<li>进程异步保存checkpoint，假设每个进程在执行前保存一个初始checkpoint，在执行完后保存一个虚拟checkpoint(virtual)<ul>
<li>进程$p<em>p$第i个checkpoint表示为$C</em>{p, i}$</li>
<li>进程$p_p$的第i个checkpoint间隔(interval)包括它的第i-1个checkpoint和第i个checkpoint之间执行的所有计算(包括了第i-1个checkpoint期间的计算但不包括第i个checkpoint)</li>
</ul>
</li>
<li>即使两个本地checkpoint没有存在因果路径，也可能不属于一致的全局快照</li>
</ul>
<h4 id="zigzag-path"><a href="#zigzag-path" class="headerlink" title="zigzag path"></a>zigzag path</h4><ul>
<li><p>A zigzag path exists from a checkpoint $C<em>{x, i}$ to a checkpoint $C</em>{y, j}$ iff there exists messages $m_1, m_2, …, m_n(n\geq 1)$:</p>
<ul>
<li>$m<em>1$ is sent by process $p_x$ after $C</em>{x, i}$(第一条消息由zigzag路径起点快照发送)</li>
<li>If $m<em>k(1\leq k\leq n)$ is received by process $p_z$, then $m</em>{k+1}$ is sent by $p<em>z$ in the same or a later checkpoint interval(although $m</em>{k+1}$ may be sent before or after $m_k$ is received)(通常来讲是消息有顺序。但也允许进程在接收到因果路径中的前一个消息之前发送消息，只要在同一个checkpoint间隔。后发送的消息在后一个间隔则不需考虑上述情况)</li>
<li>$m<em>n$ is received by process $p_y$ before $C</em>{y, j}$(最后一条消息由zigzag路径终点快照接收)</li>
<li>A zigzag path between two checkpoints is a causal path(因果路径)<ul>
<li>A causal path exists from a checkpoint A to another checkpoint B iff there is chain of messages starting after A and ending before B such that each message is sent after the previous one in the chain is received(因果路径消息必须有序)</li>
<li>a causal path is always a zigzag path, but a zigzag path need not be a causal path.</li>
</ul>
</li>
<li>如下图的进程$p<em>1$的快照$C</em>{1,1}$和进程$p<em>2$的快照$C</em>{2,2}$存在因果路径，zigzag路径允许进程$p<em>2$在接收消息$m_3$之前发送消息$m_4$给进程$p_3$，由快照$C</em>{3,2}$记录。因此$C<em>{1,1}$和$C</em>{3,2}$之间存在zigzag path<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/zigzag-path.png" alt="img"></li>
</ul>
</li>
<li><p>特殊的zigzag path—— zigzag cycle</p>
<ul>
<li>A checkpoint $C$ is involved in a zigzag cycle iff there is a zigzag path from $C$ to itself(起点和终点都是自己的zigzag路径)</li>
<li>如下图的进程$p<em>2$的快照$C</em>{2, 1}$，起始消息$m<em>2$给$p_1$，$p_1$在同一个checkpoint间隙早些时候发送消息$m_1$给$p_2$，终点也是$C</em>{2, 1}$</li>
<li>a causal path never forms a cycle.(因果路径不存在环)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/zigzag-cycle.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="Necessary-and-sufficient-conditions"><a href="#Necessary-and-sufficient-conditions" class="headerlink" title="Necessary and sufficient conditions"></a>Necessary and sufficient conditions</h4><ul>
<li>if no zigzag path (or cycle) exists between any two checkpoints from a set S of checkpoints, then a consistent snapshot can be formed that includes the set S of checkpoints and vice versa.(checkpoint集合中任意两个checkpoint之间都没有zigzag路径的话，则整个集合的checkpoint可以构成consistent global snapshot，反之亦然)<ul>
<li>The absence of a causal path between checkpoints in a snapshot corresponds to the necessary condition for a consistent snapshot(必要条件：如果一个snapshot是consistent的，则其中的检查点之间没有因果路径，zigzag路径是特殊的因果路径，没有因果路径自然也没有zigzag路径)</li>
<li>The absence of a zigzag path between checkpoints in a snapshot corresponds to the necessary and sufficient conditions for a consistent snapshot.(充要条件)</li>
<li>A set of checkpoints S can be extended to a consistent snapshot if and only if no checkpoint in S has a zigzag path to any other checkpoint in S.</li>
<li>A checkpoint can be a part of a consistent snapshot if and only if it is not invloved in a Z-cycle(要在consistent的snapshot中加入一个checkpoint，则当且仅当该checkpoint和snapshot中的任意一个checkpoint之间不存在zigzag路径，而其自身不存在zigzag回路)</li>
</ul>
</li>
</ul>
<h4 id="Finding-consistent-global-snapshots-in-a-distributed-computation"><a href="#Finding-consistent-global-snapshots-in-a-distributed-computation" class="headerlink" title="Finding consistent global snapshots in a distributed computation"></a>Finding consistent global snapshots in a distributed computation</h4><ul>
<li>Discuss how individual local checkpoints can be combined with those from other processes to form global snapshots that are consistent.</li>
<li>Let $A, B$ be individual checkpoints and $R, S$ be sets of checkpoints. Let $\leadsto$ be a relation defined over checkpoints and sets of checkpoints such that:<ul>
<li>$A\leadsto B$ iff a Z-path exists from $A$ to $B$</li>
<li>$A\leadsto S$ iff a Z-path exists from $A$ to some member of $S$</li>
<li>$S\leadsto A$ iff a Z-path exists from some member of $S$ to $A$</li>
<li>$R\leadsto S$ iff a Z-path exists from some member of $R$ to some member of $S$</li>
<li>$S\nrightarrow S$ defines that no Z-path(including Z-cycle) exists from any member of $S$ to any other member of $S$ and implies that checkpoints in $S$ are all from different processes</li>
</ul>
</li>
<li>A set of checkpoints $S$ can be extended to a consistent global snapshot iff $S\nrightarrow S$<ul>
<li>A checkpoint $C$ can be part of a consistent global snapshot iff it is not involved in a Z-cycle</li>
<li>A set of checkpoints $S$ is a consistent global snapshot iff $S\nrightarrow S$ and $|S|=N$, where $N$ is the number of processes</li>
</ul>
</li>
<li>Given a set $S$ of checkpoints such that $S\nrightarrow S$, what checkpoints from other processes can be combined with $S$ to build a consistent global snapshot?<ul>
<li>None of the checkpoints that have a Z-path to or from any of the checkpoints in $S$ can be used</li>
<li>Only those checkpoints that have no Z-paths to or from any of the checkpoints in $S$ are candidates for inclusion in the consistent snapshot<ul>
<li>The set of all such candidates is called as the Z-zone of $S$ and </li>
<li>All checkpoints that have no causal path to or from any checkpoint in $S$ is called as the C-cone of $S$ </li>
<li>the Z-cone of $S$ is a subset of the C-cone of $S$ for an arbitrary $S$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Z-cone%20and%20S-cone.png" alt="img"></li>
</ul>
</li>
<li>Although candidates for building a consistent snapshot from $S$ must lie in the Z-cone of $S$, not all checkpoints in the Z-cone can form a consistent snapshot with $S$. (在Z-cone里的检查点不一定能与$S$构成一致性的快照，但能与$S$构成一致性快照的检查点一定在Z-cone)<ul>
<li>If a checkpoint in the Z-cone is involved in a Z-cycle, then it cannot be part of a consistent snapshot.(Z-cone里可能存在zigzag环)</li>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$. Then, for each process $p<em>q$, the set $S</em>{useful}^q$ is defined as <ul>
<li>$S<em>{useful}^q={C</em>{q, i} | (S\nrightarrow C<em>{q, i}\bigwedge(C</em>{q, i}\nrightarrow S)\bigwedge(C<em>{q, i}\nrightarrow C</em>{q, i})}$</li>
<li>$\displaystyle S<em>{useful}=\bigcup_q S</em>{useful}^q$(各个进程可与$S$构成一致性快照的检查点的并集)</li>
</ul>
</li>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$, let $C<em>{q, i}$ be any checkpoint of process $p_q$ such that $C</em>{q, i}\notin S$. Then $S\bigcup {C<em>{q, i}}$ can be extended to a consistent snapshot iff $C</em>{q, i}\in S<em>{useful}$($S</em>{useful}$是所有可以与$S$构成一致性快照的检查点)</li>
</ul>
</li>
<li>Although none of the checkpoints in $S<em>{useful}$ has a Z-path to or from any checkpoint in $S$, Z-paths may exist between members of $S</em>{useful}$($S_{useful}$里的检查点之间可能会存在Z-path)</li>
<li>One final constraint is placed on the set $T$ we choose from $S_{useful}$ to build a consistent snapshot from $S$: checkpoints in $T$ must have no Z-paths between them. Furthermore, since $S\nrightarrow S$, at least one such $T$ must exist(即使只有一个元素)<ul>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$ and let $T$ be any set of checkpoints such that $S\bigcap T=\empty$. Then $S\bigcup T$ is a consistent global snapshot iff <ul>
<li>$T\subseteq S_{useful}$</li>
<li>$T\nrightarrow T$</li>
<li>$|S\bigcup T|=N$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Manivannan-Netzer-Singhal-algorithm-for-enumerating-consistent-snapshots-算法伪代码"><a href="#Manivannan-Netzer-Singhal-algorithm-for-enumerating-consistent-snapshots-算法伪代码" class="headerlink" title="Manivannan-Netzer-Singhal algorithm for enumerating consistent snapshots(算法伪代码)"></a>Manivannan-Netzer-Singhal algorithm for enumerating consistent snapshots(算法伪代码)</h4><ul>
<li>compute all consistent snapshots that include a given set a set of checkpoints $S$</li>
</ul>
<p>ComputeAllCgs($S$) {  // 计算一个完整的一致性快照<br>  $\quad$let $G=\empty$<br>  $\quad$if $S\nrightarrow S$ then<br>  $\quad<script type="math/tex">\quad$let `AllProcs` be the set of all processes not represented in $S$ // 在没有加入一致性快照的进程里选择
  $\quad</script>\quad$<code>ComputeAllCgsForm</code>($S$, $AllProcs$)<br>  $\quad$return $G$<br>}<br>ComputeAllCgsForm($T$, $ProcSet$) {<br>  $\quad$if $(ProcSet=\empty)$ then   // 已经是完整的一致性快照了<br>  $\quad<script type="math/tex">\quad</script>G=G\bigcup{T}$<br>  $\quad$else //否则递归查找<br>  $\quad<script type="math/tex">\quad$let $p_q$ be any process in $ProcSet$
  $\quad</script>\quad$for each checkpoint $C\in T_{useful}^q$ do  // 首先还是得保证检查点是可用的<br>  $\quad<script type="math/tex">\quad</script>\quad$<code>ComputeAllCgsForm</code>($T\bigcup{C}$, $ProcSet\setminus {p_q}$)<br>}</p>
<ul>
<li>Let $S$ be a set of checkpoints and $G$ be the set returned by <code>ComputeAllCgs</code>. If $S\nrightarrow S$, then $T\in G$ iff $T$ is a consistent snapshot containing $S$. That is, $G$ contains exactly the consistent snapshots that contain $S$</li>
</ul>
<h4 id="R-graph-to-determine-the-existence-of-Z-paths-between-checkpoints"><a href="#R-graph-to-determine-the-existence-of-Z-paths-between-checkpoints" class="headerlink" title="R-graph to determine the existence of Z-paths between checkpoints"></a>R-graph to determine the existence of Z-paths between checkpoints</h4><ul>
<li>Discuss a method for determining the existence of Z-paths between checkpoints in a distributed computation that has terminated or has stopped execution, using the rollback-dependency graph (R-graph).</li>
<li>The rollback-dependency graph of a distributed computation is a directed graph $G=(V, E)$, where the vertices $V$ are the checkpoint of the distributed computation and an edge $(C<em>{p, i}, C</em>{q, j})$ from checkpoint $C<em>{p, i}$ to checkpoint $C</em>{q, j}$ belongs to $E$ if<ul>
<li>$p=q$ and $j=i+1$</li>
<li>$p\neq q$ and a message $m$ sent from the $i^{th}$ checkpoint interval of $p_p$ is received by $p_q$ in its $j^{th}$ checkpoint interval($i, j\gt 0$)</li>
<li>there is a path from $C$ to $D$ in the R-graph by $C\rightsquigarrow^{rd} D$, only denotes the existence of a path, does not specify any particular path</li>
</ul>
</li>
<li>Let $G=(V, E)$ be the R-graph of a distributed computation. For any two checkpoints $C_p^i$ and $C_q^j$, $C_p^i\rightsquigarrow C_q^j$ iff:<ul>
<li>$p=q$ and $i\lt j$(因果路径)</li>
<li>$ C_p^{i+1}\rightsquigarrow^{rd} C_q^j$ in $G$(note that in this case $p$ could still be equal to $q$)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Rgraph.png" alt="img"></p>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>术语和基本算法</title>
    <url>/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%9C%AF%E8%AF%AD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="术语和基本算法"><a href="#术语和基本算法" class="headerlink" title="术语和基本算法"></a>术语和基本算法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="拓扑-Topology"><a href="#拓扑-Topology" class="headerlink" title="拓扑(Topology)"></a>拓扑(Topology)</h3><ul>
<li>System: 无向(加权)图<ul>
<li>(N, L): N为图中的点，L为边</li>
</ul>
</li>
<li>物理拓扑Physical topology<ul>
<li>节点(Nodes): 网络节点，路由器，所有的终端主机(无论是否参与)</li>
<li>边(Edges): 所有的LAN，WAN的链接，在终端主机之间的直接边</li>
</ul>
</li>
<li>逻辑拓扑(Logical topology, 从应用内容判断)<ul>
<li>节点(Nodes): 应用所在运行的终端主机</li>
<li>边(Edges): 节点之间的逻辑信道</li>
<li>逻辑拓扑的叠加(Superimposed topology or topology overlay)<ul>
<li>目标是更有效地进行信息的聚集、分发和查找(P2P)</li>
<li>环、树、网格(mesh)、超立方体(hypercube)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%82%BB%E5%9F%9F%E8%A7%86%E5%9B%BE.png" alt="img"></p>
<ul>
<li>图a为邻域视图(neighborhood view)<ul>
<li>子图(subgraph)，部分系统视图</li>
<li>需要多跳路径，易于维护(因为不是全连接，所以稳定性更好，出故障不会瘫痪一片)</li>
</ul>
</li>
<li>图b为全连接(All-to-all fully connected)</li>
</ul>
<h3 id="应用执行和控制算法执"><a href="#应用执行和控制算法执" class="headerlink" title="应用执行和控制算法执"></a>应用执行和控制算法执</h3><ul>
<li>两者都有各自自己的事件(event)</li>
<li>控制算法:<ul>
<li>用于监控和辅助的功能，例如创建ST、MIS、CDS、达成共识、全局状态检测(是否发生死锁、终止)，检查点(checkpoint)</li>
<li>叠加在应用执行上，但不会干扰应用的执行</li>
<li>发送、接收和内部事件都是对应用程序的执行是透明的</li>
<li>需要特殊的协议</li>
</ul>
</li>
</ul>
<h3 id="集中式和分布式算法"><a href="#集中式和分布式算法" class="headerlink" title="集中式和分布式算法"></a>集中式和分布式算法</h3><ul>
<li><p>集中式算法：</p>
<ul>
<li>其中的角色是不对称的，客户端-服务端式配置</li>
<li>瓶颈是传输带宽和服务端的处理能力</li>
<li>会出现点失效的问题，即服务端出问题，所有客户端都不可用</li>
</ul>
</li>
<li><p>分布式算法</p>
<ul>
<li>节点的角色更加平衡</li>
<li>难以设计完美的分布式算法(例如快照算法、基于树的算法(tree-based algorithms))</li>
</ul>
</li>
</ul>
<h3 id="对称-symmetric-和非对称-asymmetric-算法"><a href="#对称-symmetric-和非对称-asymmetric-算法" class="headerlink" title="对称(symmetric)和非对称(asymmetric)算法"></a>对称(symmetric)和非对称(asymmetric)算法</h3><h3 id="匿名算法"><a href="#匿名算法" class="headerlink" title="匿名算法"></a>匿名算法</h3><ul>
<li>进程的id或处理器的id不用于在运行时做出任何执行决策<ul>
<li>结构很优雅但是很难设计，几乎是不可能的(无法匿名选举通信的领导人)</li>
</ul>
</li>
</ul>
<h3 id="统一算法"><a href="#统一算法" class="headerlink" title="统一算法"></a>统一算法</h3><ul>
<li>不能在代码中使用进程数n作为参数</li>
<li>匀速可扩展性，使得进程离开或加入变得更加容易，只需要让邻居知道逻辑拓扑的变化即可</li>
</ul>
<h3 id="自适应算法"><a href="#自适应算法" class="headerlink" title="自适应算法"></a>自适应算法</h3><ul>
<li>让k($k&lt;n$)作为执行X时参与问题X上下文的进程数量，计算复杂度的时候应该表示为k的函数而不是n的函数</li>
<li>例如互斥，对关键段争用的开销可以表示为此时争用段的进程的数量(k)</li>
</ul>
<h3 id="非确定性接收和确定性接收"><a href="#非确定性接收和确定性接收" class="headerlink" title="非确定性接收和确定性接收"></a>非确定性接收和确定性接收</h3><ul>
<li>非确定行接收: 可以接收来自任何来源的消息</li>
<li>确定性接收: 只能接收固定来源的消息</li>
</ul>
<h3 id="确定性和非确定性的执行"><a href="#确定性和非确定性的执行" class="headerlink" title="确定性和非确定性的执行"></a>确定性和非确定性的执行</h3><ul>
<li>确定性执行<ul>
<li>没有非确定性的接收</li>
<li>异步系统重新执行确定性程序将对事件产生相同的偏序(用于调试、不稳定谓词检测)</li>
</ul>
</li>
<li>非确定性执行<ul>
<li>至少包含1个非确定性的接收</li>
<li>异步系统重新执行非确定性程序可能会产生不同的偏序(无限的交付事件和不可预测的拥塞，可变的本地CPU调度延迟等)</li>
</ul>
</li>
</ul>
<h3 id="执行抑制-Execution-inhibition-freezing"><a href="#执行抑制-Execution-inhibition-freezing" class="headerlink" title="执行抑制(Execution inhibition/freezing)"></a>执行抑制(Execution inhibition/freezing)</h3><ul>
<li>要求在某些规定的操作发生之前暂停正常执行的协议都是抑制性的<ul>
<li>非抑制性协议是指在任何执行中都不禁用任何事件</li>
<li>局部抑制性协议是指在任何执行中，任何延迟事件都是本地延迟事件，即本地控制下的抑制，不依赖于任何接收事件</li>
<li>全局抑制性协议是指在某些执行中，某些延迟事件不会在本地延迟</li>
</ul>
</li>
<li>但和阻塞非阻塞原语不同</li>
<li>抑制性的其他分类<ul>
<li>发送抑制(send inhibitory)</li>
<li>接收抑制(receive inhibitory)</li>
<li>内部事件抑制(internal event inhibitory)</li>
</ul>
</li>
</ul>
<h3 id="同步和异步系统"><a href="#同步和异步系统" class="headerlink" title="同步和异步系统"></a>同步和异步系统</h3><ul>
<li>同步系统<ul>
<li>有消息延迟上限</li>
<li>已知时钟相对于真实事件的漂移率有界</li>
<li>已知进程执行的逻辑步骤的上限</li>
</ul>
</li>
<li>异步系统<ul>
<li>同步系统的3个条件都不满足</li>
<li>分布式系统本质上是异步系统，同步系统是特殊的异步系统</li>
</ul>
</li>
</ul>
<h3 id="On-line算法和off-line算法"><a href="#On-line算法和off-line算法" class="headerlink" title="On-line算法和off-line算法"></a>On-line算法和off-line算法</h3><ul>
<li><p>On-line:</p>
<ul>
<li>‌不需要预先知道全部输入信息，可以逐步接收和处理每个数据元素。它适用于需要实时处理和决策的场景，如股市交易、网络路由等‌，对于调试和调度有优势</li>
</ul>
</li>
<li><p>Off-line:</p>
<ul>
<li>需要预先知道所有的输入信息，然后进行全面分析和处理。它适用于可以预先收集所有数据的情况，如大规模数据集上的机器学习训练‌</li>
</ul>
</li>
</ul>
<h3 id="无等待-Wait-free-算法"><a href="#无等待-Wait-free-算法" class="headerlink" title="无等待(Wait-free)算法"></a>无等待(Wait-free)算法</h3><ul>
<li>这是用于同步操作</li>
<li>对$n-1$个进程故障具有弹性，即任何进程的操作都必须在有限的步骤内完成，而与其他进程无关<ul>
<li>无等待是一种比无锁更强的条件，无等待算法要求在无锁算法的定义基础上，增加一个条件：所有上下文的执行都必须在有限的步骤内可以完成，而不依赖于其他上下文的状态。</li>
</ul>
</li>
<li>非常稳定，但是成本很高</li>
<li>可能用来设计互斥操作</li>
<li>可能并不总是能够设计出来的(例如生产者消费者问题)</li>
</ul>
<h3 id="通信信道-Communication-channels"><a href="#通信信道-Communication-channels" class="headerlink" title="通信信道(Communication channels)"></a>通信信道(Communication channels)</h3><ul>
<li>点到点: FIFO、non-FIFO<ul>
<li>在应用层FIFO通常是由网络栈(network stack)提供</li>
</ul>
</li>
</ul>
<h3 id="进程故障-严重程度依次增加"><a href="#进程故障-严重程度依次增加" class="headerlink" title="进程故障(严重程度依次增加)"></a>进程故障(严重程度依次增加)</h3><ul>
<li>故障停止(Fail-stop): 正常运行的进程停止执行，其他进程了解到失败的进程(通过某种机制) </li>
<li>Crash: 正常运行的进程停止执行，其他进程无法了解哪个是失败的进程</li>
<li>Receive omission(接收遗漏): 正常运行的进程会因为接收到已经发送过给它的一些消息而失败或crash。</li>
<li>Send omission(发送遗漏): 正常运行的进程会因为发送了已经发送过的消息而失败或crash，不过和接收遗漏模型不同</li>
<li>General omission(普遍遗漏): 接收遗漏+发送遗漏</li>
<li>Byzantine(or malicious) failiure(拜占庭式(恶意)失败): 即进程可能做任何行为，甚至是错误的行为，包括发生虚假信息 <ul>
<li>with authentication(带有验证): 如果一个有缺陷的线程声称收到了来自正确线程的消息，那么这是可以验证的。因为可以往正确线程查证</li>
<li>without authentication(没有验证)</li>
<li>注意: 非恶意故障模型(non-malicious failure models)是良性的</li>
</ul>
</li>
</ul>
<h4 id="进程故障的条件"><a href="#进程故障的条件" class="headerlink" title="进程故障的条件"></a>进程故障的条件</h4><ul>
<li>时间错误(对于同步系统)<ul>
<li>普遍遗漏故障(General omission)</li>
<li>违反指定漂移率的时钟(clocks violating specified drift rates)</li>
<li>违反执行步骤时间限制(process violating bounds on time to execute a step)</li>
</ul>
</li>
<li>链接错误<ul>
<li>Crash故障: 正常运行的链接停止传输消息</li>
<li>Omission故障: 链接只携带其中发送的一些消息，不携带其他消息</li>
<li>拜占庭式(恶意)故障: 链接表现出任意行为，包括创建虚假消息和篡改在链接上发送的消息</li>
</ul>
</li>
<li>链接错误导致的时间错误(对于同步系统):<ul>
<li>消息传递速度比指定的行为更快或更慢</li>
</ul>
</li>
</ul>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><ul>
<li>下界(lower bound, $\Omega$)</li>
<li>上界(upper bound, $O$)</li>
<li>上确界(exact bound, $\theta$)</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li>每个节点的空间复杂度</li>
<li>全系统的空间复杂度(不等价于系统中所有节点的空间复杂度之和)，因为最坏的情况通常不会同时发生在所有节点</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>每个节点的时间复杂度</li>
<li>全系统的时间复杂度，取决于节点是否完全并发执行</li>
</ul>
<h3 id="消息复杂度-Message-complexity"><a href="#消息复杂度-Message-complexity" class="headerlink" title="消息复杂度(Message complexity)"></a>消息复杂度(Message complexity)</h3><ul>
<li>消息的数量: 影响消息负载的空间复杂度</li>
<li>消息的大小: 影响消息负载的空间复杂度和通过增加传输时间影响时间复杂度的分量</li>
<li>消息时间复杂度: 取决于消息的数量、大小和发送接收消息的并发性</li>
</ul>
<h3 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h3><ul>
<li>发送和接收事件(send and receive events)</li>
<li>广播(multicasts)</li>
<li>共享存储系统(Shared memory systems): 共享存储的大小，通过原子操作实现同步</li>
</ul>
<h2 id="程序结构-Program-Structure"><a href="#程序结构-Program-Structure" class="headerlink" title="程序结构(Program Structure)"></a>程序结构(Program Structure)</h2><ul>
<li>通信顺序进程(Communicating Sequential Process, CSP)<ul>
<li>$*[G_1\leftarrow CL_1 || G_2\leftarrow CL_2|| … || G_k\leftarrow CL_k]$<ul>
<li>重复命令”*”表示无限循环</li>
<li>选择命令”||”是在受保护命令上进行的。指定执行其组成受保护命令中的一个。</li>
<li>受保护(guarded)命令的语法: $G\leftarrow CL$<ul>
<li>Guard $G$是布尔表达式</li>
<li>$CL$是如果$G$为真时要执行的命令的列表</li>
<li>Guard(门)检查来自另一进程到达的消息</li>
<li>如果所有的guard都是false，则选择命令失败</li>
<li>如果多个guard都是true，则非确定性地选择一个执行(随机？)<ul>
<li>$G_m\leftarrow CL_m$, $CL_m, G_m$是原子化操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><h3 id="Sync-1-initiator-ST-flooding"><a href="#Sync-1-initiator-ST-flooding" class="headerlink" title="Sync 1-initiator ST (flooding)"></a>Sync 1-initiator ST (flooding)</h3><ul>
<li>ST: Spanning tree<ul>
<li>生成树是没有循环并且连通的。对于任何连通图，至少存在一棵生成树。如果图中有 n 个顶点，则生成树将有 n-1 条边。最坏情况高度为n-1</li>
</ul>
</li>
<li>1个启动器的生成树同步算法(泛洪)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Sync%201-initiator%20ST%20(flooding" alt="img">.png)</p>
<ul>
<li>流程<ul>
<li>随机选择根节点作为启动器</li>
<li>每个节点标识父节点(随机挑选)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Sync%201-initiator%20ST%20(flooding" alt="img">2.png)</p>
<ul>
<li>终止条件: 迭代轮次到达直径(即节点间的最长距离)</li>
<li>复杂度<ul>
<li>本地<ul>
<li>空间复杂度: $O(degree)$</li>
<li>时间复杂度: $O(degree+diameter)$</li>
</ul>
</li>
<li>全局<ul>
<li>空间复杂度: $O(\sum local_ space)$</li>
</ul>
</li>
<li>消息<ul>
<li>时间复杂度: 直径或者消息的跳数</li>
<li>数量复杂度: 每条边的消息数量$\geq 1, \leq 2$。$[l, 2l]$</li>
</ul>
</li>
<li>类似于广度优先搜索</li>
</ul>
</li>
</ul>
<h3 id="Asynchronous-1-init-Spanning-Tree"><a href="#Asynchronous-1-init-Spanning-Tree" class="headerlink" title="Asynchronous 1-init Spanning Tree"></a>Asynchronous 1-init Spanning Tree</h3><ul>
<li>1个启动器的生成树异步算法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%201-init%20Spanning%20Tree.png" alt="img"></p>
<ul>
<li>流程<ul>
<li>根节点启动泛洪<code>QUERY</code>识别生成树的边缘</li>
<li>父节点: 接收到的第一个<code>QUERY</code>对应的节点，先到先得<ul>
<li>发送<code>ACCEPT(+rsp)</code>给挑选的父节点作为回应</li>
<li>发送<code>REJECT(-rsp)</code>给非父节点的<code>QUERY</code></li>
<li>继续发送<code>QUERY</code>给其他的邻居节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%201-init%20Spanning%20Tree1.png" alt="img"></p>
<ul>
<li>本地终止条件: 当接收到所有来自邻居非父节点的<code>ACCEPT</code>或者<code>REJECT</code>时</li>
<li>复杂度<ul>
<li>本地<ul>
<li>空间复杂度: $O(degree)$</li>
<li>时间复杂度: $O(degree)$</li>
</ul>
</li>
<li>全局<ul>
<li>空间复杂度: $O(\sum local_space)$</li>
</ul>
</li>
<li>消息<ul>
<li>时间复杂度: 直径+1的跳数(因为有个最终回复)</li>
<li>数量复杂度: 每条边的消息数量$\geq 2, \leq 4$，$[2l, 4l]$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Asynchronous-Spanning-Tree-Concurrent-Initiators"><a href="#Asynchronous-Spanning-Tree-Concurrent-Initiators" class="headerlink" title="Asynchronous Spanning Tree: Concurrent Initiators"></a>Asynchronous Spanning Tree: Concurrent Initiators</h3><ul>
<li><p>多个并发启动器的生成树异步算法</p>
</li>
<li><p>没有预先设计规定的根节点</p>
<ul>
<li>可选1: 合并部分生成树，但是很难只根据本地知识完成，会导致循环</li>
<li>可选2: 只允许一个生成树继续进行计算，停止其他的生成树(算法使用该思路，选择具有更大进程id的节点继续)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20Spanning%20Tree%20Concurrent%20Initiators1.png" alt="img"></p>
<ul>
<li><p>流程</p>
<ul>
<li>节点可以自发启动算法并成为根(启动器)</li>
<li>每个根启动1个启动器算法生成树异步算法的变体，在中间节点抑制较低优先级的根。<ul>
<li>当<code>QUERY</code>、<code>ACCEPT</code>和<code>REJECT</code>到达节点时，行动取决于当前节点的根节点和新节点的优先级。</li>
</ul>
</li>
</ul>
</li>
<li><p>终止条件: 只有根节点探测到终止才能终止，要求发送额外的消息通知其他节点终止。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20Spanning%20Tree%20Concurrent%20Initiators.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20Spanning%20Tree%20Concurrent%20Initiators0.png" alt="img"></p>
<ul>
<li>复杂度<ul>
<li>时间复杂度: $O(l)$</li>
<li>消息数量复杂度: $O(nl)$</li>
</ul>
</li>
</ul>
<h3 id="Asynchronous-DFS-Spanning-Tree"><a href="#Asynchronous-DFS-Spanning-Tree" class="headerlink" title="Asynchronous DFS Spanning Tree"></a>Asynchronous DFS Spanning Tree</h3><ul>
<li>和非DFS算法一样处理并发启动器<ul>
<li>当<code>QUERY</code>、<code>ACCEPT</code>和<code>REJECT</code>到达节点时，行动取决于当前节点的根节点和新节点的优先级。</li>
</ul>
</li>
<li>终止条件: 只有当根节点检测到终止时，用生成树的路径通知其他节点终止。</li>
<li>时间复杂度: $O(l)$</li>
<li>消息数量复杂度: $O(nl)$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20DFS%20Spanning%20Tree.png" alt="img"></p>
<h3 id="Broadcast-and-Convergecast-on-a-Tree"><a href="#Broadcast-and-Convergecast-on-a-Tree" class="headerlink" title="Broadcast and Convergecast on a Tree"></a>Broadcast and Convergecast on a Tree</h3><ul>
<li>生成树上消息的广播和聚合算法</li>
<li>广播: 分发消息<ul>
<li>根节点向所有子节点发送要广播的消息，根节点终止。</li>
<li>当一个非根节点从其父节点接收到消息时，将其复制并转发给其他子节点，该非根节点终止</li>
</ul>
</li>
<li>聚合: 在根节点收集消息，以计算全局函数<ul>
<li>用途：计算最小值、最大值、领导者选举、计算全局状态函数</li>
<li>叶子节点将消息发送给父节点，叶子节点终止</li>
<li>非叶节点接收到来自所有子节点的消息后，将收集的消息发送给父节点，该非叶子节点终止</li>
<li>根节点接收到所有子节点的消息后，全局函数完成计算后，根节点终止</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Broadcast%20and%20Convergecast%20on%20a%20Tree.png" alt="img"></p>
<ul>
<li>时间复杂度: $O(h)$</li>
<li>消息数量复杂度: $n-1$</li>
</ul>
<h3 id="Single-Source-Shortest-Path-Sync-Bellman-Ford"><a href="#Single-Source-Shortest-Path-Sync-Bellman-Ford" class="headerlink" title="Single Source Shortest Path: Sync Bellman-Ford"></a>Single Source Shortest Path: Sync Bellman-Ford</h3><ul>
<li>单源最短路径的同步算法<ul>
<li>整体为加权图，没有负权重的环</li>
<li>没有节点具有全局视图，仅拥有本地拓扑</li>
</ul>
</li>
<li>流程<ul>
<li>假设节点知道n轮迭代后，算法终止<ul>
<li>经过k轮之后，对于任意给定的节点，它应该已经知道所有可以通过最多k跳到达的其他节点的最短路径长度。</li>
</ul>
</li>
</ul>
</li>
<li>终止: 第n轮迭代</li>
<li>时间复杂度: $n-1$</li>
<li>消息数量复杂度: $(n-1)l$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Single%20Source%20Shortest%20Path%20Sync%20Bellman-Ford.png" alt="img"> </p>
<h3 id="Distance-Vector-Routing"><a href="#Distance-Vector-Routing" class="headerlink" title="Distance Vector Routing"></a>Distance Vector Routing</h3><ul>
<li>距离向量路由算法<ul>
<li>用于互联网路由(流行到20世纪80年代中期)，具有动态变化的图，其中链接权重模拟延迟/负载</li>
<li>Sync Bellman-Ford的变体: 外层循环改为无限，就是说没有终止</li>
<li>追踪通往每个目的地的最短路径</li>
<li>长度替换为$LENGTH[1..n]$；父节点替换为$PARENT[1..n]$</li>
<li>第k个分量表示从某个源节点(通常是执行算法的那个节点)到网络中第k个节点的当前最佳已知距离，$LENGTH[k]$</li>
</ul>
</li>
<li>每次迭代的流程<ul>
<li>对每个目的地独立应用三角不等式<ul>
<li>$LENGTH[k]\gt (LENGTH<em>j[k] + weight</em>{j, i})$</li>
<li>节点i用RTT或者到邻居节点j的排队延迟评估$weight_{i, j}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Single-Source-Shortest-Path-Async-Bellman-Ford"><a href="#Single-Source-Shortest-Path-Async-Bellman-Ford" class="headerlink" title="Single Source Shortest Path: Async Bellman-Ford"></a>Single Source Shortest Path: Async Bellman-Ford</h3><ul>
<li>单源最短路径的异步算法<ul>
<li>整体为加权图，没有负权重的环   </li>
<li>没有节点具有全局视图，仅拥有本地拓扑</li>
</ul>
</li>
<li>复杂度(c是常数)<ul>
<li>时间复杂度: 最坏情况$\Omega(c^n\cdot d)$</li>
<li>消息数量复杂度: 最坏情况有$\Omega(C^n)$条消息。<ul>
<li>如果所有的边有相同的权重，算法计算最小跳数，需要用$O(n^2\cdot l)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Single%20Source%20Shortest%20Path%20Async%20Bellman-Ford.png" alt="img"></p>
<h3 id="All-All-Shortest-Paths-Floyd-Warshall"><a href="#All-All-Shortest-Paths-Floyd-Warshall" class="headerlink" title="All-All Shortest Paths: Floyd-Warshall"></a>All-All Shortest Paths: Floyd-Warshall</h3><ul>
<li>所有节点的最短路径<ul>
<li>就是为每个节点跑一次最短路径，加一个外循环</li>
</ul>
</li>
<li>复杂度<ul>
<li>时间复杂度: $O(n^3)$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/All-All%20Shortest%20Paths%20Floyd-Warshall1.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/All-All%20Shortest%20Paths%20Floyd-Warshal.png" alt="img"></p>
<h3 id="Distributed-Floyd-Warshall"><a href="#Distributed-Floyd-Warshall" class="headerlink" title="Distributed Floyd-Warshall"></a>Distributed Floyd-Warshall</h3><ul>
<li>$LENGTH[1…n, 1…n], VIA[1…n, 1…n]$的第i行存储在第i个节点，负责更新第i行，i作为源节点</li>
<li>对应于上个集中式算法的第4行<ul>
<li>节点i如何在每次迭代中访问远程数据$LENGTH[pivot, t]?$<ul>
<li>分布式的动态汇点树: 在每次迭代中选择一个枢轴节点(pivot)，所有与枢轴节点有非无穷大路径的节点都会形成一个汇点树，其中枢轴节点是汇点。可以确保节点能够高效访问所需的远程数据。</li>
</ul>
</li>
<li>如何在不同节点之间同步外循环的迭代执行(否则算法出错)<ul>
<li>模拟”同步器”的操作: 使用接收操作确保节点之间的同步(节点可以通过接收来自其父节点的数据$LENGTH[pivot, *]$来确保同步执行)</li>
</ul>
</li>
</ul>
</li>
<li>重命名$LENGTH[i, j], VIA[i, j]$为$LEN[j], PARENT[j]$<ul>
<li>例如$LENGTH[i, pivot]$为$LEN[pivot]$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Distributed%20Floyd-Warshall1.png" alt="img"></p>
<ul>
<li>流程<ul>
<li>在任何节点i中，迭代pivot:<ul>
<li>如果$LEN[pivot]\neq \infin$，则枢轴节点将$LEN[*]$分发给所有在枢轴节点的汇点树中的节点，包括节点i</li>
<li>汇点树中的父子边需要被标识<ul>
<li>节点向$PARENT[pivot]$发送<code>IN_TREE</code>，向其他邻居节点发送<code>NOT_IN_TREE</code></li>
<li>接收到某个节点的<code>IN_TREE</code>回复，说明该节点是pivot在汇点树中的子节点</li>
</ul>
</li>
<li>等待每个邻居的<code>IN_TREE</code>或<code>`NOT_IN_TREE</code>，发送和接收是同步的</li>
<li>枢轴节点向下广播$LEN[*]$到汇点树中，发送和接收也是同步的</li>
<li>所有节点以伪锁定步骤执行三角不等式</li>
</ul>
</li>
<li>复杂度<ul>
<li>时间复杂度: 每个节点的执行时间复杂度$O(n^2)$再加上n次广播的时间</li>
<li>消息数量复杂度: n次迭代<ul>
<li>每次迭代:<ul>
<li>每条边发送2条<code>IN_TREE</code>或<code>NOT_IN_TREE</code>消息，每条消息大小为$O(1)$，总$O(l)$</li>
<li>最多n-1条<code>PIV_LEN</code>消息，每条消息大小为$O(n)$(n个节点的长度信息)，总共$O(n)$</li>
</ul>
</li>
<li>总共$O(n(l+n))$条消息，占用$O(nl+n^3)$的消息空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Distributed%20Floyd-Warshall.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Distributed%20Floyd-Warshall0.png" alt="img"></p>
<h3 id="Constrained-flooding-no-ST"><a href="#Constrained-flooding-no-ST" class="headerlink" title="Constrained flooding(no ST)"></a>Constrained flooding(no ST)</h3><ul>
<li>约束泛洪算法(无生成树)</li>
<li>使用FIFO通道，并通过序列号检测重复的消息</li>
</ul>
<h4 id="Async-constrained-flooding-no-ST"><a href="#Async-constrained-flooding-no-ST" class="headerlink" title="Async, constrained flooding(no ST)"></a>Async, constrained flooding(no ST)</h4><ul>
<li>异步约束泛洪算法(无生成树)<ul>
<li>被IPV4中的链路状态路由(Link State Routing)使用</li>
<li>复杂度<ul>
<li>时间复杂度: 直径d个连续跳数</li>
<li>消息数量复杂度: 最坏情况$2l$条消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Async%20constrained%20flooding.png" alt="img"></p>
<h4 id="Sync-constrained-flooding-no-ST"><a href="#Sync-constrained-flooding-no-ST" class="headerlink" title="Sync, constrained flooding(no ST)"></a>Sync, constrained flooding(no ST)</h4><ul>
<li>同步约束泛洪算法(无生成树)<ul>
<li>$STATEVEC[k]$是对k的数据的统计</li>
</ul>
</li>
<li>复杂度: <ul>
<li>时间复杂度: 直径d轮迭代</li>
<li>消息数量复杂度: 发送$2ld$条消息，每条消息大小为$n$(每轮$2l$，d轮)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Sync%20constrained%20flooding.png" alt="img"></p>
<h3 id="MST-sync"><a href="#MST-sync" class="headerlink" title="MST, sync"></a>MST, sync</h3><ul>
<li>最小生成树同步算法</li>
<li>假设无向加权图，如果权重不是唯一的，假设使用某种打破平局的方法，如节点ID，来对边的权重施加全序。</li>
<li>Kruskal 的 MST 算法:<ul>
<li>假设图的组件森林</li>
<li>维护排序的边列表</li>
<li>在每次迭代中，识别连接两个不同组件的最小权重边</li>
<li>将该边包含在 MST 中</li>
<li>时间复杂度：$O(l*logl)$</li>
</ul>
</li>
<li>Prim的 MST算法<ul>
<li>从一个单节点组件开始</li>
<li>在每次迭代中，选择与当前组件相邻的最小权重边。组件通过这条选定的边扩展。</li>
<li>时间复杂度：O(n^2) (或$O(n*logn)$使用 Fibonacci 堆在稠密图中) </li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Minimum%20Weight%20Outgoing%20Edge.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MST%20Example.png" alt="img"></p>
<ul>
<li><p>Gallagher-Humblet-Spira 分布式 MST </p>
<ul>
<li>使用 Kruskal 的策略，从图的组件森林开始。</li>
<li>MWOE(minimum weight outgoing edge): <ul>
<li>最小权重的出边: D”outgoing” 是逻辑上的，表示组件扩展的方向。<ul>
<li>对于图$G$的任何生成森林${(N_i, L_i)|i=1, …, k}$，考虑其中的任意一个组件$(N_j, L_j)$。记$\lambda_j$为那些仅与$N_j$中的一个节点相邻的所有边中权重最小的边。包含生成森林中所有边$L_i$的$G$的最小生成树，也必须包含边$\lambda_j$</li>
</ul>
</li>
<li>连通组件的生成树与 MWOEs 结合，以在合并后的组件中仍然保留生成树属性。</li>
<li>并发地合并 MWOEs：最多有$\frac{n}{2^k}$个组件，因此最多需要$log n$次迭代</li>
<li>每个组件在每次迭代中都有一个领导者节点。</li>
<li>每个组件内的每次迭代包含 5 个步骤，由领导者触发：<ul>
<li>广播-收敛阶段：领导者识别 MWOE。</li>
<li>广播阶段：确定下一次迭代的潜在领导者。</li>
<li>广播阶段：在合并组件中选择一个领导者；它向新组件中的所有节点标识自己。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>根节点广播<code>SEARCH_MWOE</code>以查找最小权重出边（MWOE）。</li>
<li>收敛广播<code>REPLY_MWOE</code>: 邻居节点收到 SEARCH_MWOE 后，将回复 REPLY_MWOE 消息，报告它们找到的 MWOE。</li>
<li>根节点广播<code>ADD_MWOE</code>: 根节点收集所有 REPLY_MWOE 消息后，选择一个 MWOE 并广播 ADD_MWOE 消息，指示其他节点添加该边到生成树中。</li>
<li>如果 MWOE 也被 MWOE 的另一端组件选为 MWOE，则具有较高 ID 的事件过程是下一次迭代的领导者，并广播 <code>NEW_LEADER</code>。</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>时间复杂度: $O(n*logn)$($logn$次迭代，因为并发地合并)</li>
<li>消息复杂度: <ul>
<li>每轮迭代，每条树的边$O(n)$条消息</li>
<li>每轮迭代，1条<code>EXAMINE</code>消息用来确定MWOEs</li>
<li>因此为$O((n+l)logn)$条消息</li>
</ul>
</li>
<li>正确性要求同步操作<ul>
<li>在步骤 (2) 中，使用 <code>EXAMINE</code> 来确定未标记的邻居是否属于同一组件。如果未标记边的节点处于不同的级别，则会出现问题！</li>
<li>考虑在边$(j, k)$上发送<code>EXAMINE</code>，该边实际属于同一组件。但是k可能还没有发现它属于新组件和新的领导者ID，并且回复为<code>+ve</code>，说两者属于不同组件，于是j又继续发<code>EXAMINE</code>给k。</li>
<li>这可能导致循环。</li>
</ul>
</li>
</ul>
</li>
<li>需要使用额外的消息/步骤<ul>
<li>新的领导者在新的组件的标记边执行广播和收敛广播<ul>
<li>步骤2中，如果接收者还处于旧的迭代轮次，则可能延迟对<code>EXAMINE</code>消息的响应</li>
<li>总共需要$n*logn$条额外消息</li>
</ul>
</li>
<li>在参与新的迭代轮次时，需要通知每个邻居节点<ul>
<li>当所有未标记边上的邻居在同一轮次时发送<code>EXAMINE</code>消息。</li>
<li>总共需要$l*logn$条额外消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Sync%20GHS%20Message%20Types.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Sync%20GHS%20Code.png" alt="img"></p>
<h3 id="MST-async"><a href="#MST-async" class="headerlink" title="MST, async"></a>MST, async</h3><ul>
<li>最小生成树异步算法</li>
<li>复杂度<ul>
<li>时间复杂度: $O(n*logn(l+d))$</li>
<li>消息复杂度: $O(n*logn + l)$</li>
</ul>
</li>
<li>挑战<ul>
<li>确定相邻节点的级别</li>
<li>与单个组件反复合并导致$logn$变成$n$</li>
<li>如果组件处于不同级别，需要协调搜索最小权重出边MWOEs和合并</li>
</ul>
</li>
</ul>
<h3 id="Synchronizers-simple-alpha-beta-gamma"><a href="#Synchronizers-simple-alpha-beta-gamma" class="headerlink" title="Synchronizers: simple, $\alpha$, $\beta$, $\gamma$"></a>Synchronizers: simple, $\alpha$, $\beta$, $\gamma$</h3><ul>
<li><p>同步器</p>
<ul>
<li>一类转换算法，允许为同步系统设计的同步程序在异步系统运行</li>
<li>假设系统无故障，从头开始设计定制的异步算法可能比使用同步器更高效</li>
</ul>
</li>
<li><p>进程安全性</p>
<ul>
<li>如果进程i发送的所有消息都已被接收，则进程i在第r轮迭代是安全的，</li>
<li>实现的关键点是向每个进程发出信号，告知何时可以进入下一轮(即当所有要接收消息都已到达时，可以进入下一轮)</li>
</ul>
</li>
<li>公式<ul>
<li>$M<em>a=M_s + M</em>{init} + rounds * M_{round})$(所有的消息)<ul>
<li>$M_s$: 同步算法中的消息数量</li>
<li>$M_{init}$: 初始化异步系统所需的顺序消息数量</li>
<li>$rounds$: 同步算法的迭代轮数</li>
<li>$M_{round}$: 一次迭代中需要执行的消息数量</li>
</ul>
</li>
<li>$T<em>a = T_S + T</em>{init} + rounds * T_{round}$(所有的时间)<ul>
<li>$T_s$: 同步算法的时间，假设每轮只发送一个单位消息，则该值为轮数</li>
<li>$T_init$: 初始化异步系统所需的时间(顺序消息跳数)</li>
<li>$rounds$: 迭代次数</li>
<li>$T_round$: 一次迭代的耗时(顺序消息跳数)</li>
</ul>
</li>
</ul>
</li>
<li><p>复杂度<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Synchronizers%20Complexity.png" alt="img"></p>
</li>
<li><p>Simple Synchronizer</p>
<ul>
<li>每个进程每轮向每个邻居发送一条消息(合并消息或发送虚拟消息)</li>
<li>在接收到每个邻居的消息后，节点进入下一轮</li>
<li>邻居$P<em>i, P_j$之间可能仅相差一轮，因此$P_i$在轮次$round_i$只能接收来自$round_i$或$round</em>{i+1}$的消息</li>
<li>初始化<ul>
<li>任何进程都可以开始轮次</li>
<li>在直径(d个时间单位)内，所有进程都会处于该轮次</li>
<li>$T<em>{init} = d, M</em>{init} = 0$</li>
</ul>
</li>
<li>复杂度<ul>
<li>$M<em>{round}=2|L|, T</em>{round}=1$</li>
</ul>
</li>
</ul>
</li>
<li><p>$\alpha$ Synchronizer</p>
<ul>
<li>$P_i$从轮次$r$中移动到$r+1$，当且仅当所有邻居在轮次$r$中都是安全的。</li>
<li>当邻居$P_j$接收到它发出的每个消息的ack后，它会告知$P_i$以及其他邻居它$P_j$是安全的</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/alpha%20synchronizer.png" alt="img"></p>
<ul>
<li>复杂度<ul>
<li>每条信息都有ack，对于传输层来说，ack可能是自带的，因为建立连接就有握手</li>
<li>每次迭代$2|L|$条消息以通知邻居自己是安全的:<ul>
<li>$M_{round} = O(|L|)$</li>
<li>$T_{round} = O(1)$</li>
</ul>
</li>
<li>无需初始化，每个进程都可以自发地唤醒并开始执行</li>
<li>$\beta$ Synchronizer</li>
</ul>
</li>
<li>初始化<ul>
<li>有根的生成树进行初始化</li>
<li>消息数量为$O(n*logn+|L|)$</li>
<li>时间复杂度$O(n)$</li>
</ul>
</li>
<li>操作<ul>
<li>安全节点发起汇聚传播(<code>CvgC</code>)</li>
<li>中间节点在其子树安全时传播<code>CvgC</code></li>
<li>当根节点变得安全并从所有子节点接收<code>CvgC</code>后，发起树广播通知所有节点进入下一轮</li>
</ul>
</li>
<li>复杂度<ul>
<li>确认消息是免费的，理由同上</li>
<li>每轮迭代消息数量: $M_{round} = 2(n-1)$</li>
<li>每轮迭代时间复杂度:<ul>
<li>平均: $T_{round} = 2 logn $</li>
<li>最坏: $T_{round} = 2n$</li>
</ul>
</li>
<li>$\gamma$ Synchronizer</li>
</ul>
</li>
<li>集群集合: 每个集群有一个生成树</li>
<li>集群内: $\beta$同步器沿着生成树的边传播</li>
<li>集群间: 集群稳定后，$\alpha$同步器沿着指定的集群间边传播(对于两个相邻的集群之间有1条集群边)<ul>
<li>为了传达集群间α同步器的稳定状态，在集群内部通过树进行CvgC汇聚传播(叶节点发起)和BC广播。</li>
</ul>
</li>
<li>复杂度<ul>
<li>每轮的消息数量$M_{round}=O(L_c)$, $L_c$是集群中的链接数</li>
<li>每轮的时间复杂度$T_{round}=O(h_c)$, $h_c$是集群中的树的高度</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/gamma%20synchronizer.png" alt="img"></p>
<h3 id="MIS-async-randomized"><a href="#MIS-async-randomized" class="headerlink" title="MIS, async, randomized"></a>MIS, async, randomized</h3><ul>
<li>MIS异步随机算法(最大独立集, Maximal Independent Set)<ul>
<li>对于一个图$(N, L)$，节点集合$N’\subset N$，是一个独立集，如果对于$N’$中的每个节点i和j，它们之间不存在边</li>
<li>一个独立集是最大独立集当且仅当不存在严格超集是独立集(即不可能比它大的独立集)。</li>
<li>一个图可能有多个最大独立集，大小可能不同</li>
<li>是个NP完全问题，可用于无线广播的频带分配(互斥的)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Maximal%20Independent%20Set%20Example.png" alt="img"></p>
<ul>
<li>Luby’s 异步随机算法<ul>
<li>流程<ul>
<li>节点随机选择自己的数字并与邻居交换</li>
<li>邻域中最小的数字获胜选入最大独立集</li>
<li>如果邻居被选中，则自己要被淘汰</li>
<li>只有被选中节点的邻居会被淘汰</li>
</ul>
</li>
<li>复杂度<ul>
<li>在每次迭代中，至少有一个节点被选中，至少有一个节点被淘汰，因此最多需要$\leq \frac{n}{2}$次迭代。</li>
<li>由于算法具有随机性质，预期迭代次数为$O(logn)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Luby%20Maximal%20Independent%20Set%20Code.png" alt="img"></p>
<h3 id="CDS"><a href="#CDS" class="headerlink" title="CDS"></a>CDS</h3><ul>
<li>支配集: 图$(N, L)$的一个支配集$N’\subset N$，使得每个不在$N’$中的节点都与$N’$中的某个节点有边相连</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Compact%20Routing%20Tables.png" alt="img"></p>
<ul>
<li>连通支配集(Connected Dominating Set)<ul>
<li>图$(N, L)$的一个支配集$N’$，使得由$N’$中的节点诱导的子图是连通的</li>
<li>属于NP完全问题<ul>
<li>寻找最小的连通支配集</li>
<li>判断是否存在大小为$k\lt |N|$的支配集</li>
</ul>
</li>
</ul>
</li>
<li>多项式时间启发式算法:<ul>
<li>使用近似因子和拉伸因子进行度量</li>
<li>创建生成树(ST)，然后删除叶子节点的边</li>
<li>创建最大独立集，然后添加边创建连通支配集</li>
</ul>
</li>
<li>应用<ul>
<li>广播的骨干，用于网络中的高效数据传输</li>
</ul>
</li>
</ul>
<h3 id="Compact-routing-tables"><a href="#Compact-routing-tables" class="headerlink" title="Compact routing tables"></a>Compact routing tables</h3><ul>
<li>紧凑路由表<ul>
<li>要避免大小为n的表格(大尺寸的路由表会导致更多的处理时间。)   - 层次路由: 层次化的集群网络，IPV4。使用层次路由来减少路由表的大小。</li>
<li>树标签方案     - 用于路由的逻辑树拓扑     - 节点标签表示可以通过连续地址标记的链路到达的目的地。<ul>
<li>这种方法可以生成较小的路由表，但可能会导致流量不平衡。</li>
</ul>
</li>
</ul>
</li>
<li>区间路由<ul>
<li>节点标签$B$对$N$是一比一映射</li>
<li>边标签: I标记L中的每一条边，使用$B(N)$的某个子集作为节点标签<ul>
<li>所有的目的地都会被覆盖($\bigcup_{y\in Neighbors}I(x, y)\cup B(x)=N$)</li>
<li>没有覆盖重复$(I(x, w)\cap I(x, y)=\empty)$对于$w, y\in Neighbors$</li>
</ul>
</li>
<li>对于任何$s, t$，存在一条路径$<s=x_0, x_1, ..., x_{k-1}, x_k = t>$，其中$B(t)\in I(x_{i-1}, x_i)$对于每个$i\in [1, k]$</li>
<li>区间标签适用于所有图</li>
<li>路径长度没有保证，对拓扑变化不鲁棒</li>
</ul>
</li>
<li>前缀路由<ul>
<li>节点、通道标签来自同一域，视为字符串。</li>
<li>路由：使用标签为目的地最长前缀的通道。</li>
</ul>
</li>
<li>伸缩因子$r$<ul>
<li>$max<em>{i, j\in N}{\frac{distance_r(i, j)}{distance</em>{opt}(i, j)}}$<ul>
<li>定义为所有节点对$i, j$中的最大值，$distance<em>r(i, j)$是使用路由方案r从节点i到节点j的距离，而$distance</em>{opt}(i, j)$是最佳路径的距离</li>
</ul>
</li>
<li>设计紧凑的路由方案<ul>
<li>这是一个涉及丰富图算法的问题。</li>
<li>需要识别并证明路由效率的界限。</li>
<li>不同的专用拓扑结构(例如，网格、环、树)可以提供更容易的结果范围。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Leader-election-LCR-algorithm"><a href="#Leader-election-LCR-algorithm" class="headerlink" title="Leader election: LCR algorithm"></a>Leader election: LCR algorithm</h3><ul>
<li>领导者选举<ul>
<li>所有进程就一个共同的进程(领导者)达成一致</li>
<li>分布式算法不完全对称: 需要一个启动者和结束进程；例如，最小生成树MST用于BC和CvgC来计算全局函数。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Leader%20Election.png" alt="img"></p>
<ul>
<li>LeLang Chang Roberts (LCR) 算法<ul>
<li>异步单向环</li>
<li>所有进程具有唯一的ID</li>
<li>进程循环它们的ID，最大的ID获胜</li>
<li>尽管有明显的优化，但<ul>
<li>消息复杂度: $\frac{n(n-1)}{2}$</li>
<li>时间复杂度: $O(n)$</li>
</ul>
</li>
</ul>
</li>
<li>不存在匿名环上的确定性领导者选举算法</li>
<li>算法可能是统一的，即适用于所有节点。</li>
<li>Hirschberg-Sinclair Algorithm<ul>
<li>双向二分搜索: 基于令牌的环形搜索</li>
<li>每轮迭代k时，每个活跃的进程执行以下操作<ul>
<li>令牌传递给两侧的$2^k$个邻居</li>
<li>进程$P_i$在第k轮后成为领导者，当且仅当i时两侧$2^k$个邻居中具有最高ID的进程<ul>
<li>在第k轮后，任何一对领导者之间的距离至少为$2^k$</li>
<li>领导者的数量随着$\frac{n}{2^k}$按对数级减少</li>
</ul>
</li>
<li>只有获胜的领导者才能进入下一轮迭代</li>
</ul>
</li>
<li>复杂度<ul>
<li>每轮最多发送n条消息，类似于LCR的抑制机制。共$logn$轮</li>
<li>消息复杂度: $O(n*logn)$</li>
<li>时间复杂度: $O(n)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dynamic-object-replication"><a href="#Dynamic-object-replication" class="headerlink" title="Dynamic object replication"></a>Dynamic object replication</h3><ul>
<li><p>对象复制问题</p>
<ul>
<li>加权图: $(N, L)$，其中k个用户位于$N_k\subset N$节点，r个对象副本位于$N_r\subset N$</li>
<li>如果$k\gt r$并且访问是只读的，副本的最佳放置是最小化从用户到最近副本的距离总和($min(\sum<em>{i\in N_k, r_i\in N_r}dist</em>{i, r<em>i})$，其中的$dist</em>{i, r_i}$为节点到最近副本的成本)</li>
<li>如果来自每个用户$N_k$的读取访问具有一定的频率(权重)，则最小化函数发生变化</li>
<li>需要考虑每条边的带宽限制</li>
<li>假设用户访问是读取的概率为x，更新的概率为1-x。更新需要所有副本都进行更新</li>
</ul>
</li>
<li><p>动态对象复制: 自适应数据复制</p>
<ul>
<li>网络$(V, E)$，$V$是点集，$E$是边集</li>
<li>复制方案: V的子集R，其中每个节点在R中都有一个副本</li>
<li>$r_i, w_i$: 节点i发出的读取和写入速率</li>
<li>$c_r(i), c_w(i)$: 节点i发出的读取和写入成本</li>
<li>$R$: 所有可能的复制方案集合</li>
<li>目标：最小化复制方案的成本：<ul>
<li>$\min<em>{R’\in R}[\sum</em>{i\in V}r<em>i\cdot c_r(i) + \sum</em>{i\in V}w_i\cdot c_w(i)]$</li>
</ul>
</li>
<li>成本是NP完全问题</li>
<li>假设单个副本可串行化，通过Read-One-Write-All(ROWA)策略实现</li>
</ul>
</li>
<li><p>基于树形覆盖</p>
<ul>
<li>所有通信: 在树形覆盖$T$上设置$R$<ul>
<li>$R$: 类似变形虫的子图，移动到活动的重心<ul>
<li>当读取成本较高时扩展</li>
<li>当写入成本较高时收缩</li>
<li>平衡状态$R$是最优的，一旦读写模式稳定，则在d+1步内收敛</li>
<li>动态活动: 算法在周期中重新执行</li>
</ul>
</li>
</ul>
</li>
<li>读取: 从最近的副本，沿着$T$，使用父指针</li>
<li>写入: 到最近的副本，沿着$T$，然后在$R$中传播，使用$R$的邻居集</li>
<li>实现<ul>
<li>判断是否在$R$中</li>
<li>寻找$R$的邻居</li>
<li>寻找父节点</li>
</ul>
</li>
</ul>
</li>
<li><p>收敛性</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Adaptive%20Data%20Replication%20Convergence.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Adaptive%20Data%20Replication%20Tests.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Adaptive%20Data%20Replication.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Adaptive%20Data%20Replication0.png" alt="img"></p>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与问题的计算复杂度</title>
    <url>/2025/03/10/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2025-03-10-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="算法分析与问题的计算复杂度"><a href="#算法分析与问题的计算复杂度" class="headerlink" title="算法分析与问题的计算复杂度"></a>算法分析与问题的计算复杂度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="解决一个计算问题的过程"><a href="#解决一个计算问题的过程" class="headerlink" title="解决一个计算问题的过程"></a>解决一个计算问题的过程</h3><ul>
<li>是否可计算</li>
<li>是否能行可计算(在有限的复杂度内完成计算)</li>
<li>算法设计与分析</li>
<li>用计算机语言实现算法</li>
<li>软件系统</li>
</ul>
<h3 id="可计算理论"><a href="#可计算理论" class="headerlink" title="可计算理论"></a>可计算理论</h3><ul>
<li>计算模型</li>
<li>可计算问题与不可计算问题</li>
<li>计算模型的等价性——图灵/Church命题</li>
</ul>
<h3 id="计算复杂性理论"><a href="#计算复杂性理论" class="headerlink" title="计算复杂性理论"></a>计算复杂性理论</h3><p>在给定的计算模型下研究问题的复杂性</p>
<ul>
<li>固有复杂性</li>
<li>上界</li>
<li>下界</li>
<li>平均</li>
<li>复杂性问题的分类: P=NP?</li>
<li>抽象复杂性研究</li>
</ul>
<h3 id="算法设计和分析"><a href="#算法设计和分析" class="headerlink" title="算法设计和分析"></a>算法设计和分析</h3><ul>
<li>可计算问题的算法的设计与分析</li>
<li>设计高效算法，分析算法性能，两者交互验证<ul>
<li>设计算法的理论、方法和技术(设计正确高效的算法)</li>
<li>分析算法的理论、方法和技术(判断算法是否足够高效)</li>
</ul>
</li>
</ul>
<h3 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h3><p>算法是一个满足下列条件的计算: </p>
<ul>
<li>输入: 有一个满足给定约束条件的输入</li>
<li>输出: 满足给定约束条件的结果</li>
<li>有穷性/终止性: 有限步内必须终止</li>
<li>可行性: 每一个动作都能够被精确地机械执行<ul>
<li>反例: 将大元素放数组后，小元素放数组前。但是无法精确执行，因为没有确定一个元素是大元素还是小元素的指标</li>
</ul>
</li>
</ul>
<h3 id="计算机问题求解的实例——补丁与bug问题"><a href="#计算机问题求解的实例——补丁与bug问题" class="headerlink" title="计算机问题求解的实例——补丁与bug问题"></a>计算机问题求解的实例——补丁与bug问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>错误就是人们所说的bug。用户在试用软件时总是希望其错误越少越好，最好是没有错误的。但是推出一个没有错误的软件几乎不可能，所以很多软件公司都在疯狂地发放补丁(有时这种补丁甚至是收费的)。T公司就是其中之一。上个月，T公司推出了一个新的字处理软件，随后发放了一批补丁。最近T公司发现其发放的补丁有致命的问题，那就是一个补丁在排除某些错误的同时，往往会加入另一些错误，此字处理软件中只可能出现n个特定的错误，这n个错误是由软件本身决定的。T公司目前共发放了m个补丁，对于每一个补丁，都有特定的适用环境，某个补丁只有在当前软件中包含某些错误而同时又不不包含另一些错误时才可以使用，如果它被使用，它将修复某些错误而同时加入某些错误。另外，使用每个补丁都要耗一定的时间(即补丁程序的运行时间)。</p>
<p>现在T公司的问题很简单: 其字处理软件的初始版本不幸地包含了全部n个错误，有没有可能通过使用这m个补丁(任意顺序地使用，一个补丁可使用多次)，使此字处理软件成为一个没有错误的软件。如果可能，希望找到总耗时最少的方案。</p>
<h4 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h4><p>T公司的T公司的字处理软件中可能出现的n个错误为集合$B={b<em>1, b_2, ···, b_n}$中的元素，T公司目前共发放了m个补丁，记为；$P={p_1, p_2, ···, p_m}$。对于每一个补丁$P_i$，假设存在错误集合: $B</em>{i+}$，$B<em>{i-}$，当软件包含了$B</em>{i+}$中的所有错误，而没有包含$B<em>{i-}$中的任何错误时，补丁$P_i$才可以被使用，否则不能使用，显然$B</em>{i+}$，$B<em>{i-}$交集为空。补丁$P_i$将修复某些错误而同时加入某些错误，设错误集合$F</em>{i+}$，$F<em>{i-}$使用过补丁$P_i$之后，$F</em>{i-}$中的任何错误都不会在软件中出现，而软件将包含$F<em>{i+}$中的所有错误，同样$F</em>{i+}$，$F_{i-}$交集为空。另外，使用每个补丁都要耗一定的时间$T_i$。</p>
<p>现在T公司的字处理软件的初始版本不幸地包含了全部n个错误，试编写程序判断有没有可能通过使用这m个补丁(任意顺序地使用，一个补丁可使用多次)，使此字处理软件成为一个没有错误的软件。如果可能，希望找到总耗时最少的方案。</p>
<h4 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h4><p>把n个bug的状态(存在和不存在)的组合用一个0-1字符串(模式串)表示，执行一个补丁本质上就是模式串的转换。<br>模式串可以作为一个图的定点，那么补丁就是图中的边。于是问题则转换为从全1模式串${1, 1, …, 1}$到全0模式串${0, 0, …, 0}$的转换。</p>
<p><img src="" alt="img"></p>
<h4 id="设计最短路径算法"><a href="#设计最短路径算法" class="headerlink" title="设计最短路径算法"></a>设计最短路径算法</h4><ul>
<li>Dijkstra最短路径算法求解</li>
</ul>
<h2 id="寻找最优算法的途径"><a href="#寻找最优算法的途径" class="headerlink" title="寻找最优算法的途径"></a>寻找最优算法的途径</h2><ul>
<li>设计算法A，求$W(n)$，得到算法类最坏情况下时间复杂度的一个上界</li>
<li>寻找函数$F(n)$，使得对任何算法都存在一个规模为n的输入，并且该算法在这个输入下至少要做$F(n)$次基本运算，得到该算法类最坏情况下时间复杂度的一个下界<ul>
<li>给定问题和基本运算后就能确定一个算法类</li>
</ul>
</li>
<li>如果$W(n)=F(n)$或$W(n)=\Theta(F(n))$，则A是最优的，下界是紧的</li>
<li>如果$W(n)\gt F(n)$，A不是最优的或者$F(n)$的下界过低。需要: <ul>
<li>改进原算法A或设计新的算法A’，使得$W’(n)\lt W(n)$</li>
<li>重新证明新下界$F’(n)$，使得$F’(n)\gt F(n)$</li>
<li>重复以上两个步骤，直到最终得到$W’(n)=F’(n)$或者$W’(n)=\Theta(F’(n))$</li>
</ul>
</li>
</ul>
<h3 id="平凡下界"><a href="#平凡下界" class="headerlink" title="平凡下界"></a>平凡下界</h3><ul>
<li>算法的输入规模和输出规模是其平凡下界<ul>
<li>n阶置换: 求解的时间复杂度下界为$\Omega(n!)$</li>
<li>求n次实系数多项式在给定x时的值: 求解的时间复杂度下界为$\Omega(n)$</li>
<li>两个n阶矩阵的乘积: 求解的时间复杂度下界为$\Omega(n^2)$</li>
<li>货郎问题: 求解的时间复杂度下界为$\Omega(n^2)$</li>
</ul>
</li>
</ul>
<h3 id="以找最大问题为例"><a href="#以找最大问题为例" class="headerlink" title="以找最大问题为例"></a>以找最大问题为例</h3><ul>
<li>获得某基本运算的算法类的上界<ul>
<li>以比较作为基本运算的算法类的上界为: n-1</li>
</ul>
</li>
<li>所设计算法的复杂度<ul>
<li>在n个数的数组中找最大的数，以比较做基本运算的算法类中的任何算法在最坏情况下至少要做n-1次比较<ul>
<li>因为最大的数是唯一的，其他n-1个数必须在比较后被淘汰，一次比较至多淘汰一个数，所以至少需要n-1次比较</li>
</ul>
</li>
<li>下界为: n-1</li>
</ul>
</li>
<li>于是所设计的算法便是最优算法</li>
</ul>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h2 id="检索算法的时间复杂度分析"><a href="#检索算法的时间复杂度分析" class="headerlink" title="检索算法的时间复杂度分析"></a>检索算法的时间复杂度分析</h2><h2 id="排序算法的时间复杂度分析"><a href="#排序算法的时间复杂度分析" class="headerlink" title="排序算法的时间复杂度分析"></a>排序算法的时间复杂度分析</h2>]]></content>
      <categories>
        <category>高级算法设计</category>
      </categories>
      <tags>
        <tag>高级算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2024/09/11/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-09-11-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="量化设计与分析基础"><a href="#量化设计与分析基础" class="headerlink" title="量化设计与分析基础"></a>量化设计与分析基础</h2><h3 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h3><h4 id="The-development-of-computer-technology"><a href="#The-development-of-computer-technology" class="headerlink" title="The development of computer technology"></a>The development of computer technology</h4><ul>
<li>Rapid Improvement comes from advances in two aspects<ul>
<li>Semiconductor technology used to build computers<ul>
<li>integrated circuit集成电路</li>
<li>microprocessor微处理器</li>
</ul>
</li>
<li>Innovations in architecture<ul>
<li>high level language like C, Python… reduced the need for object-code compatibility(not assembly language)</li>
<li>the creation of standardized, vendor-independent OS(UNIX, Linux)<ul>
<li>lowered the cost and risk of bringing out a new architecture(现行框架魔改开发，不需要从零开始，从而降低了成本和风险)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="The-achievements-of-computer-technology-development"><a href="#The-achievements-of-computer-technology-development" class="headerlink" title="The achievements of computer technology development"></a>The achievements of computer technology development</h4><ul>
<li>made it possible to develop a new set of architectures with simpler instructions(指令简单化)<ul>
<li>RISC：Reduced Instruction Set Computer, focused on two critical performance techniques<ul>
<li>the exploitation of instruction-level parallelism(指令级并行)<ul>
<li>pipelining</li>
</ul>
</li>
<li>the use of caches</li>
</ul>
</li>
<li>RISC-based dominant central processing unit: ARM</li>
</ul>
</li>
</ul>
<h4 id="Effects-of-Dramatic-Grouwth-computer-technology-development"><a href="#Effects-of-Dramatic-Grouwth-computer-technology-development" class="headerlink" title="Effects of Dramatic Grouwth(computer technology development)"></a>Effects of Dramatic Grouwth(computer technology development)</h4><ul>
<li>Enhanced the capability available to computer users, having even better performance than supercomputer of 20 years earlier</li>
<li>Improvement in cost-performance led to new classes of computers(PC, smartphones. tablets)</li>
<li>Improvement of semiconductor manufacturing led to the dominace of microprocessor-based computers(微处理器电脑, Minicomputers， even servers using microprocessors)</li>
<li>Allowed modern programmers to trade performance for productivity(以性能换生产力？也就是高效实现代码，不管性能如何。因为如今性能好，可以随便浪费)<ul>
<li>C/C++ -&gt; Java, JS, Scala, Python</li>
<li>Software deployment(Software as a Service, SaaS)</li>
</ul>
</li>
<li>The nature of applications<ul>
<li>Speech, sound, image, video</li>
</ul>
</li>
</ul>
<h4 id="History-of-Single-Processor-Performance"><a href="#History-of-Single-Processor-Performance" class="headerlink" title="History of Single Processor Performance"></a>History of Single Processor Performance</h4><ul>
<li>1986-2003, the increase in growth to about 52% because of advanced architectural and organizational ideas</li>
<li>2003-2011, the increase slowed to 23% per year, because of the limits of power and the available ILP(能耗限制和指令并行的问题)</li>
<li>2011-2015， the annual improvement was less than 12%, due to the limits of parallelism of Amdahl’s Law</li>
<li>2015- now, with the end of Moore’s Law, improvement has been just 3.5% per year</li>
</ul>
<h4 id="Dennard-Scaling-Law"><a href="#Dennard-Scaling-Law" class="headerlink" title="Dennard Scaling Law"></a>Dennard Scaling Law</h4><ul>
<li>Robert Dennard</li>
<li>power density was constant for a given area of silicon(给定面积的硅，其功率密度是恒定的)<ul>
<li>As transistors get smaller, power density stays constant, so that the power use stays in proportion with area(功耗和面积成正比)</li>
<li>Even as increased the number of transistors because of smaller dimensions of each transistor</li>
<li>在该设想中由于能耗只与面积相关，所以即使缩小了晶体管大小，其功率密度也是不变的。那么在单位面积内，晶体管无论型号大小，数量多少，只要塞满了面积，那么能耗就是相同的。也就是说，随着晶体管密度增加，每个晶体管能耗会降低。而每个单位面积晶体管计算能力会随着技术迭代增强，而能耗并没有发生变化，那么计算机相当于变得更加节能了，即相同性能的情况下，面积更小的晶体管就能达到，则能耗更低。</li>
</ul>
</li>
<li>Ended by 2004<ul>
<li>current and voltage couldn’t keep dropping and still maintain the dependability of integrated circuit(因为晶体管不断变小，确实理论上是会使能耗降低，而降低的方式便是更低的电流和电压，但是当电流电压低到一定程度的时候，便不能保证集成电路的可靠性)</li>
<li>另一主要原因是在芯片尺寸不变，晶体管数量变多的情况下，电流泄漏会带来更大的挑战，也会导致芯片升温，从而造成热失控的威胁，从而进一步增加能源成本。</li>
<li>因此单个芯片(uniprocessors)上去卷性能是有极限的，需要往多处理器或多核的方向上去发展<ul>
<li>multiple processors or cores</li>
<li>增加内核数量有利于提高(虽然并非完全)工作负载，但是由于拥有多个核心而增加的活动开关元件仍然会导致整体功耗增加，从而加剧CPU功耗问题。</li>
<li>最终的结果是，在不违反功率约束的情况下，一个集成电路中只有一小部分能够在一定时间处于实际有效状态，其余的(不活跃的)区域称为暗硅。</li>
<li>多核并不能解决由登纳德缩放定律终结带来的能效计算挑战。每个活跃的核都会消耗能量，无论其对计算是否具有有效贡献。一个主要的障碍可以用阿姆达尔定律（Amdahl’s Law）表述。</li>
</ul>
</li>
<li>ILP to DLP, TLP, RLP<ul>
<li>ILP: 指令级并行，编译器和硬件，属于隐式并行(implicitly parallel)，不依赖人工调控</li>
<li>DLP：数据级并行，显示并行(explicitly parallel)，需要人工重构应用</li>
<li>TLP：线程级并行，显示并行(explicitly parallel)，需要人工重构应用</li>
<li>RLP：请求级并行，显示并行(explicitly parallel)，需要人工重构应用</li>
</ul>
</li>
</ul>
</li>
<li>ILP: Instruction-level parallelism<ul>
<li>exploits data-level parallelism at modest levels with compiler help using ideas like pipelining and at medium levels using ideas like speculative execution(利用编译器优化，例如流水线)</li>
</ul>
</li>
<li>DLP: Data-level parallelism<ul>
<li>many data items that can be operated on at the same time<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/DLP.png" alt="img"></li>
</ul>
</li>
<li>TLP: Task-level parallelism<ul>
<li>tasks of work are created that can operate independently and largely in parallel<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/TLP.png" alt="img"></li>
</ul>
</li>
<li>RLP: Request-level parallelism<ul>
<li>exploits parallelism among largely decoupled tasks specified by the programmer or the operating system(程序员和操作系统指定解耦任务)</li>
</ul>
</li>
</ul>
<h4 id="Moore-Law"><a href="#Moore-Law" class="headerlink" title="Moore Law"></a>Moore Law</h4><ul>
<li>晶体管数量每18-24个月翻倍，而其成本减少一半(注意：不仅要翻倍数量，还要让成本减少一半，两者必须都成立，否则就摩尔定律就失效了)</li>
<li>逐渐失效：<ul>
<li>晶体管的数量增长已经开始减缓，成本下降速度也开始减缓<ul>
<li>因为要实现更小(数量)、更快、更便宜(成本)的芯片难度很大</li>
</ul>
</li>
</ul>
</li>
<li>存在极限：<ul>
<li>物理极限<ul>
<li>硅材料本身，当晶体管达到一定大小阈值时，电子将出现隧穿效应，电路稳定性受到影响</li>
</ul>
</li>
<li>成本效益<ul>
<li>晶体管数量增加，芯片成本也增加</li>
<li>更小的晶体管要更复杂的制造工艺</li>
</ul>
</li>
<li>散热问题(和Dennard Scaling Law相同的问题)<ul>
<li>高密度晶体管会使热量积聚导致芯片性能下降</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Performance-Slow-down-性能进步减缓"><a href="#Performance-Slow-down-性能进步减缓" class="headerlink" title="Performance Slow-down(性能进步减缓)"></a>Performance Slow-down(性能进步减缓)</h4><ul>
<li><p>Reasons</p>
<ul>
<li>transistors no longer getting much better(半导体极限，前面两个定律的内容)</li>
<li>the unchanging power budgets for microprocessors(分给微处理器的能耗预算没变化，也就是我们总是希望用更低的能耗获得更好的性能)</li>
<li>the replacement of the single power-hungry processor with several energy efficient processors(用更高效利用能耗的多处理器替代单处理器)</li>
<li>the limits to multiprocessing to achieve Amdahl’s Law(Amdahl理论说明多处理器也是有极限的，因为不是所有的处理器都参与进了活动)</li>
</ul>
</li>
<li><p>The only path to improve energy-performance-cost is specialization</p>
<ul>
<li>专业化，特别化，定制化。而非通用CPU</li>
<li>domain-specific cores which perform only one class of computations well, but do so remarkly better than general-purpose cores</li>
</ul>
</li>
</ul>
<h3 id="Defining-Computer-Architecture"><a href="#Defining-Computer-Architecture" class="headerlink" title="Defining Computer Architecture"></a>Defining Computer Architecture</h3><h4 id="Old-view"><a href="#Old-view" class="headerlink" title="Old view"></a>Old view</h4><ul>
<li><p>only Instruction Set Architecture(ISA) design</p>
<ul>
<li>programmer-visible instruction set</li>
<li>the boundary between the software and hardware</li>
<li>ISA also need to define items in the computer that are available to a program(not only instruction)<ul>
<li>like: data type(数据类型), registers(寄存器), addressing modes(编址), memory(内存)</li>
</ul>
</li>
</ul>
</li>
<li><p>ISA example: RISC-V, a modern RISC instruction set</p>
<ul>
<li>free, open, elegant, popular(more than 60 companies)</li>
<li>ideas<ul>
<li>a large set of registers</li>
<li>easy-to-pipeline instructions</li>
<li>a lean(精简的) set of operations</li>
</ul>
</li>
<li>nearly all ISAs today are classified as general-purpose register architectures(几乎所有都属于通用目的的寄存器架构？)<ul>
<li>操作的要不是寄存器就是内存空间</li>
<li>Two popular versions of class<ul>
<li>register-memory ISAs, x86<ul>
<li>相当一部分的指令都能访问内存</li>
</ul>
</li>
<li>load-store ISAs, ARMv8, RISC-V，1985年以来发布的ISAs都是这种版本<ul>
<li>只有load和store指令能够访问内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Memory Addressing(内存分配)<ul>
<li>byte addressing to access memory operands(All: 80x86, ARMv8, RISC-V)</li>
<li>Some architectures require that objects must be aligned(对齐), so that accesses are generally faster<ul>
<li>if $A\quad mod\quad s = 0$, an object of size s bytes at byte address A is aligned</li>
<li>ARMv8 require alignment, 80x86 and RISC-V do not require alignment</li>
</ul>
</li>
</ul>
</li>
<li>Addressing Modes<ul>
<li>specify the address of a memory object(指定内存对象的地址)</li>
<li>RISC-V addressing modes<ul>
<li>Register：寄存器</li>
<li>Immediate：立即数</li>
<li>Displacement：替换，例如间接寻址(寄存器+立即数得到内存地址)</li>
</ul>
</li>
</ul>
</li>
<li>Types and sizes of operands(操作数的大小和类型)<ul>
<li>x86，ARMv8，RISC-V都支持不同的操作数类型<ul>
<li>8-bit(ASCII character)</li>
<li>16-bit(Unicode character or half word)</li>
<li>32-bit(integer or word)</li>
<li>64-bit(double word or long integer)</li>
<li>IEEE 754 floating point in 32-bit(single precision，单精度) and 64-bit(double precision，双精度)</li>
</ul>
</li>
</ul>
</li>
<li>Operations<ul>
<li>general categories<ul>
<li>data transfer</li>
<li>arithmetic logical</li>
<li>control</li>
<li>floating point</li>
</ul>
</li>
</ul>
</li>
<li>Control flow instructions<ul>
<li>virtually all support<ul>
<li>conditional branches(条件分支)</li>
<li>unconditional jumps(无条件跳转)</li>
<li>procedure calls(进程调度)</li>
<li>returns(返回)</li>
</ul>
</li>
</ul>
</li>
<li>Encoding an ISA(指令编码方式，定长和变长)<ul>
<li>two basic choices<ul>
<li>fixed length<ul>
<li>ARMv8和RISC-V指令都是32bits长度</li>
<li>简化了指令的解码</li>
</ul>
</li>
<li>variable length<ul>
<li>80x86编码的指令是1-18bytes</li>
<li>占用更少的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>This view is incorrect</p>
</li>
</ul>
<h4 id="Real-Computer-Architecture"><a href="#Real-Computer-Architecture" class="headerlink" title="Real Computer Architecture"></a>Real Computer Architecture</h4><ul>
<li>Designing the organization and hardware to meet goals and functional requirements(设计组织和硬件去达到目标和功能性的需求)<ul>
<li>Include ISA, microarchitecture(微架构), hardware(硬件)</li>
<li>Concerned with balancing the performance, efficiency, cost, and reliability of a computer system(考虑计算机系统的性能、效率、成本和可靠性的平衡)<ul>
<li>For example, longer and more complex instruction take longer for the processor to decode and can be more costly to implement effectively</li>
</ul>
</li>
</ul>
</li>
<li>organization and hardware are the two components of implementation of a computer<ul>
<li>Organization includes the high-level aspects of a computer’s design(组织是计算机设计的高级部分)<ul>
<li>memory system, memory interconnect(内存互联), the design of the internal processor(内部处理器) or CPU(中央处理器)</li>
<li>又称为Microarchitecture<ul>
<li>Describe how a particular processor will implement the ISA(特定的处理器怎么实现指令集)</li>
<li>AMD Opteron and Intel Core i7 are two processors with the same ISA but different organizations</li>
</ul>
</li>
<li>Both processors implement the 80x86 instruction set(因为要支持Windows操作系统？)<ul>
<li>but have very different pipeline and cache organizations(不同的流水线和缓存组织)</li>
</ul>
</li>
</ul>
</li>
<li>Hardware refers to the specifics of a computer(指定了计算机的细节)<ul>
<li>including detailed logic design(逻辑设计) and packaging technology(封装技术) of the computer</li>
<li>Often a line of computers contains computers with identical ISA and very similar organizations, but they differ in the detailed hardware implementation(有相同ISA、相似组织的PC，但是在硬件实现上并不相同)</li>
<li>例如Intel Core i7和Intel Xeon E7<ul>
<li>几乎相同，但时间频率(clock rates)不同，内存系统(memmory systems)也不同</li>
<li>Xeon E7对于服务器的计算机更加有效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Trends-in-Technology"><a href="#Trends-in-Technology" class="headerlink" title="Trends in Technology"></a>Trends in Technology</h3><h4 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h4><ul>
<li>Integrated circuit technology(Moore’s Law is no more)<ul>
<li>集成电路技术，摩尔定律逐渐失效</li>
<li>Transistor density(晶体管密度)：35% per year</li>
<li>Die Size(芯片大小)：10-20% per year<ul>
<li>在半导体中，’die’是指从‌硅晶圆上切割下来的未封装的半导体芯片‌。它包含了完整的电路，但尚未进行封装处理。</li>
</ul>
</li>
<li>Integration overall(整体集成度)：40-55% per year</li>
</ul>
</li>
<li>DRAM capacity(DRAM能力)：25-40% per year(slowing, 正在减缓)<ul>
<li>8Gb(2014)</li>
<li>16Gb(2019)</li>
<li>32Gb(Now)</li>
</ul>
</li>
<li>Flash capacity<ul>
<li>Flash更加便宜<ul>
<li>8-10X cheaper/bit than DRAM</li>
</ul>
</li>
</ul>
</li>
<li>Magnetic disk capacity(磁盘，磁性硬盘)，recently slowed to 5% per year<ul>
<li>Density increases may no longer be possible(密度已经几乎到极限了), maybe increase from 7 to 9 platters</li>
<li>硬盘又更便宜，但肯定更慢<ul>
<li>8-10X cheaper/bit than Flash</li>
<li>200-300X cheaper/bit than DRAM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Bandwidth-and-Latency"><a href="#Bandwidth-and-Latency" class="headerlink" title="Bandwidth and Latency"></a>Bandwidth and Latency</h4><ul>
<li><p>Bandwidth(throughput，吞吐量)</p>
<ul>
<li>Total amount of work done in a given time(规定时间内的工作量)</li>
<li>32000-40000X improvement for processors(处理器性能占主导地位)</li>
<li>300-1200X improvement for memory and disks(内存和磁盘部分影响)</li>
</ul>
</li>
<li><p>Latency(or response time，响应时间)</p>
<ul>
<li>Time between start and completion of an event</li>
<li>50-90X improvement for processors(依然是处理器性能占主导地位)</li>
<li>6-8X improvement for memory and disks(内存和磁盘部分影响)</li>
</ul>
</li>
<li><p>Microprocessor和Networks对带宽和延时的提升都是较均匀的</p>
</li>
<li>Memory的对带宽的影响更加显著</li>
<li>Disk对延时的影响有限</li>
</ul>
<h4 id="Transistor-and-Integrated-circuits"><a href="#Transistor-and-Integrated-circuits" class="headerlink" title="Transistor and Integrated circuits"></a>Transistor and Integrated circuits</h4><ul>
<li><p>Scaling of Transistor Performance and Wires(晶体管性能和导线布线的关系？)</p>
<ul>
<li>集成电路工艺的特点就是特征大小(feature size)<ul>
<li>Feature size is the minimum size of a transistor or a wire in either the x or y dimension(特征大小是某个维度上晶体管或导线的最小规模)<ul>
<li>decreased from 10 um in 1971 to 0.016 um in 2017</li>
</ul>
</li>
</ul>
</li>
<li>The density of transistors increases quadratically with a linear decrease in feature size(晶体管密度随着特征大小线性减小而二次方增加)</li>
<li>Wire delay does not improve with feature size(导线电路的延迟与特征大小没有太大关系)<ul>
<li>Scales poorly compared to transistor performance(与晶体管性能相比，特征大小对导线的影响没那么大)</li>
<li>become a major design obstacle for large integrated circuits(大型集成电路的巨大设计瓶颈)</li>
</ul>
</li>
<li>Larger and larger fractions of the clock cycle have been consumed by the propagation delay of signals on wires(越来越多的时间周期被消耗在线路上的传播延迟)</li>
<li>But Power now plays an even greater role than wire delay(集成电路的功耗比电路传输的延迟更加重要)</li>
</ul>
</li>
<li><p>Power and Energy</p>
<ul>
<li>A systems perspective, three primary concerns<ul>
<li>what is the maximum power a processor ever requires?(处理器所需的最大功耗)</li>
<li>what is the sustained power consumption?(持续功耗是多少)</li>
<li>energy and energy efficiency(能耗和能耗的效率，供能的设施)</li>
</ul>
</li>
<li>Thermal Design Power(TDP，热设计功率)<ul>
<li>Susbtained power consumption is widely called the thermal design power(TDP)，持续功耗的另一个称呼</li>
<li>actual average power(实际的平均功率) &lt; TDP &lt; peak power(1.5X，峰值功率)</li>
<li>TDP determines the cooling requirement(TDP决定了对冷却系统的需求)</li>
<li>A typical power supply for a system is typically sized to exceed the TDP(系统的典型电源大小通常超过TDP)</li>
<li>a cooling system is usually designed to match or exceed TDP(冷却系统通常要匹配甚至超过TDP的要求)</li>
</ul>
</li>
<li>Power is simply energy per unit time(功率是单位时间的能耗)<ul>
<li>1 watt = 1 joule per second(1瓦特为每秒1焦耳)</li>
</ul>
</li>
<li>The right metric for comparing processors(比较处理器的恰当指标)<ul>
<li>energy is always a better metric<ul>
<li>because it is tied to a specific task and the time required for that task</li>
<li>The energy to complete a workload(完成工作所需的能耗) = the average power(平均功率) * the execution time for the workload(工作的执行时间)</li>
</ul>
</li>
<li>power consumption as a constraint(功耗作为约束) is the primary legitimate use(合法使用用途) for measure</li>
</ul>
</li>
<li>Within a Microprocessor<ul>
<li>For CMOS chips, the primary energy consumption has been in switching transistors, also called dynamic energy(CMOS芯片主要能耗在于开关晶体管)</li>
<li>The energy of pulse of the logic transition of 0-&gt;1-&gt;0, or 1-&gt;0-&gt;1(即一次脉冲的能耗) required per transistor <ul>
<li>$Energy_{dynamic} \propto Capacitive \quad load \times Voltage^2$<ul>
<li>与电容性负载和电压的平方成正比</li>
</ul>
</li>
</ul>
</li>
<li>The energy of a single transition of 0-&gt;1 or 1-&gt;0(不需复位)<ul>
<li>$Energy_{dynamic} \propto 1/2 \times Capacitive \quad load \times Voltage^2$</li>
</ul>
</li>
<li>The power required per transistor = energy of a transition * frequency of transitions(功率需求)<ul>
<li>$Power_{dynamic} \propto 1/2 \times Capacitive \quad load \times Voltage^2 \times Frequency \quad sitched$</li>
</ul>
</li>
<li>Dynamic power and energy are greatly reduced by lowering the voltage(降低电压能显著减少动态功耗和能耗)</li>
<li>Clock frequency growth should be slow down if we cannot reduce voltage or increase power per chip(如果不能减少电压或提升每个芯片的功率，时钟频率的增长需要减缓)<ul>
<li>减少电压是因为隧穿？还是因为时间频率增加时电压升高会导致更高的能耗？</li>
</ul>
</li>
</ul>
</li>
<li>Reducing Power(减少功率)<ul>
<li>Modern microprocessors offer many techniques to improve energy efficiency(提高能耗效率)：<ul>
<li>Do nothing well<ul>
<li>Turn off the clock of inactive modules to save energy(关闭不活跃的模块的时钟以节省能源，这是关闭模块，因为有的模块在工作，有的不工作)</li>
</ul>
</li>
<li>Dynamic voltage-frequency scaling (DVFS)<ul>
<li>Offer a few clock frequencies and voltages in which to operate that use lower power and energy(提供一些使用较低功率和能耗的时钟频率和电压进行操作)</li>
<li>The overall server power savings is about 10%-15%</li>
</ul>
</li>
<li>Design for the typical case<ul>
<li>Given that PMDs and laptops are often idle, memory and storage offer low power modes to save energy(鉴于PMD和笔记本电脑经常处于空闲状态，内存和存储提供低功耗模式以节省能源，不关闭模块，只是切换低功耗)</li>
</ul>
</li>
<li>Overclocking(超频)，Turbo mode(加速模式，性能模式)<ul>
<li>the chip decides that it is safe to run at a higher clock rate for a short time until temperature starts to rise(芯片决定是否能够在更高的时钟频率下工作一小段时间直到温度上升)</li>
<li>turn off all cores but one and run it faster(或者可以关掉所有的芯片但只要有一个运行更快些)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Static Power(静态功耗)<ul>
<li>Static power is becoming an important issue, because leakage current(泄漏电流) flows even when a transistor is off(即使晶体管关闭了，依然可能会有电流泄漏)<ul>
<li>$Power<em>{static} \propto Current</em>{static} \times Voltage$，功率和电流电压成正比</li>
</ul>
</li>
<li>Leakage can be as high as 50% for high-performance chips<ul>
<li>large SRAM caches need power to maintain storage values</li>
</ul>
</li>
<li>Power gating(电源门控)<ul>
<li>turning off the power supply to inactive modules in order to control loss because of leakage(关闭不活跃模块的电源，控制泄露造成的能耗损失)</li>
</ul>
</li>
<li>Race-to-halt(竞相暂停)<ul>
<li>the processor operates at full speed during active periods, completing tasks as quickly as possible(处理器在活跃期间全速运行，尽快完成任务)</li>
<li>when there is no immediate work to be done, the processor quickly transitions into a low-power state, effectively halting its activity(没有即时工作需要被运行时，处理器会快速转换到低功耗状态，有效停止其活动)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Energy Cost and Area Cost</p>
<ul>
<li>Dark silicon<ul>
<li>指由于功耗和散热限制(power consumption and heat dissipation limitations)，计算机芯片的某些部分保持不活跃的现象</li>
<li>As transistor density increases, power constraints(功率的约束) restrict the number of active transistors that can operate simultaneously(限制了能够同时活跃的芯片的数量)</li>
<li>certain areas of the chip remain “dark” or powered off at any given moment(特定区域的芯片会在任何给定时间持续保持不活跃状态或者直接关闭)</li>
</ul>
</li>
<li>Energy / area cost of building blocks of a modern computer<ul>
<li>demonstrates the importance of careful uses of caches and memory buffers(谨慎使用缓存)<ul>
<li>A floating-point addition uses 30 times as much energy as an 8-bit integer add(浮点数加法比整数加法能耗高)</li>
<li>A small SRAM is 125 times more energy-efficient than DRAM(小的SRAM比DRAM能耗高)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Shift-in-Computer-Architecture"><a href="#Shift-in-Computer-Architecture" class="headerlink" title="Shift in Computer Architecture"></a>Shift in Computer Architecture</h4><ul>
<li>Domain-specific processors(特定领域的处理器)<ul>
<li>save energy by reducing wide floating-point operations(减少大量浮点数操作节省能耗)</li>
<li>deploying special-purpose memories to reduce accesses to DRAM(减少访问DRAM，动态随机存储器，部署特定目的的内存，DMA?)</li>
<li>provide 10-100 more integer arithmetic units than a traditional processor(提供更多的计算单元，寄存器？)</li>
<li>perform only a limited set of tasks<ul>
<li>but perform faster and more energy efficiently than a general-purpose processor(在自己领域比通用寄存器强)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Trends-in-Cost"><a href="#Trends-in-Cost" class="headerlink" title="Trends in Cost"></a>Trends in Cost</h3><h4 id="Impact-of-Time-Volume-and-Commoditization-时间、容量、商品化"><a href="#Impact-of-Time-Volume-and-Commoditization-时间、容量、商品化" class="headerlink" title="Impact of Time, Volume, and Commoditization(时间、容量、商品化)"></a>Impact of Time, Volume, and Commoditization(时间、容量、商品化)</h4><ul>
<li><p>Time</p>
<ul>
<li>The underlying principle that drives costs down is learning curve<ul>
<li>manufacturing costs decrease over time(加工成本下降), price in close relationship to cost</li>
<li>The learning curve itself is best measured by change in yield(学习曲线通过良率的变化得到)<ul>
<li>yield: the percentage of manufactured devices that survives the testing procedure(良率，加工后的设备能通过测试的比率)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Volume</p>
<ul>
<li>decrease the time needed to get through the learning curve(减少完成学习曲线所需要的时间)</li>
<li>decrease cost because it increases purchasing and manufacturing efficiency(减少成本，因为提升了采购和加工的效率)<ul>
<li>costs decrease about 10% for each doubling of volume(翻倍容量能下降大约10%的成本)</li>
</ul>
</li>
<li>decrease the amount of development costs</li>
</ul>
</li>
<li><p>Competition(竞争)</p>
<ul>
<li>decrease the gap between cost and selling price, but it also decrease cost(缩小了售价和成本的差距，同时也会降低成本)</li>
<li>competition among the suppliers of the components(竞争来自于组件的供应商)</li>
<li>volume efficiencies the suppliers can achieve(供应商可以实现批量效率)</li>
</ul>
</li>
</ul>
<h4 id="Cost-of-an-Integrated-Circuit-集成电路成本"><a href="#Cost-of-an-Integrated-Circuit-集成电路成本" class="headerlink" title="Cost of an Integrated Circuit(集成电路成本)"></a>Cost of an Integrated Circuit(集成电路成本)</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/IC%20Manufacturing%20Process.png" alt="image"></p>
<ul>
<li>$Cost\quad of\quad integrated\quad circuit = (Cost\quad of\quad die + Cost\quad of\quad testing\quad die + Cost\quad of\quad packing\quad and\quad final\quad test) / Final\quad test\quad yield$<ul>
<li>die：芯片</li>
<li>分子部分对应的是已经成功的芯片的花费成本，等号左边集成电路成本是总成本</li>
</ul>
</li>
<li>$Cost\quad of\quad die = Cost\quad of\quad wafer / (Dies\quad per\quad wafer \times Die\quad yield)$</li>
<li>$Dies\quad per\quad wafer = {[\pi \times (Wafer \quad diameter / 2)^2] / (Die\quad area)} - {[\pi \times Wafer \quad diameter] / \sqrt{2 \times Die\quad area}}$<ul>
<li>wafer：薄片</li>
<li>前者是薄片模型除以芯片面积，后者是薄片周长除以晶片对角线长(边缘部分)</li>
</ul>
</li>
<li><p>$Dies\quad yield = Wafer\quad yield \times 1/(1 + Defects\quad per\quad unit\quad area\times Die\quad area)^N$</p>
<ul>
<li>yield：良率</li>
<li>芯片良率为整体薄片良率的部分比率</li>
<li>Defects per unit area：0.016-0.057 defects per square cm(每单位平方厘米面积出现缺陷的可能性，与芯片本身无关，是集成薄片的问题)</li>
<li>N，process-complexity factor(复杂性参数)：11.5-15.5(40nm)</li>
</ul>
</li>
<li><p>A computer designer remember about chip costs:</p>
<ul>
<li>The manufacturing process dictates the wafer cost, wafer yield and defects per unit area(加工过程决定了薄片成本、良率和单位面积缺陷的概率)</li>
<li>the sole control of the designer is die area(设计者只能决定芯片面积)<ul>
<li>by what functions are included on or excluded from the die(哪些功能组件是需要的，哪些是不需要的)</li>
<li>by the number of I/O pins(I/O引脚的数量)</li>
</ul>
</li>
<li>the cost per die grows roughly as the square of the die area(成本大致随着面积的平方而增长)</li>
</ul>
</li>
</ul>
<h3 id="Dependability-可靠性"><a href="#Dependability-可靠性" class="headerlink" title="Dependability(可靠性)"></a>Dependability(可靠性)</h3><ul>
<li><p>Infrastructure providers started offering service level agreements(SLAs)</p>
<ul>
<li>could be used to decide whether the system was up or down(系统运行还是终止?)</li>
<li>Systems alternate between two state of service with respect to an SLA:<ul>
<li>stage 1: Service accomplishment, where the service is delivered as specified(完成态)</li>
<li>stage 2: Service interruption, where the delivered service is different from the SLA(中断态)</li>
<li>Transitions between these two states are caused by <ul>
<li>failures(from state 1 to state 2，出错)</li>
<li>restorations(from state 2 to state 1，修复)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Quantifying these transitions leads to two main measures of dependability(可靠性指标)</p>
<ul>
<li>Module reliability(模块可靠性): a measure of the continuous service accomplishment(or, equivalently, of the time to failure，故障时间，一次故障到下一次故障的时间) from a reference initial instant<ul>
<li>Mean time to failure(MTTF, 平均故障时间)<ul>
<li>a rate of failures</li>
<li>generally reported as failures per billion hours of operation(十亿小时运行过程中的故障数), or FIT(Failure in time)</li>
<li>an MTTF of 1000000 hours equals 1000 FIT(1 MTTF = 1000000 FIT?)</li>
</ul>
</li>
<li>Service interruption is measured as mean time to repair(MTTR)(服务的中断由平均恢复时间衡量)</li>
<li>Mean time between failures(MTBF) is the sum of MTTF + MTTR<ul>
<li>平均故障间隔时间 = 平均故障时间 + 平均恢复时间<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MTBF.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
<li>Module availability(模块可用性): a measure of the service accomplishment with respect to the alternation between the two states of accomplishment and interruption(衡量服务完成情况)<ul>
<li>For non-redundant systems with repair(需要维修的非冗余系统), module availability is<ul>
<li>$Module\quad availability = MTTF / (MTTF + MTTR)$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Model%20availability.png" alt="image"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并行计算与并行计算机"><a href="#并行计算与并行计算机" class="headerlink" title="并行计算与并行计算机"></a>并行计算与并行计算机</h2><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><ul>
<li>通常是指把一个大规模的计算问题划分为若干规模较小的部分，然后可以在多个互连的处理器上同时执行求解的计算模式<ul>
<li>任务级并行(多个任务同时进行)</li>
<li>数据级并行(一个任务接一个任务)</li>
</ul>
</li>
</ul>
<h3 id="并行计算机"><a href="#并行计算机" class="headerlink" title="并行计算机"></a>并行计算机</h3><ul>
<li><p>A parallel computer is a collection of processing elements that can communicate and cooperate to solve a large problem fast(互相通信协作快速解决大型任务的处理元件的集合)</p>
<ul>
<li>collection of processing elements(PEs)<ul>
<li>How many? How powerful each? Scalability(可扩展性)</li>
<li>Few very powerful(Earth Simulator) vs. many small ones(BlueGene)<ul>
<li>用少量性能非常好的</li>
<li>更多更小，但单个性能会更差些</li>
</ul>
</li>
</ul>
</li>
<li>communicate<ul>
<li>shared memory(共享内存) vs msg passing(消息传递)</li>
<li>Interconnection network(互连网络)<ul>
<li>bus(总线)</li>
<li>multistage(级联)</li>
<li>crossbar(交叉开关)</li>
</ul>
</li>
<li>Evaluation criteria(评估标准): <ul>
<li>cost成本</li>
<li>latency延迟</li>
<li>throughput冲突</li>
<li>scalability可扩展</li>
<li>fault tolerance容错</li>
</ul>
</li>
</ul>
</li>
<li>cooperate<ul>
<li>Synchronization<ul>
<li>allow sequencing of operations to ensure correctness(确保一系列操作的正确性)</li>
</ul>
</li>
<li>Granularity up<ul>
<li>parallelism down, communication down, overhead down</li>
</ul>
</li>
<li>Autonomy<ul>
<li>SIMD(单指令多数据流)</li>
<li>MIMD(多指令多数据流)</li>
</ul>
</li>
</ul>
</li>
<li>solve a large problem fast<ul>
<li>general machine</li>
<li>special purpose machine(solve certain problems well)</li>
</ul>
</li>
</ul>
</li>
<li><p>Virtually all stand-alone computers today are parallel from a hardware persperctive(从硬件角度如今的计算机都是并行的)</p>
<ul>
<li>Multiple functional units(各种功能组件L1 cache, L2 cache, branch, prefetch, decode, floating-point, graphics processing(GPU), integer)</li>
<li>Multiple execution units/cores(各种执行组件核心)</li>
<li>Multiple hardware threads(各种硬件总线?)</li>
</ul>
</li>
<li><p>Networks connect multiple stand-alone computers(nodes) to make larger parallel computer clusters(网络可以连接相对独立的计算机作为节点形成更大的并行计算机集群)</p>
</li>
<li><p>并行计算机体系结构涉及问题</p>
<ul>
<li>资源分配<ul>
<li>并行计算机系统多大</li>
<li>处理单元性能如何</li>
<li>购买价格如何</li>
</ul>
</li>
<li>数据存储，通信以及同步<ul>
<li>各处理单元如何协作和通信</li>
<li>数据如何在各个处理单元之间传递</li>
<li>如何实现各个处理单元的同步</li>
</ul>
</li>
<li>性能与规模<ul>
<li>如何将之全部转化为高性能</li>
<li>如何进行评测</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="高性能计算机发展史"><a href="#高性能计算机发展史" class="headerlink" title="高性能计算机发展史"></a>高性能计算机发展史</h2><h3 id="并行计算机与高性能计算机"><a href="#并行计算机与高性能计算机" class="headerlink" title="并行计算机与高性能计算机"></a>并行计算机与高性能计算机</h3><ul>
<li>为了实现高性能，仅靠改进电路工艺提高单机器件速度是很有限的，使用并行计算机的方法更加普遍有效</li>
<li>并行计算可以视作高性能计算机的同义词(普遍认可)</li>
</ul>
<h3 id="高性能计算机与超级计算机"><a href="#高性能计算机与超级计算机" class="headerlink" title="高性能计算机与超级计算机"></a>高性能计算机与超级计算机</h3><ul>
<li><p>两者等价</p>
<ul>
<li>高性能计算机(HPC):High Performance Computer</li>
<li>超级计算机(SC):Super Computer</li>
</ul>
</li>
<li><p>衡量性能指标：</p>
<ul>
<li>时间</li>
<li>操作次数</li>
</ul>
</li>
</ul>
<h3 id="高性能计算不可避免"><a href="#高性能计算不可避免" class="headerlink" title="高性能计算不可避免"></a>高性能计算不可避免</h3><ul>
<li>应用需求<ul>
<li>实际应用中需要性能更强大的硬件系统，使得一些新的应用需求得以满足<ul>
<li>微处理器的运算速度呈几何级数增长</li>
<li>并行结构硬件<ul>
<li>绝大部分应用需求</li>
</ul>
</li>
</ul>
</li>
<li>对性能要求的范围<ul>
<li>随着花费的日益增多需要知道系统的性能范围</li>
</ul>
</li>
<li>更多更新的应用与更好的性能之间相互促进</li>
<li>科学计算的需要<ul>
<li>FLOPS(Floating-point Operations Per Second):每秒钟进行的浮点计算操作次数，衡量性能重要标准<ul>
<li>Meta:$10^6$</li>
<li>Giga:$10^9$</li>
<li>Tera:$10^{12}$</li>
<li>Peta:$10^{15}$</li>
<li>Exa:$10^{18}$——目前所能达到</li>
<li>Zetta:$10^{21}$</li>
</ul>
</li>
<li>实时3D图像</li>
</ul>
</li>
<li>工程计算的需要：大部分并行计算机是许多工业部门的支柱<ul>
<li>石油行业：油藏分析、地震处理、油田建模</li>
<li>制造业：材质模拟、结构仿真、空气动力学仿真、热力学仿真</li>
<li>汽车行业：碰撞模拟，拖拉模拟，燃料的燃烧效率计算</li>
<li>航空行业：气流分析，发动机效率，结构机械</li>
<li>计算机辅助设计</li>
<li>制药行业：分子模型</li>
<li>生命科学：分子动力学、药物筛选、基因组测序</li>
<li>娱乐业：视觉要求</li>
<li>建筑行业：视觉要求，预排工作以及绘制立体视图</li>
<li>经济学建模：投资收益及相关分析、欺诈与异常检测、回溯测试、量化交易、风险分析</li>
<li>地球科学：大气层建模、气象模拟预测、冰川建模</li>
</ul>
</li>
<li>商业计算的需要<ul>
<li>高质量要求依赖于并行计算机<ul>
<li>计算能力决定了可以掌控的交易规模</li>
</ul>
</li>
<li>数据库、在线处理、决策支持、数据挖掘、数据仓库</li>
<li>TPC基准(TPC-C order entry， TPC-D决策支持)<ul>
<li>提供了明确的测量标准</li>
<li>企业的规模决定系统的规模</li>
<li>随着处理器数目的增加，问题的规模也并不是不变的</li>
<li>吞吐率作为性能标准(transactions per minute, tpm)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>技术进展</li>
<li>结构趋势</li>
<li>经济发展的需要</li>
<li>当前趋势<ul>
<li>当今的微处理器可以为多处理机系统提供支持</li>
<li>服务器以及工作站向着多处理器方向发展</li>
<li>今后的微处理器将成为多处理器 </li>
</ul>
</li>
</ul>
<h3 id="超级计算"><a href="#超级计算" class="headerlink" title="超级计算"></a>超级计算</h3><ul>
<li>超级计算(supercomputing)，于1929年在《纽约世界报》首次使用，指的是IBM为哥伦比亚大学制造的大型定制制表机(tabulator)</li>
</ul>
<h4 id="超级计算机-supercomputer"><a href="#超级计算机-supercomputer" class="headerlink" title="超级计算机(supercomputer)"></a>超级计算机(supercomputer)</h4><ul>
<li><p>能够执行一般个人电脑无法处理的高速运算的计算机</p>
<ul>
<li>通常而言，超级计算机的处理能力是目前最快的笔记本电脑或台式机的一百万倍以上(甚至不止，可能上亿)</li>
<li>现有的超级计算机运算速度大都可以达到每秒一万亿次以上</li>
</ul>
</li>
<li><p>特征</p>
<ul>
<li>某一时代性能最高的系统，服务于国家战略目标</li>
<li>运算速度超级快</li>
<li>存储容量超级大</li>
<li>占地面积超级大($100-1000m^2$)</li>
<li>能耗超级高(&gt;10MW)</li>
<li>造假超级贵(Billion RMB)</li>
<li>其关键技术迅速辐射到其他应用领域，推动国民经济建设，科学技术进步与人类社会发展</li>
</ul>
</li>
<li><p>与传统计算机相比，区别在于组件资源的组织、互连和规模，以及支撑软件在该规模上管理系统运行的能力</p>
</li>
<li><p>超级计算机对科学发现、技术创新、产业革命的重要作用</p>
<ul>
<li>高性能计算：是科学研究的三大手段之一</li>
<li>大数据处理：正成为科学研究的第四范式(理论、实验、计算、数据为科学研究四大范式)</li>
</ul>
</li>
<li>超级计算机可以帮助人们模拟解决一系列重要问题，如一些极端情景<ul>
<li>尺度超大或超小(宏观、微观)</li>
<li>时变超快或超慢</li>
<li>过程超昂贵或超危险</li>
</ul>
</li>
</ul>
<h3 id="演进历史-40年系统性能增长5-8亿倍"><a href="#演进历史-40年系统性能增长5-8亿倍" class="headerlink" title="演进历史(40年系统性能增长5.8亿倍)"></a>演进历史(40年系统性能增长5.8亿倍)</h3><h4 id="初生时代"><a href="#初生时代" class="headerlink" title="初生时代"></a>初生时代</h4><ul>
<li>世界上第一台真正意义上的高性能计算机诞生于1964年，美国计算机科学家西摩·克雷(Seymour Cray)和他的同事一起设计<ul>
<li>由于是通过美国数据控制公司(Control Data Corporation, CDC)制造并推向市场，命名为CDC 6600</li>
<li>约3MFLOPS，CPU时钟主频10MHz</li>
<li>性能是当时最快的计算机IBM 7030的10倍，1964-1969世界第一，高性能计算机的开端</li>
<li>价格800万美元</li>
<li>主要应用于高能核物理方面的研究工作</li>
<li>采用了液冷技术、硅晶体管技术、精简指令集技术</li>
</ul>
</li>
<li>西摩·克雷多次研制世界上最快的超级计算机，国防部称呼为美国民族的智多星<ul>
<li>Any one can build a fast CPU, the trick is to build a fast system. 设计快速的CPU比设计快速的系统更容易</li>
<li>Computers should obey a square law —— when the price doubles, you should get at least four times as much speed. 价格翻倍，性能至少提升4倍</li>
</ul>
</li>
</ul>
<h4 id="克雷时代"><a href="#克雷时代" class="headerlink" title="克雷时代"></a>克雷时代</h4><ul>
<li>1976，Cray-1，里程碑意义<ul>
<li>时钟频率80MHz，峰值性能为136MFLOPS，洛斯·阿拉莫斯国家实验室，研究核武器</li>
<li>首次使用集成电路对CPU芯片进行封装</li>
<li>首次使用基于向量的处理器架构</li>
<li>首次使用链式结构大幅减少CPU和内存的数据交换频率</li>
</ul>
</li>
</ul>
<h4 id="多核时代"><a href="#多核时代" class="headerlink" title="多核时代"></a>多核时代</h4><ul>
<li>并行协作</li>
<li>Cray-2开创的多核并行方向</li>
<li>日本电气株式会社公司1989发布SX-3/44R，以23.3GFLOPS计算速度获得世界第一</li>
<li>英特尔的Paragon系列超级计算机，并于1997年推出的ASCI Red系列，首次突破T级(FLOPS)计算大关</li>
</ul>
<h4 id="异构时代"><a href="#异构时代" class="headerlink" title="异构时代"></a>异构时代</h4><ul>
<li>2002年日本NEC公司发布地球模拟器(Earth Simulator)，拥有35TFLOPS浮点运算性能</li>
<li>美国IBM公司发布的Blue Gene/L系列超级计算机</li>
<li>美国花费6亿美元研发的Frontier超级计算机设计性能为1.5EFLOPS，2022年达到完全负载工作状态时，实测计算性能为1.102EFLOPS</li>
</ul>
<h3 id="国产发展历程"><a href="#国产发展历程" class="headerlink" title="国产发展历程"></a>国产发展历程</h3><h4 id="起步阶段-1956-1995"><a href="#起步阶段-1956-1995" class="headerlink" title="起步阶段(1956-1995)"></a>起步阶段(1956-1995)</h4><ul>
<li>我国第一代通用数字计算机均基于电子管技术<ul>
<li>1958-8-1，中国第一台小型电子管通用数字计算机——103型计算机，运算速度为每秒1800次，主要用于科学计算</li>
<li>1959，第一台自行设计的大型电子管数字计算机——104型计算机，运算速度为每秒10000次</li>
<li>1964，第一台国产大型电子管通用数字计算机——119型计算机，运算速度为每秒50000次</li>
</ul>
</li>
<li>为服务两弹一星研制专门的高性能计算机<ul>
<li>1958-9-8，第一台电子管专用数字计算机901机研制成功(中国人民解放军军事工程学院(哈军工，现国防科技大学)慈云桂教授)，依然基于电子管技术</li>
</ul>
</li>
<li>1965-4，第一台晶体管数字计算机(441-B计算机)，相比于美国的第一台全晶体管计算机RCA501晚6年</li>
<li>1983-12-22，慈云桂教授团队成功研制了“银河Ⅰ号”巨型计算机，运算速度达到每秒1亿次<ul>
<li>标志中国打破西方国家封锁，成为能够独立研发亿次高性能计算机的国家，真正迈入超算行列</li>
</ul>
</li>
<li>上世纪80年代，在“造不如买、买不如租”，“市场换技术”等政策指导下，半导体产业发展受到严重影响<ul>
<li>到80年代末，中国凭自己的技术已经很难生产出一台计算机了</li>
<li>在中国丧失独立自主研发制造计算机的能力后，美国政府开始严格限制对中国出口高性能计算机</li>
<li>玻璃房子<ul>
<li>原石油工业部地球物理勘探局曾花费巨资从国外购买了一台大型机，没想到，对方对后期的集成和维护费用开价百亿以上</li>
<li>对方还提出了一个让中国IT人铭记了十几年的屈辱条件——在设备使用过程中，为防止机器核心技术外泄，设备机房采用全透明的玻璃墙壁，对方要时刻监控我国工作人员的一举一动，甚至连高性能计算机的启动密码和机房钥匙都要由对方控制</li>
</ul>
</li>
<li>为了彻底拆除“玻璃房子”，研发出完全拥有自主知识产权的国产高性能计算机，我国的科学家们走上了一条异常艰苦的突围之路</li>
</ul>
</li>
</ul>
<h4 id="追赶阶段-1996-2009"><a href="#追赶阶段-1996-2009" class="headerlink" title="追赶阶段(1996-2009)"></a>追赶阶段(1996-2009)</h4><ul>
<li>天河、曙光、神威<ul>
<li>2004 年，由中科院计算所、曙光公司、上海超级计算中心三方共同研发制造的“曙光 4000A”高性能计算机实现了 10 TFLOPS 的运算速度，成为我国第一个跨入十万亿级计算的超级计算机，也标志着我国成为继美国和日本第三个有独立设计十万亿级高性能计算的国家，也是我国第一个进入TOP500前十的超级计算机</li>
<li>2009 年 9 月，国防科技大学成功研制了我国首台千万亿次超级计算机—“天河一号”，部署在国家超级计算天津中心。峰值速度为 1.2 PFLOPS 且LINPACK 实测性能为 563.1 TFLOPS，使中国成为世界上第二（继美国之后）能够研制千万亿次超级计算机的国家，至此，我国顶尖高性能计算机离登顶只有一步之遥</li>
<li>2010 年 11 月 16 日是我国高性能计算机发展史中一个值得铭记的时刻，全球超级计算机 TOP500 排行榜在美国新奥尔良市揭晓，升级后的“天河一号”二期系统（“天河-1A”）以每秒 4700 万亿次的峰值性能、每秒 2507 万亿次的 LINPACK 实测值持续性能，超越美国橡树岭国家实验室的“美洲虎”超级计算机，成为当时世界上最快的超级计算机<ul>
<li>这是我国自主研发的高性能计算机首次登顶超级计算机TOP500排行榜，这标志着我国国产高性能计算机正式进入世界一流梯队</li>
</ul>
</li>
</ul>
</li>
<li>2004，2008，2009突破十万亿次、百万亿次、千万亿次计算大关，不断缩小与世界领先技术的差距</li>
</ul>
<h4 id="超越阶段-2010至今"><a href="#超越阶段-2010至今" class="headerlink" title="超越阶段(2010至今)"></a>超越阶段(2010至今)</h4><ul>
<li>2013 年底，国防科技大学研制的“天河二号”超级计算机正式验收并部署到国家超算广州中心，自2013 年 6 月至 2016 年 6 月，“天河二号”连续 6 次排名世界上最快的超级计算机，理论峰值达 54.90 PFLOPS，实际峰值速度达 33.86 PFLOPS</li>
<li>2016 年 6 月 20 日，“神威·太湖之光”超级计算机在LINPACK 计算性能测试中以 93 PFLOPS 的评测结果超越“天河二号”，成为当时世界上最快的超级计算机<ul>
<li>“神威·太湖之光”也是中国首度自行设计并使用国产核心芯片登上 TOP500 第一名的超级计算机</li>
<li>一直保持世界领先的计算性能，直到 2018 年 6 月被美国的 Summit 超级计算机所超越(三连冠)</li>
<li>采用国产申威众核处理器</li>
<li>全系统4万个结点，1000万核</li>
<li>峰值性能12.5亿亿次／秒，Linpack 9.3亿亿次／秒</li>
<li>能效比 6GF/W</li>
<li>在国家超算无锡中心</li>
</ul>
</li>
</ul>
<h4 id="重要经验"><a href="#重要经验" class="headerlink" title="重要经验"></a>重要经验</h4><ul>
<li>国家科技计划与地方、应用部门的发展计划相结合<ul>
<li>多渠道筹资研制高效能计算机</li>
<li>科技部和地方政府共同支持建立国家超算中心</li>
</ul>
</li>
<li>产学研用的结合<ul>
<li>高性能计算中心在高效能计算机研制中发挥作用<ul>
<li>遴选研制团队／提出系统指标</li>
</ul>
</li>
<li>企业参与国家科技计划，提高自身水平，促进研制工作<ul>
<li>浪潮、曙光、联想参与千万亿次和亿亿次计算机的研制</li>
</ul>
</li>
<li>应用部门牵头发展应用软件</li>
</ul>
</li>
<li>机器、环境、应用三者均衡发展，相互促进</li>
<li>并行是通往超级计算的唯一途径</li>
</ul>
<h3 id="未来发展趋势"><a href="#未来发展趋势" class="headerlink" title="未来发展趋势"></a>未来发展趋势</h3><ul>
<li>从 E 级计算到 Z 级计算<ul>
<li>简单地堆叠硬件难以继续实现性能指标提升</li>
<li>还需要解决能耗、可扩展性、可靠性、应用编程、应用效率等诸多极具挑战性的难题</li>
</ul>
</li>
<li>超算与人工智能、大数据的融合应用<ul>
<li>人工智能还需要更复杂的硬件结构才能完成。智能超级计算机的研发也获得了业界与科学家们的广泛关注</li>
</ul>
</li>
<li>非冯·诺依曼架构的新型计算系统<ul>
<li>由于硅基半导体工艺已逐步逼近其物理极限，经典的冯·诺依曼架构暴露出了愈发明显的瓶颈</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机体系结构</category>
      </categories>
      <tags>
        <tag>高级计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基准评测集</title>
    <url>/2024/09/25/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-09-25-%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86/</url>
    <content><![CDATA[<h1 id="基准评测集"><a href="#基准评测集" class="headerlink" title="基准评测集"></a>基准评测集</h1><h2 id="计算机性能"><a href="#计算机性能" class="headerlink" title="计算机性能"></a>计算机性能</h2><ul>
<li>计算机性能: 通常指机器的速度，程序执行时间的倒数</li>
<li>程序执行时间(Wall-clock time, response time, or elapsed time): 指用户的响应时间(访问磁盘和访问存储器的时间，CPU时间，I/O时间以及操作系统的开销)</li>
<li>CPU时间: 表示CPU的工作时间，不包括I/O等待时间和运行其他任务的时间</li>
</ul>
<h3 id="The-Processor-Performance-Equation"><a href="#The-Processor-Performance-Equation" class="headerlink" title="The Processor Performance Equation"></a>The Processor Performance Equation</h3><ul>
<li>CPU time for a program can then be expressed two ways: <ul>
<li>CPU time = CPU clock cycles for a program x Clock cycle time(CPU时间 = 一个程序的CPU时钟周期 x 时钟周期时间)</li>
<li>CPU time = CPU clock cycles for a program / Clock rate(CPU时间 = 一个程序的CPU时钟周期 / 时钟频率，与上面的公式是一样的，因为时钟周期时间和时钟频率互为倒数)</li>
<li>CPU time = Instruction count(Total Instruction Count / Program) x Cycles per instruction(Total Clock cycles / Total Instructin Count) x Clock cycle time(Toal Cost Seconds / Total Clock cycle)(CPU时间 = 指令数量 x 每条指令所需的时钟周期数 x 时钟周期时间) = Total Cost Seconds / Total Program Num(每个程序执行的时间)<ul>
<li>clock cycles per instruction(CPI): CPI = CPU clock cycles for a program / Instruction count(每条指令所需的时钟周期数CPI = 一个程序的CPU时钟周期 / 指令的条数)</li>
</ul>
</li>
</ul>
</li>
<li>Different instruction types having different CPIs(不同的指令集类型有不同的CPI)<ul>
<li>$CPU\quad clock\quad cycles = \Sigma_{i = 1}^n IC_i \times CPI_i$(总的CPU时钟周期数为各种指令集的时钟周期数之和)</li>
<li>$CPU\quad time = (\Sigma_{i = 1}^n IC_i \times CPI_i) \times Clock\quad cycle\quad time$</li>
</ul>
</li>
<li><p>Overall CPI(整体的CPI，所有指令集类型的加权平均)</p>
<ul>
<li>$CPI = \frac{\Sigma_{i=1}^n IC_i \times CPI_i}{Instruction\quad count} = \Sigma——{i=1}^n \frac{IC_i}{Instruction\quad count} \times CPI_i$</li>
</ul>
</li>
<li><p>It is difficult to change one parameter in completet isolation from others(Clock cycle time, CPI and Instruction count)</p>
<ul>
<li>Clock cycle time: Hardware technology and organization(取决于硬件和组织)</li>
<li>CPI: Organization and instruction set architecture(取决于组织和指令集架构)</li>
<li>Instruction count: Instruction set architecture and compiler technology(取决于指令集架构和编译技术)</li>
</ul>
</li>
<li><p>具体影响因素</p>
<ul>
<li>算法<ul>
<li>影响程序的执行指令数(Instruction Count)</li>
<li>好的算法可以大幅度减少运算的次数，从而大幅度减少执行的指令数</li>
</ul>
</li>
<li>编程语言<ul>
<li>影响程序的执行指令数(Instruction Count)</li>
<li>编程语言可能对执行指令数产生巨大的影响，例如: 解释执行、即时编译或者原生编译的三大类语言完成同样的功能所需要的指令数可能有数量级的差异</li>
</ul>
</li>
<li>编译器和库<ul>
<li>影响程序的执行指令数(Instruction Count)和CPI</li>
<li>编译器和库决定了源程序到计算机指令的翻译过程，编译程序的效率既影响到程序的执行指令数，又影响到CPI(Intel的ICC编译器编译出来的程序，效率比GCC高30%，因为ICC充分利用向量化指令和针对处理器结构进行了优化)</li>
</ul>
</li>
<li>指令系统结构<ul>
<li>影响程序的执行指令数(Instruction Count)、CPI和时钟频率</li>
</ul>
</li>
<li>微体系结构<ul>
<li>影响CPI和时钟频率</li>
<li>微体系结构的改进可以降低CPI，细分流水线提高时钟频率</li>
</ul>
</li>
<li>物理设计<ul>
<li>影响时钟频率</li>
<li>物理设计和电路的进步可以降低时钟周期，从而提高时钟频率(倒数)</li>
</ul>
</li>
<li>工艺<ul>
<li>影响时钟频率</li>
<li>工艺的进步使得晶体管变快从而提高时钟频率</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS(Million Instruction Per Second，每秒百万次指令数，用于不同计算机横向比较，忽略了不同指令系统之间的差异)</p>
<ul>
<li>$MIPS = \frac{I_N}{(T_E \times 10^6)} = \frac{R_C}{CPI\times 10^6}$<ul>
<li>$T_E$表示程序执行时间</li>
<li>$R_C$表示时钟速率，$T_C$的倒数</li>
<li>$I_N$表示指令数量</li>
</ul>
</li>
<li>相对MIPS: $MIPS<em>{Rel} = (\frac{T</em>{Ref}}{T<em>V} \times MIPS</em>{Ref}$<ul>
<li>$MIPS<em>{Ref}$和$T</em>{Ref}$为参照机器的执行时间和MIPS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="FLOPS-Floating-point-Operations-Per-Second-每秒浮点运算次数"><a href="#FLOPS-Floating-point-Operations-Per-Second-每秒浮点运算次数" class="headerlink" title="FLOPS(Floating-point Operations Per Second, 每秒浮点运算次数)"></a>FLOPS(Floating-point Operations Per Second, 每秒浮点运算次数)</h3><ul>
<li>$MFLOPS = \frac{I_{FN}}{(T_E \times 10^6)}$<ul>
<li>$I_{FN}$表示程序中的浮点运算次数</li>
<li>一般认为在标量计算机中执行一次浮点运算平均需要3条指令<ul>
<li>$1FLOPS \approx 3MIPS$</li>
</ul>
</li>
<li>每秒百万次浮点运算次数(Mega Floating-point Operations Per Second, MFLOPS, megaFLOPS,  MFlop/s)</li>
<li>每秒十亿次浮点运算次数(Giga Floating-point Operations Per Second, GFLOPS, gigaFLOPS, GFlop/s)</li>
<li>每秒万亿次浮点运算次数(Tera Floating-point Operations Per Second,TFLOPS,teraFLOPS,TFlop/s)</li>
<li>每秒千万亿次浮点运算次数(Peta Floating-point Operations Per Second,PFLOPS,petaFLOPS,PFlop/s)</li>
<li>每秒百亿亿次浮点运算次数(Exa Floating-point Operations Per Second,EFLOPS,exaFLOPS,EFlop/s)</li>
</ul>
</li>
</ul>
<h3 id="其他性能"><a href="#其他性能" class="headerlink" title="其他性能"></a>其他性能</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.png" alt="img"></p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li>提高计算机的使用效率</li>
<li>减少用户购机的盲目性，降低投资的风险</li>
<li>改进系统结构设计，提高机器的性能</li>
<li>促进软/硬件结合，合理功能划分</li>
<li>优化“结构-算法-应用”的最佳组合</li>
<li>提供客观、公正的评价计算机的标准</li>
</ul>
<h3 id="机器级性能评测"><a href="#机器级性能评测" class="headerlink" title="机器级性能评测"></a>机器级性能评测</h3><h4 id="CPU的某些基本性能指标"><a href="#CPU的某些基本性能指标" class="headerlink" title="CPU的某些基本性能指标"></a>CPU的某些基本性能指标</h4><ul>
<li>工作负载<ul>
<li>执行时间</li>
<li>浮点运算数</li>
<li>指令数目</li>
</ul>
</li>
<li>总时间$T_n$ = 并行执行时间$T_comput$ + 并行开销时间$T_paro$ + 相互通信时间$T_comm$</li>
</ul>
<h4 id="存储器的某些基本性能指标"><a href="#存储器的某些基本性能指标" class="headerlink" title="存储器的某些基本性能指标"></a>存储器的某些基本性能指标</h4><ul>
<li>层次结构<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="img"></li>
<li>带宽</li>
</ul>
<h4 id="并行和通信开销的分析"><a href="#并行和通信开销的分析" class="headerlink" title="并行和通信开销的分析"></a>并行和通信开销的分析</h4><h4 id="计算机的可用性与好用行以及机器成本、价格与性价比"><a href="#计算机的可用性与好用行以及机器成本、价格与性价比" class="headerlink" title="计算机的可用性与好用行以及机器成本、价格与性价比"></a>计算机的可用性与好用行以及机器成本、价格与性价比</h4><ul>
<li>机器的性价比(Performance/Cost Ratio)指用单位代价(以百万美元表示)所获取的性能(MIPS或GFLOPS)</li>
<li>利用率(Utilization): 可达到的速度与峰值速度之比</li>
</ul>
<h3 id="算法级性能评测"><a href="#算法级性能评测" class="headerlink" title="算法级性能评测"></a>算法级性能评测</h3><h4 id="加速比-Speedup"><a href="#加速比-Speedup" class="headerlink" title="加速比(Speedup)"></a>加速比(Speedup)</h4><ul>
<li><p>并行系统的加速比指对于一个给定的应用，并行算法(并行程序)的执行速度相对于串行算法(串行程序)的执行速度加快了多少倍</p>
</li>
<li><p>符号: </p>
<ul>
<li>$P$: 处理器数</li>
<li>$W$: 问题规模(计算负载、工作负载、给定问题的总计算量)<ul>
<li>$W_S$: 应用程序中的串行分量，$f$是串行分量比例($f = \frac{W_S}{W}$)</li>
<li>$W_P$: 应用程序中可并行化的部分，$(1-f)$为并行分量的比例</li>
<li>$W_S + W_P = W$: </li>
</ul>
</li>
<li>$T_S = T_1$: 串行执行时间</li>
<li>$T_P$: 并行执行时间</li>
<li>$S$: 加速比</li>
<li>$E$: 效率</li>
</ul>
</li>
<li><p>Speedup of computer X relative to computer Y(相对加速比)</p>
<ul>
<li>$n = \frac{Execution\quad time_Y}{Execution\quad time_X} = \frac{\frac{1}{Performance_Y}}{\frac{1}{Performance_X}} = \frac{Performance_X}{Performance_Y}$(X is n times as fast as Y)</li>
<li>$S = \frac{T_S}{T_P}$</li>
</ul>
</li>
<li><p>Amdahal定律</p>
<ul>
<li>固定负载条件下程序并行化效率提升的理论上界(固定的计算负载分布在多个处理器上，达到加速的目的)</li>
<li>常用于预测使用多个处理器后的理论加速比上界</li>
<li>固定负载的加速公式<ul>
<li>$S = \frac{W_S + W_P}{W_S + \frac{W_P}{p}} = \frac{f+(1-f)}{f + \frac{1-f}{p}} = \frac{p}{1+f(p-1)}$<ul>
<li>$W_S + W_P = [f + (1-f)]W$</li>
<li>$p \rightarrow \infin$，上式的极限为: $S = \frac{1}{f}$</li>
<li>因此在固定负载的情况下，加速比是有上限的</li>
</ul>
</li>
</ul>
</li>
<li>除非一段串行程序的所有部分都可以并行化，否则可以达到的加速比是非常有限的(不论使用多少核)</li>
<li>并行程序的加速比与串行执行所需要的时间无关，只与可并行部分的长度$W_P$和并行系数p有关</li>
<li>实际并行加速不仅受限于程序的串行分量，也受到并行程序运行时额外开销的影响，令$W_O$为额外开销<ul>
<li>$S=\frac{W_S + W_P}{W_S + \frac{W_P}{p} + W_O} = \frac{W}{fW + \frac{W(1-f)}{p} + W_O} = \frac{p}{1+f(p-1)+\frac{W_Op}{W}}$</li>
<li>$p \rightarrow \infin$，$S = \frac{W}{fW + W_O}$</li>
</ul>
</li>
</ul>
</li>
<li>Gustafson定律<ul>
<li>对于很多大型计算，精度要求很高，即在此类应用中<strong>精度是个关键因素</strong>，而<strong>计算时间是固定不变的</strong>。此时为了提高精度，必须加大计算量，相应地亦<strong>必须增多处理器数才能维持时间不变</strong></li>
<li>除非学术研究，在实际应用中没有必要固定工作负载而计算程序运行在不同数目的处理器上，<strong>增多处理器必须相应地增大问题规模才有实际意义</strong></li>
<li>Gustafson加速定律<ul>
<li>$S’ = \frac{W_S + pW_P}{W_S + \frac{p\cdot W_P}{p}} = \frac{W_S + pW_P}{W_S + W_P}= f + p(1-f) = p + f(1-p) = p - f(p-1)$</li>
<li>并行开销$W_O$<ul>
<li>$S’ = \frac{W_S + pW_P}{W_S + W_P + W_O} = \frac{f + p(1-f)}{1+\frac{W_O}{W}}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Sun-Ni定律(存储受限的加速定律)<ul>
<li>只要存储空间许可，应尽量增大问题规模以产生更好和更精确的解(可能使执行时间略微增加)</li>
<li>假定在单节点上使用了全部存储容量M并在相应于W的时间内求解之，此时工作负载$W = fW + (1-f)W$</li>
<li>在p个节点的并行系统上，能够求解较大规模的问题是因为存储容量可增加到pM。令因子$G(p)$反映存储容量增加到p倍时并行工作负载的增加量，所以扩大后的工作负载$W = fW + (1-f)G(p)W$</li>
<li>存储受限的加速公式<ul>
<li>$S’’ = \frac{fW + (1-f)G(p)W}{fW + \frac{(1-f)G(p)W}{p}} = \frac{f + (1-f)G(p)}{fW + \frac{(1-f)G(p)}{p}}$</li>
</ul>
</li>
<li>加入并行开销$W_O$<ul>
<li>$S’’ = \frac{fW + (1-f)WG(p)}{fW + \frac{(1-f)G(p)W}{p} + W_O} = \frac{f + (1-f)G(p)}{f + \frac{(1-f)G(p)}{p} + \frac{W_O}{W}} $</li>
</ul>
</li>
<li>$G(p) = 1$，Amdahl加速定律</li>
<li>$G(p) = p$，Gustafson加速定律</li>
<li>$G(p) &gt; p$，相应于计算机负载比存储要求增加得快，此时Sun-Ni加速均比Amdahl加u是和Gustafson加速高</li>
</ul>
</li>
<li>参考的加速经验公式: $\frac{P}{logP} \le S \le P$</li>
<li>线性加速比: 很少通信开销的矩阵相加、内积运算</li>
<li>$\frac{P}{logP}$的加速比: 分治类的应用问题(二叉树，树的同级可并行执行，但向根逐级推进时，并行度逐渐减少)</li>
<li>通信密集类的应用问题: $S = \frac{1}{C(p)}$，$C(p)$是p个处理器的某一通信函数(线性/对数)</li>
<li>超级性加速: 并行搜索算法(提前取消无谓的搜索分支)</li>
<li>绝对加速: 最佳并行算法与串行算法相比</li>
<li>相对加速: 同一算法在单机和并行机的运行时间之比</li>
</ul>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><ul>
<li>加速比S与线性加速比p的比值<ul>
<li>$E = \frac{S}{p} = \frac{\frac{T_S}{T_P}}{p} = \frac{T_S}{p\cdot T_P}$</li>
<li>线性加速比<ul>
<li>对于p核的高性能计算机: $T_P = \frac{T_S}{p}$，此时并行程序拥有线性加速比p</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可扩展性-三种度量标准是等效的"><a href="#可扩展性-三种度量标准是等效的" class="headerlink" title="可扩展性(三种度量标准是等效的)"></a>可扩展性(三种度量标准是等效的)</h4><ul>
<li>可扩展性最简朴的含义是: 在确定的应用背景下，计算机系统(或算法或程序等)性能随处理器数量的增加而按比例提高的能力</li>
<li>影响加速比的因素: 处理器数量p和问题规模W<ul>
<li>求解问题中的串行分量</li>
<li>并行处理所引起的额外开销(通信、等待、竞争、冗余操作、同步)</li>
<li>加大的处理器数量超过了算法中的并发程度</li>
</ul>
</li>
<li>增加问题的规模有利于提高加速的因素<ul>
<li>较大的问题规模可提供较高的并发度</li>
<li>额外开销的增加可能慢于有效计算的增加</li>
<li>算法中的串行分量比例不是固定不变的(串行部分所占的比例随着问题规模的增大而缩小)</li>
</ul>
</li>
<li>增加处理器数量会增大额外开销和降低处理器的利用率。所以对于一个特定的并行系统(算法或程序)，能否有效利用不断增加的处理器的能力应是受限的，而度量这种能力就是可扩展性指标</li>
<li>因此可扩展性是调整什么和按什么比例调整<ul>
<li>并行计算要调整的是处理器数p和问题规模W</li>
<li>两者可按不同比例进行调整，比例关系可能是线性的，多项式的或指数的</li>
</ul>
</li>
<li><p>可扩展性的主要目的是</p>
<ul>
<li>确定解决某类问题用何种并行算法与何种并行体系结构的组合，可以有效地利用大量的处理器</li>
<li>对于运行于某种体系结构的并行机上的某种算法当移植到大规模处理机上后运行的性能</li>
<li>对固定的问题规模，确定在某类并行机上最优的处理器数量与可获得的最大加速比</li>
<li>用于指导改进并行算法和并行体系结构，以使并行算法尽可能地充分利用可扩充的大量处理器</li>
<li>目前无一个公认的、标准的和被普遍接受的严格定义和评判标准</li>
</ul>
</li>
<li><p>等效率度量标准(非唯一的方法): 保持效率E不变的前提下，研究问题规模W如何随着处理器个数p而变化</p>
<ul>
<li>令$t_e^i$和$t_o^i$分别是并行系统上第i个处理器的有用计算时间和额外开销时间(通信、同步和空闲等待时间)<ul>
<li>$T<em>e = \Sigma</em>{i=0}^{p-1} t_e^i$(整个系统的有用计算时间)</li>
<li>$T<em>o = \Sigma</em>{i=0}^{p-1} t_o^i$(整个系统的额外开销时间)</li>
</ul>
</li>
<li>$T_p$是p个处理器系统上并行算法的运行时间，对于任意i显然有$T_p = t_e^i + t_o^i$，且$T_e + T_o = pT_p$</li>
<li>问题的规模W为最佳串行算法所完成的计算量$W=T_e$<ul>
<li>$S = \frac{T_e}{T_p} = \frac{T_e}{\frac{T_e+T_o}{p}} = \frac{p}{1+\frac{T_o}{T_e}} = \frac{p}{1+ \frac{T_o}{W}}$</li>
<li>$E = \frac{S}{p} = \frac{1}{1+\frac{T_o}{T_e}} = \frac{1}{1+\frac{T_o}{W}}$</li>
</ul>
</li>
<li>优点: <ul>
<li>简单可定量计算</li>
<li>只需少量参数完成计算</li>
</ul>
</li>
<li>缺点: <ul>
<li>$T_o$以解析计算得到，但有时难以计算: 例如非局部访问的读写时间、进程调度的时间、存储竞争的时间以及高速缓存一致性操作时间等都是难以准确计算的</li>
</ul>
</li>
</ul>
</li>
<li>等速度度量标准(iso-speed, 以试验测试为主要手段): 保持平均速度不变的前提下，研究处理器个数p增多时，应相应增加多少工作量W<ul>
<li>$T_o$隐含在所测量的执行时间中</li>
</ul>
</li>
<li><p>平均延迟度量标准(average latency, 以试验测试为主要手段): 保持效率E不变的前提下，用平均延迟的比值来标志随处理器个数p增加需要增加的工作量W</p>
<ul>
<li>调节W与p测量并行和串行执行时间，最终通过平均延迟反映出$T_o$</li>
</ul>
</li>
<li><p>主要目的</p>
<ul>
<li>探索算法和并行架构的组合<ul>
<li>确定解决某类问题使用何种并行算法和并行架构的组合，更有利于利用大量的硬件资源</li>
</ul>
</li>
<li>预测算法性能<ul>
<li>根据某个算法在特定架构下的小规模处理器上的性能，预测该算法移植到较大规模的处理器上后算法的运行性能</li>
</ul>
</li>
<li>计算最大加速比<ul>
<li>探索在固定的问题规模下，确定利用的处理器数量及其能获得的最大加速比</li>
</ul>
</li>
<li>指导算法改进和并行架构设计<ul>
<li>根据拓展性指标，指导开发、研究人员改进并行算法或者系统架构，以提高处理器的利用效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序级性能评测"><a href="#程序级性能评测" class="headerlink" title="程序级性能评测"></a>程序级性能评测</h3><h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h4><ul>
<li>基本测试</li>
<li>数据库测试</li>
<li>并行测试程序</li>
</ul>
<h3 id="HPC架构"><a href="#HPC架构" class="headerlink" title="HPC架构"></a>HPC架构</h3><h4 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h4><ul>
<li>速度<ul>
<li>系统组件的速度(处理器时钟频率)</li>
</ul>
</li>
<li>并行性<ul>
<li>系统的并发度，同时能执行的操作数</li>
</ul>
</li>
<li>效率<ul>
<li>系统的利用率</li>
<li>常用度量: <ul>
<li>持续浮点性能</li>
<li>理论峰值性能的比值</li>
</ul>
</li>
</ul>
</li>
<li>峰值性能<ul>
<li>超级计算机理论上在其硬件资源的支持下能够获得的最大性能值</li>
<li>理论峰值性能: 计算机理论上能达到的每秒钟完成浮点计算最大次数，由CPU的主频、CPU每个时钟周期执行浮点运算的次数和系统总CPU核数共同决定<ul>
<li>理论峰值性能 = CPU时钟频率 x CPU每个时钟周期执行的浮点运算次数 x CPU数量  </li>
<li>适用于通用的硬件体系结构，但忽略了内存架构及带宽、I/O性能、缓存一致性等因素的影响，从而无法真正反映系统的真实峰值性能</li>
</ul>
</li>
<li>实测峰值性能<ul>
<li>通过标准的程序测试得到</li>
</ul>
</li>
</ul>
</li>
<li>功率<ul>
<li>处理器主频与功率相关</li>
<li>冷却系统</li>
</ul>
</li>
<li>可靠性<ul>
<li>软硬件故障</li>
<li>Checkpoint机制(用于回滚)</li>
</ul>
</li>
<li>可编程性<ul>
<li>涉及系统的易用性和生产率</li>
</ul>
</li>
</ul>
<h2 id="基准评测集-1"><a href="#基准评测集-1" class="headerlink" title="基准评测集"></a>基准评测集</h2><ul>
<li>性能基准评测就是从基准测试程序和测试规范的角度评价和预测系统的性能<ul>
<li>可以帮助机构确定所需要采购的超级计算机</li>
<li>可以指导制造商设计高性能计算机系统的方向</li>
<li>探索HPC趋势的重要历史记录</li>
</ul>
</li>
</ul>
<h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><ul>
<li>The best choice of benchmarks to measure performance is <strong>real applications</strong><ul>
<li>Kernels: small, key pieces of real applications</li>
<li>Toy programs: 100-line programs(基础的程序，不超过100行) for in beginning programming assignment</li>
<li>Synthetic benchmarks: fake programs invented to try to match the profile and behavior of real applications(Dhrystone, 整数运算能力；浮点数运算能力)</li>
<li>benchmark suites: collections of benchmark applications(SPEC06fp, TPC-C)</li>
</ul>
</li>
</ul>
<h3 id="商用基准测试程序"><a href="#商用基准测试程序" class="headerlink" title="商用基准测试程序"></a>商用基准测试程序</h3><h4 id="Transaction-processing-TP-benchmarks-事务处理能力"><a href="#Transaction-processing-TP-benchmarks-事务处理能力" class="headerlink" title="Transaction-processing(TP) benchmarks(事务处理能力)"></a>Transaction-processing(TP) benchmarks(事务处理能力)</h4><ul>
<li><p>measure the ability of a system to handle transactions that consist of database accesses and updates</p>
</li>
<li><p>Transaction Processing Council(TPC): create realistic and fair benchmarks for TP</p>
<ul>
<li>TPC-A,TPC-B(已废弃)</li>
<li>TPC-C: simulates a complex query environment(目前最流行的在线事务处理, (Online Transaction Processing, OLTP), 商用基准测试程序, 能模拟一个大公司的整个销售环境(仓库、区域、用户、订单等事务的比例、响应时间)，用于测试事务处理系统的性能与价性比)<ul>
<li>性能结果tpmC: 描述了系统在执行Payment、Order-status、Delivery、Stock-Level等交易的同时，每分钟可以处理多少个New-Order交易<ul>
<li>所有的交易响应时间必须满足TPC-C测试规范的要求</li>
<li>流量指标值越大越好</li>
</ul>
</li>
<li>价性比结果$/tpmC: 结果越小越好</li>
<li>各厂商的TPC-C测试结果都按TPC组织规定的两种形式发布<ul>
<li>测试结果概要(Executive Summary)<ul>
<li>描述了主要的测试指标、测试环境示意图以及完整的系统配置、报价</li>
</ul>
</li>
<li>详细测试报告(Executive Report)<ul>
<li>还详细说明了整个测试环境的设置和测试的过程</li>
</ul>
</li>
</ul>
</li>
<li>TPC-C允许被测系统放大和缩小，但终端数和数据库规模也必须按规模缩放</li>
</ul>
</li>
<li>TPC-H</li>
<li>TPC-DI</li>
<li>TPC-E</li>
</ul>
</li>
</ul>
<h4 id="SPEC-System-Performance-Evaluation-Cooperative-测试程序"><a href="#SPEC-System-Performance-Evaluation-Cooperative-测试程序" class="headerlink" title="SPEC(System Performance Evaluation Cooperative)测试程序"></a>SPEC(System Performance Evaluation Cooperative)测试程序</h4><ul>
<li>由计算机厂商、系统集成商、大学、研究机构、咨询等多家公司组成的非营利性组织</li>
<li>SPEC CPU系列测试程序集合主要关注CPU的性能，通过分析具体程序的行为寻找优化方向<ul>
<li>SPECratio(单进程)分值主要反映PC系统性能<ul>
<li>A ratio by dividing the time on the reference computer by the time on the computer being rated(参考计算机与测试计算机的SPEC的执行时间的比值)</li>
<li>综合测试结果是取SPECratio的几何平均值</li>
<li>SPEC CPU ratio是一个相对比值，IPC高分值不一定高(IPC指的是每周期执行的指令数？)</li>
</ul>
</li>
<li>衡量服务器的吞吐量通常采用SPECrate，在多CPU执行SPEC CPU的多份拷贝，并且把CPU的时间转换为比率(rate)</li>
<li>随CPU性能提高已发展了6轮: 1989、1992、1995、2000、2006、2017<ul>
<li>SPEC CPU2000: 12个定点程序，14个浮点程序<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%202000%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
<li>SPEC CPU2006: 12个定点程序，17个浮点程序<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%202006%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
<li>SPEC CPU2017: 10个定点，14个浮点程序，分为<ul>
<li>Rate(多道程序): 多个拷贝多核运行</li>
<li>Speed(多线程): 单个拷贝、代码针对openMP自动并行化做了修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%2020171%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%2020172%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Summarize performance results of the suite in a unique number<ul>
<li>arithmetic means of execution times of programs in the suite(算术平均)</li>
<li>the weighted arithmetic mean(加权算术平均)</li>
<li>normalize execution times to a reference computer(标准化到参考计算机)</li>
</ul>
</li>
</ul>
<h3 id="HPC基准评测集"><a href="#HPC基准评测集" class="headerlink" title="HPC基准评测集"></a>HPC基准评测集</h3><h4 id="计算性能评测集"><a href="#计算性能评测集" class="headerlink" title="计算性能评测集"></a>计算性能评测集</h4><ul>
<li>Linpack(Linear system package)<ul>
<li>图灵奖得主美国计算机科学家Jack Dongarra等几位学者于1979年开发的线性系统软件库(Linear system package)</li>
<li><a href="http://www.netlib.org/lapack/lug/">Linkpack用户手册</a></li>
<li>目标是集成常用的线性方程组求解的程序(最小平方问题、稠密矩阵运算)至一个通用的线性代数软件库，支持求解大部分常见的线性代数问题</li>
<li>用来度量系统的浮点计算能力<ul>
<li>评测指标: 每秒浮点运算次数(FLOPS)</li>
</ul>
</li>
<li>Linpack性能是指求解双精度线性代数方程组时所达到的实际性能<ul>
<li>Linpack100: 使用Fortran中的Linpack软件求解规模为100阶的稠密线性代数方程组<ul>
<li>为了运行该程序，需要提供一个称为<code>SECOND</code>的计时函数，报告已经过去的CPU时间</li>
<li>运行此基准评测的基本规则是不能对Fortran代码进行任何更改，甚至不允许更改注释，只允许采用编译优化选项进行优化</li>
<li><a href="http://www.netlib.org/benchmark/linpackd">Linpack100 测试程序</a></li>
</ul>
</li>
<li>Linpack1000: 求解规模为1000阶的线性代数方程组<ul>
<li>运行此基准评测的基本规则要宽松一些，可以指定希望求解的任何线性方程，用任何语言实现。</li>
<li>而且在达到必须满足要求的情况下，可以在不改变计算量的前提下做算法和代码上的优化<ul>
<li>必须满足要求是必须计算出一个解决方案，并且该解决方案必须返回一个达到规定精度的结果</li>
</ul>
</li>
<li><a href="http://www.netlib.org/benchmark/1000d">Linpack1000 测试程序</a></li>
</ul>
</li>
<li>类似的HPL是针对现代高性能计算机的评测基准，是国际超级计算系统TOP500的重要依据<ul>
<li>具体为求一个n维的线性方程组的解: <ul>
<li>$Ax=b; A\in R^{n\times n};x, b\in R^n$</li>
</ul>
</li>
<li>$n\times(n+1)$的系数矩阵$[A, b]$, 进行LU分解: <ul>
<li>$[A. b] = [[LU], y]$</li>
</ul>
</li>
<li>方程组的解$x$转化为求解三角矩阵U作为系数矩阵的线性方程组$Ux=y$而得到</li>
<li>目标是尽可能地使得高性能计算机对矩阵A的不同部分并行地做出更新，需要对矩阵进行分块<ul>
<li>$N$为最高GFLOPS值的矩阵规模，$N_B$为求解矩阵的分块大小</li>
<li>$P$为处理器网格中水平方向处理器的个数，$Q$为处理器网格中垂直方向处理器的个数</li>
<li>如下图，矩阵首先划分为$N_B=4\times 4$个数据块，之后所有$N_B$个数据块映射到数目为$P\times Q=2\times2$的进程阵<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/HPL.png" alt="img"></li>
</ul>
</li>
<li><a href="http://www.netlib.org/benchmark/hpl">HPL 采用 C 语言进行编写的测试程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HPCG(High-Performance Conjugate Gradient, 高性能共轭梯度法，C++)<ul>
<li>然而，实际应用中的计算存在大量使用偏微分方程建模、稀疏计算和不规则访存的情况，以上这些情况无法用Linpack进行衡量。这是就需要用到HPCG，但要注意: HPCG只是一种求解稀疏矩阵方程组的迭代算法，作为Linpack的补充，而不能替代，促使计算机系统的设计不仅仅只专注于计算能力的发展，还要向访存、通信这些方面发展</li>
<li>目的是适应目前大部分应用程序所采用的计算和数据访问模式，最终促进计算机性能的整体提升</li>
<li>模拟三维热力学运动问题，从而转化为求解离散的三维偏微分方程模型问题<ul>
<li>三维热力学运动问题转化步骤: <ul>
<li>网格划分: 将热力学问题转化为离散的三维空间网格。根据实际情况，可以选择均匀网格或非均匀网格</li>
<li>离散化: 根据具体的热力学方程，将偏微分方程转化为差分方程。例如，可以使用有限差分法或有限元法来离散化方程<ul>
<li>利用差分方程迭代的过程中，采用全局通信和邻近进程数据的通信方式以及向量更新、点乘、稀疏矩阵向量乘法和局部三角求解器等计算模式，覆盖了高性能计算领域中常见的计算操作</li>
</ul>
</li>
<li>边界条件: 根据实际问题，在离散的网格上设置正确的边界条件。这些条件用于描述问题的物理特性</li>
<li>代数方程组: 将离散化的方程整理为矩阵形式，并构建一个稀疏线性方程组。方程组的未知数通常是网格点上的温度或其他物理量</li>
<li>解方程组: 使用HPCG或其他合适的求解器，通过迭代方法(如共轭梯度法)求解离散方程组。这涉及到矩阵向量乘法和共轭梯度法的实现</li>
<li>并行计算: 为了提高性能，利用并行计算技术(如MPI或OpenMP)将计算任务分配给多个处理器或多个计算节点</li>
</ul>
</li>
<li>使用局部对称高斯·塞德尔(Local Symmetric Gauss-Seidel, LSGS)预条件子的预处理共轭梯度法(Conjugate Gradient, CG)<ul>
<li>通过将原始线性系统矩阵分解为局部块矩阵，使用Gauss-Seidel迭代逐块求解，能够有效地加速CG方法的收敛速度</li>
<li>基本步骤: <ul>
<li>定义原始线性系统: 将原始线性系统表示为$Ax=b$的形式，其中$A$是对称正定的稀疏矩阵，$x$是解向量，$b$是右侧向量</li>
<li>分解稀疏矩阵: 将稀疏矩阵A分解为对角矩阵形式(如D-L-U, 主对角线矩阵、严格的下三角、严格的上三角)</li>
<li>预处理: 采用Gauss-Seidel迭代对分解后的系数矩阵进行预处理，通过使用前一步求解得到的分量更新当前的分量，直到达到所需要的精度。对于块矩阵来说，每个块的更新是独立进行的</li>
<li>执行共轭梯度法迭代: 使用预处理后的分解系数矩阵(块对角矩阵)和预处理后的右侧向量进行共轭梯度法迭代求解</li>
</ul>
</li>
<li>主要优点: <ul>
<li>能够利用块矩阵的局部性质和Gauss-Seidel迭代的迭代更新加速共轭梯度法的收敛</li>
</ul>
</li>
<li>限制: <ul>
<li>对块矩阵的分解和求解过程复杂</li>
<li>在某些情况下可能会受到块矩阵形状和特征值分布的影响</li>
</ul>
</li>
</ul>
</li>
<li>主要处理的数据为对称正定稀疏矩阵<ul>
<li>稀疏线性方程组通过配置文件中的参数构建，其中未知数是网格点上的温度或其他的物理量<ul>
<li>网格维度(<code>nx</code>, <code>ny</code>, <code>nz</code>): 设置三维网格的大小，决定方程组中未知数的个数</li>
<li>网格划分(<code>px</code>, <code>py</code>, <code>pz</code>): 定义并行计算中网格划分的方式</li>
<li>通信模式(<code>cg_iter</code>, <code>symmetry</code>, <code>overlap</code>, <code>global_mpi</code>): 决定通信方式，是否引入对称性</li>
<li>矩阵类型(<code>exec_set</code>, 值可以为<code>laplacian</code>, <code>elasticity</code>): 决定了稀疏矩阵的结构</li>
<li>非零元素密度(<code>toc</code>): 决定矩阵的稀疏程度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>运行要求: <ul>
<li>问题规模所需占用的内存大小至少占系统总内存的四分之一以上<ul>
<li>主要是由于问题规模太小会导致数据访存开销以及访存不规则的问题无法暴露</li>
</ul>
</li>
<li>禁止用户改变预处理器的设置，保证系统测试的合理性<ul>
<li>禁止修改数据在内存中的存储长度等修改数据存储格式的操作</li>
<li>禁止通过修改算法减少通信开销</li>
</ul>
</li>
</ul>
</li>
<li>指标<ul>
<li>HPCG得分: 作为一个综合评估指标，度量计算机的整体性能，反应了计算机在求解稀疏线性系统方面的速度和效率</li>
<li>迭代次数: 反映的是计算机的计算能力和收敛速度</li>
<li>内存带宽: HPCG基准测试是一个内存密集型的应用程序，通过测试可以了解计算机在高速缓存和主存之间的数据传输效率</li>
</ul>
</li>
<li>指出了未来计算机的改进方向: 通过异步通信以及能够降低通信延迟的相关技术</li>
</ul>
</li>
<li><p>Graph500(Sandia National Laboratories, SNL. Richard Murphy)</p>
<ul>
<li>在图遍历的基础上设计出来(因为图遍历是一种典型的数据密集型应用)</li>
<li>旨在评测高性能计算机对复杂数据的处理性能(特别是数据密集型应用)，侧重于系统的通信子系统，不再专注于计算性能</li>
<li><p>流程: </p>
<ul>
<li>图数据生成</li>
<li>图遍历验证<ul>
<li>利用广度优先搜索(BFS)或单源点最短路径(SSSP, Single source shortest path?)算法作为核心搜索程序，随机选择一个根节点作为源点进行遍历并检查保存的结果与原来的生成图是否匹配</li>
<li>迭代次数与源点数量相同</li>
</ul>
</li>
<li>结果计算与输出 </li>
<li>在访问搜索根源点之前立即开始对搜索时间计时，将输出的结果写入内存后，停止计时</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Graph500%E6%B5%81%E7%A8%8B.png" alt="img"></p>
</li>
<li><p>Graph500基准评测程序按照问题的规模分为六个等级，也被称为等级10-15</p>
<p>大小|规模(2的次方)|节点数($\times 10^8$)|内存要求/TB<br>:-:|:-:|:-:|:-:<br>Toy|26|1|0.02<br>Mini|29|5|0.14<br>Small|32|43|1.1<br>Medium|36|687|17.6<br>Large|39|5498|141<br>Huge|42|43980|1126</p>
</li>
<li><p>指标: </p>
<ul>
<li>每秒遍历的边数(Traversed Edges Per Second, TEPS)，是生成图的边数和核心搜索程序算法的耗时比值</li>
</ul>
</li>
<li>目标: <ul>
<li>公平遵守基准规范的意图</li>
<li>给定机器的最大问题大小</li>
<li>给定问题大小的最短执行时间</li>
<li>次要目标: <ul>
<li>最小代码量(不包括验证码)</li>
<li>最少的开发时间</li>
<li>最大的可维护性</li>
<li>最大的可扩展性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IO性能评测集-评估文件系统和存储性能"><a href="#IO性能评测集-评估文件系统和存储性能" class="headerlink" title="IO性能评测集(评估文件系统和存储性能)"></a>IO性能评测集(评估文件系统和存储性能)</h4><ul>
<li>MDTest: 广泛使用的文件和目录创建、访问和删除的基准测试工具，用于评估文件系统的元数据性能<ul>
<li>通过在一组机器(通常是HPC集群中的计算节点)上并行创建、统计和删除目录树和文件树评测I/O性能</li>
<li>指标是每秒的操作数(OP/秒)</li>
<li><a href="https://sourceforge.net/projects/mdtest/">MDTest测试程序</a></li>
</ul>
</li>
<li>IOR(Interoperability of I/O Ribbons): 使用多种I/O接口(POSIX, MPI-IO, HDF5)和访问模式来测量并行文件系统和存储系统I/O性能的基准测试工具<ul>
<li>通过接收参数，在客户端上产生特定的工作负载从而测试系统的I/O性能并输出评测结果</li>
<li>评测结果中的带宽是通过传输的数据量除以停止时间戳与开始时间戳的差值得到</li>
</ul>
</li>
<li>IO500: 一个综合性的基准测试套件，旨在评估高性能计算环境下文件系统和存储系统的性能<ul>
<li>由于测试方法、工具和参数甚至测试步骤的先后顺序不同，不同厂商发布的I/O性能测试结果具有很大的差异性，使用IO500可以对高性能存储系统进行标准的测试和比较</li>
<li>方法: 分为两组进行评测<ul>
<li>第一组评测的是高性能计算机I/O的理想性能，通过大文件的读写等方式测评计算机存储系统的性能上限，能够有效激励世界各大存储厂商不断提升系统的极限性能<ul>
<li>IOR easy</li>
<li>MDTest easy</li>
</ul>
</li>
<li>第二组评测的是高性能计算机I/O的极限性能，通过海量小文件的读写测评计算机存储系统的性能极限<ul>
<li>IOR hard</li>
<li>MDTest hard</li>
</ul>
</li>
</ul>
</li>
<li>最终分数是IOR分数和MDTest分数的几何平均值(乘积开方)</li>
</ul>
</li>
</ul>
<h4 id="网络性能评测集"><a href="#网络性能评测集" class="headerlink" title="网络性能评测集"></a>网络性能评测集</h4><ul>
<li><p>IMB: 用于评估HPC集群在不同消息粒度下节点间点对点、全局通信的效率</p>
<ul>
<li>点对点通信<ul>
<li>评测测试的是两个进程间的消息传递，包括Ping-Pong和Ping-Ping(互ping?)测试</li>
</ul>
</li>
<li>并行通信<ul>
<li>评测测试的是全局负载下消息的收发效率，包括Sendrecv和Exchange测试</li>
</ul>
</li>
<li>群体通信<ul>
<li>评测测试的是一对多或者多对一的消息传递</li>
</ul>
</li>
</ul>
</li>
<li><p>OSU(Ohio State University) Benchmark</p>
<ul>
<li>程序生成不同规模的数据并执行各种不同模式的MPI通信(跨语言通信协议)，测试各种通信模式的延迟和带宽<ul>
<li>延迟测试采用的是Ping-Pong方式</li>
<li>带宽测试分为点对点通信和组通信两种形式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="能耗评测集"><a href="#能耗评测集" class="headerlink" title="能耗评测集"></a>能耗评测集</h4><ul>
<li>Green 500: 提供高性能计算机的能耗排名<ul>
<li>指标: 使用PPW(performance per watt, 每瓦特性能, 通常单位为GFLOPS Per Watt)作为其指标对能源效率进行排名<ul>
<li>$PPW = \frac{Performance}{Power} = \frac{R<em>{max}}{\overline{P}(R</em>{max})}$</li>
<li>$\overline{P}(R<em>{max}) = N \cdot \overline{P}</em>{unit}(R_{max})$(超级计算机的整体功耗包括计算节点、网络和存储等各个部分的能耗之和，这里是假定各部分能耗一致)</li>
</ul>
</li>
</ul>
</li>
<li>功率测量方法<ul>
<li>直接测量: 通过使用功率计或电流传感器直接测量超级计算机的电力输入。功率计可以接入电源线路测量电流和电压，并计算功率($P = UI$)。这种方法可以提供较准确的功率测量结果，但需要考虑电流和电源的稳定性</li>
<li>间接测量: 通过测量超级计算机的其他物理参数间接估计功率<ul>
<li>使用温度传感器测量系统的温度，根据热传导定律和热功率模型推导功率($Q=Pt$?)</li>
</ul>
</li>
<li>硬件监控: 使用超级计算机中的硬件监控功能获取功耗数据</li>
<li>软件监控: 使用特定的性能检测工具和软件估计功耗，可以通过检测处理器利用率、内存访问模式和其他负载信息推断功耗</li>
</ul>
</li>
<li>超级计算机的功率测量需要综合考虑软硬件监控方法，以获得更准确的数据，用于评估和优化能源效率</li>
<li>任何的功率测量方法都有一定的误差范围，并且测量都有不确定性。</li>
<li>要定期进行功耗测量，以监控和评估超级计算机的能源效率，并在必要的时候进行调整优化</li>
</ul>
<h4 id="应用评测集"><a href="#应用评测集" class="headerlink" title="应用评测集"></a>应用评测集</h4><ul>
<li><p>Miniapplication</p>
<ul>
<li>是真实应用程序的更小版本，用于评估超级计算机对于动态应用程序的性能<ul>
<li>既要足够复杂，又要足够小</li>
<li>性能包括内存、网络、加速器和处理器元素的参数和交互空间</li>
</ul>
</li>
<li>开源Miniapplication<ul>
<li>MiniAMR: 用于探索自适应网格细化和动态执行的小型应用程序</li>
<li>MiniFE: 有限元代码的小型应用程序，提供了对多核节点上进行计算的支持</li>
<li>MiniGhost: 有限差分小型应用程序，可在均匀三维域上实现有限差分</li>
<li>MiniMD: 基于分子动力学工作负载的小型应用程序</li>
<li>Cloverleaf: 使用显式的二阶精确方法来求解可压缩欧拉方程</li>
<li>TeaLeaf: 求解线性热传导方程工作负载的小型应用程序</li>
</ul>
</li>
</ul>
</li>
<li><p>戈登·贝尔奖(ACM Gordon Bell Prize): 超算界的诺贝尔奖</p>
<ul>
<li>评选对象是当年前500排名的超级电脑系统上所跑的应用程序</li>
<li>奖项：<ul>
<li>最高性能奖(Peak Performance)</li>
<li>最高性价比奖(Price/Performance)</li>
<li>特别奖(Special Achievement)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机体系结构</category>
      </categories>
      <tags>
        <tag>高级计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提高性能</title>
    <url>/2024/10/09/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-09-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h1><h2 id="Take-Advantage-of-Parallelism"><a href="#Take-Advantage-of-Parallelism" class="headerlink" title="Take Advantage of Parallelism"></a>Take Advantage of Parallelism</h2><h3 id="Level-of-the-system"><a href="#Level-of-the-system" class="headerlink" title="Level of the system"></a>Level of the system</h3><ul>
<li>multiple processors and multiple storgae devices can be used</li>
<li>The workload of handling requests can then be spread among the processors and storage devices(分摊到各个处理器和存储设备)</li>
</ul>
<h3 id="Level-of-individual-processor"><a href="#Level-of-individual-processor" class="headerlink" title="Level of individual processor"></a>Level of individual processor</h3><ul>
<li>pipelining: the best-known example of ILP(流水线并行)</li>
</ul>
<h3 id="Level-of-detailed-digital-design"><a href="#Level-of-detailed-digital-design" class="headerlink" title="Level of detailed digital design"></a>Level of detailed digital design</h3><ul>
<li>set-associative caches use multiple banks of memory that are typically searched in parallel to find a desired item(使用能并行查找的缓存)</li>
</ul>
<h2 id="Principle-of-Locality-局部性原理"><a href="#Principle-of-Locality-局部性原理" class="headerlink" title="Principle of Locality(局部性原理)"></a>Principle of Locality(局部性原理)</h2><h3 id="The-principle-of-locality"><a href="#The-principle-of-locality" class="headerlink" title="The principle of locality"></a>The principle of locality</h3><ul>
<li>programs tend to reuse data and instructions they have used recently(倾向于使用刚使用过的数据、指令)</li>
</ul>
<h3 id="An-implication-of-locality"><a href="#An-implication-of-locality" class="headerlink" title="An implication of locality"></a>An implication of locality</h3><ul>
<li>predict with reasonable accuracy what instructions and data a program will use in the near future(预测要使用的数据、指令)<ul>
<li>based on its accesses in the recent past</li>
</ul>
</li>
</ul>
<h3 id="Two-different-types-of-locality"><a href="#Two-different-types-of-locality" class="headerlink" title="Two different types of locality"></a>Two different types of locality</h3><h4 id="Temporal-locality"><a href="#Temporal-locality" class="headerlink" title="Temporal locality"></a>Temporal locality</h4><ul>
<li>recently accessed items are likely to be accessed soon(例如循环指令)</li>
</ul>
<h4 id="Spatial-locality"><a href="#Spatial-locality" class="headerlink" title="Spatial locality"></a>Spatial locality</h4><ul>
<li>items whose addresses are near one another tend to be referenced close together in time(例如访问数组)</li>
</ul>
<h2 id="Foucus-on-the-Common-Case"><a href="#Foucus-on-the-Common-Case" class="headerlink" title="Foucus on the Common Case"></a>Foucus on the Common Case</h2><ul>
<li>in making a design trade-off, favor the frequent case over the infrequent case(优先考虑常见的例子)</li>
<li>The common case is often simpler and can be done faster than the infrequent case<ul>
<li>first optimize the more common case of no overflow, because overflow is rare(优先考虑不溢出时候的优化，因为溢出是非常特殊的情况，很少发生)</li>
</ul>
</li>
</ul>
<h2 id="并行算法-程序-的设计步骤"><a href="#并行算法-程序-的设计步骤" class="headerlink" title="并行算法(程序)的设计步骤"></a>并行算法(程序)的设计步骤</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4.png" alt="img"></p>
<h3 id="任务划分-Partitioning"><a href="#任务划分-Partitioning" class="headerlink" title="任务划分(Partitioning)"></a>任务划分(Partitioning)</h3><ul>
<li>将整个计算分解为一些小的任务，其目的是尽量开拓并行执行的机会</li>
<li>一个并行程序通常同时存在数据和功能并行的机会<ul>
<li>功能并行的并行度通常比较有限，并且不会随着问题规模的扩大而增加；不同的函数所涉及的数据集的大小可能差异很大，因此也难于实现负载均衡(基本看消耗大的，时间长的)</li>
<li>数据并行有很好的可扩展性，易于实现负载均衡(容易平均分)</li>
</ul>
</li>
<li>合理性检查<ul>
<li>所划分的任务数是否高于目标机上处理器数目1-2个量级？否则缺少灵活性</li>
<li>划分是否避免了冗余的计算和存储要求？否则可扩展性不大，因为会随着问题规模的扩大增加更多的冗余</li>
<li>各任务的尺寸是否大致相当？否则很难负载均衡</li>
<li>划分的任务数是否与问题尺寸成比例？否则可扩展性不大<ul>
<li>理想情况下，问题尺寸的增加应该引起任务数量的增加而不是任务尺寸的增加。也就是需要执行的任务更多而不是一个任务要执行更久</li>
</ul>
</li>
<li>是否采用了几种不同的划分法？多角度看待更全面</li>
</ul>
</li>
</ul>
<h4 id="域分解-Domain-Decomposition-数据划分，大多数采用"><a href="#域分解-Domain-Decomposition-数据划分，大多数采用" class="headerlink" title="域分解(Domain Decomposition, 数据划分，大多数采用)"></a>域分解(Domain Decomposition, 数据划分，大多数采用)</h4><ul>
<li>划分对象是数据<ul>
<li>算法(程序)的输入数据</li>
<li>计算产生的中间结果</li>
<li>最后得到的输出数据</li>
</ul>
</li>
<li>步骤: <ul>
<li>分解与问题相关的数据，使得这些小的数据篇尽可能大小上大致相等</li>
<li>将每个计算关联到操作的数据上<ul>
<li>由此每个任务包括一些数据和对应操作</li>
<li>当一个操作需要别的任务的数据时，就会产生任务间通信需求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="功能分解-Functional-Decomposition-计算划分"><a href="#功能分解-Functional-Decomposition-计算划分" class="headerlink" title="功能分解(Functional Decomposition, 计算划分)"></a>功能分解(Functional Decomposition, 计算划分)</h4><ul>
<li>关注于被执行的计算上，而非计算所需的数据(每个任务最好只做一种计算)</li>
<li>如果计算划分成功，再继续研究计算所需的数据，如果数据基本上不相交，意味着划分成功</li>
<li>不常用，主要用来分析域分解结果产生的问题</li>
</ul>
<h3 id="通信分析-Communication-analysis"><a href="#通信分析-Communication-analysis" class="headerlink" title="通信分析(Communication analysis)"></a>通信分析(Communication analysis)</h3><ul>
<li>分析确定各个任务执行中所需交换的数据和协调各个任务的执行，由此可检测上述任务划分的合理性</li>
</ul>
<h4 id="局部-全局通信"><a href="#局部-全局通信" class="headerlink" title="局部/全局通信"></a>局部/全局通信</h4><ul>
<li>局部通信: 每个任务只和较少的几个近邻通信</li>
<li>全局通信: 每个任务与很多其他任务通信</li>
</ul>
<h4 id="结构化-非结构化通信"><a href="#结构化-非结构化通信" class="headerlink" title="结构化/非结构化通信"></a>结构化/非结构化通信</h4><ul>
<li>结构化: 规整结构，如树、网格等</li>
<li>非结构化: 通信网络可能是任意图，如稀疏矩阵-向量乘(消息传递编程困难)</li>
</ul>
<h4 id="静态-动态通信"><a href="#静态-动态通信" class="headerlink" title="静态/动态通信"></a>静态/动态通信</h4><ul>
<li>静态: 通信伙伴身份不随时间改变，如矩阵相乘</li>
<li>动态: 通信伙伴的身份可能由运行时数据决定且是可变的，如15-puzzle问题，消息传递编程较困难</li>
</ul>
<h4 id="同步-异步通信"><a href="#同步-异步通信" class="headerlink" title="同步/异步通信"></a>同步/异步通信</h4><ul>
<li>同步: 接收方和发送方协同操作需要协同</li>
<li>异步: 接收方和发送方协同操作无需协同</li>
</ul>
<h4 id="one-way-two-way通信"><a href="#one-way-two-way通信" class="headerlink" title="one-way/two-way通信"></a>one-way/two-way通信</h4><ul>
<li>one-way: 通信存在生产者-消费者关系，如读写(阻塞？)</li>
<li>two-way: 通信只需要一方发起并完成，如只读(非阻塞？)</li>
</ul>
<h3 id="任务组合-Agglomeration"><a href="#任务组合-Agglomeration" class="headerlink" title="任务组合(Agglomeration)"></a>任务组合(Agglomeration)</h3><ul>
<li>按性能要求和实现的代价来考察前两阶段的结果，必要时可将一些小的任务组合成更大的任务以提高性能或减少通信开销</li>
</ul>
<h4 id="增加粒度"><a href="#增加粒度" class="headerlink" title="增加粒度"></a>增加粒度</h4><ul>
<li>大量细粒度任务有可能增加通信代价和任务创建代价，所以可以适当合并细粒度的任务</li>
<li>表-容效应(Surface-Volume Effect)<ul>
<li>一个任务通信需求比例于它所操作的子域的表面积，而计算需求却比例于子域的容积</li>
</ul>
</li>
</ul>
<h4 id="保持灵活性"><a href="#保持灵活性" class="headerlink" title="保持灵活性"></a>保持灵活性</h4><ul>
<li>可移植性</li>
<li>可扩展性</li>
</ul>
<h3 id="处理器映射-Mapping"><a href="#处理器映射-Mapping" class="headerlink" title="处理器映射(Mapping)"></a>处理器映射(Mapping)</h3><ul>
<li>将每个任务分配到一个处理器上，其目的是最小化全局执行时间和通信成本以及最大化处理器的利用率</li>
</ul>
<h4 id="映射策略"><a href="#映射策略" class="headerlink" title="映射策略"></a>映射策略</h4><ul>
<li>指定任务到哪个处理器上去执行，其主要目标是减少算法的总执行时间，策略有二：<ul>
<li>把那些可并发执行的任务放在不同的处理器上以增强并行度</li>
<li>把那些需频繁通信的任务置于同一个处理器上以提高局部性</li>
</ul>
</li>
</ul>
<h4 id="负载均衡-使得所有处理器完成等量的任务"><a href="#负载均衡-使得所有处理器完成等量的任务" class="headerlink" title="负载均衡(使得所有处理器完成等量的任务)"></a>负载均衡(使得所有处理器完成等量的任务)</h4><ul>
<li>减少同步等待的时间，这包括等待其它进程结束运行的时间和串行执行的代码部分(包括临界区代码和因数据相关造成的串行执行)</li>
<li>通常采用的一种策略是在任务分配中，先集中目标使负载尽量均衡，然后再对任务分配进行调整，使得交互尽量少</li>
</ul>
<h3 id="任务分配与调度"><a href="#任务分配与调度" class="headerlink" title="任务分配与调度"></a>任务分配与调度</h3><h4 id="静态调度-程序员完成"><a href="#静态调度-程序员完成" class="headerlink" title="静态调度(程序员完成)"></a>静态调度(程序员完成)</h4><ul>
<li>静态地为每个处理器分配连续的循环迭代(要求处理器计算能力同构)</li>
<li>轮转(将第i个循环迭代分配给第 $i \mod P$ 个处理器)</li>
</ul>
<h4 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h4><ul>
<li>基本自调度SS(Self Scheduling)：每个处理器空闲时从全局队列取一个任务</li>
<li>块自调度BSS(Block Self Scheduling)：每次取k个任务(块)</li>
<li>指导自调度GSS(Guided Self Scheduling) ：每次取剩余任务的 $\frac{1}{P}$</li>
<li>因子分解调度FS(Factoring Scheduling)：$C_i=\frac{R_i}{2P}$，每阶段所有处理器任务大小相等</li>
<li>梯形自调度TSS(Trapezoid Self Scheduling) ：连续的块之间的差距固定不变</li>
<li>安全自调度SSS(Safe Self Scheduling)：任务分配使得累计执行时间刚刚超过平均负载</li>
<li>亲和性调度AS(Affinity Scheduling)：分布式任务队列(本地调度+远程调度)</li>
<li>自适应耦合调度AAS(Adapt Affinity Scheduling)：初始分配不平衡、计算能力异构<ul>
<li>重载</li>
<li>轻载</li>
<li>常载</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机体系结构</category>
      </categories>
      <tags>
        <tag>高级计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能计算机的体系结构</title>
    <url>/2024/10/16/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-16-%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="高性能计算机的体系结构"><a href="#高性能计算机的体系结构" class="headerlink" title="高性能计算机的体系结构"></a>高性能计算机的体系结构</h1><h2 id="超级计算机硬件"><a href="#超级计算机硬件" class="headerlink" title="超级计算机硬件"></a>超级计算机硬件</h2><ul>
<li>从硬件组成上看，超级计算机系统系统的硬件由五个子系统组成<ul>
<li>计算阵列</li>
<li>存储阵列</li>
<li>服务阵列</li>
<li>互连通信子系统</li>
<li>监控诊断子系统<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="计算阵列"><a href="#计算阵列" class="headerlink" title="计算阵列"></a>计算阵列</h3><ul>
<li>由计算节点组成，每个计算节点配置不同数量的中央处理器(CPU)和协处理器(GPU)<ul>
<li>协处理器通常是加速器，被用于增加计算的吞吐量，以降低可编程性的微小代价获得<ul>
<li>因为加速器使用的控制逻辑通常与现有的处理器指令集架构(ISA)不兼容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h4><ul>
<li>采用层次式混合共享存储架构，实现大容量、高带宽、低延迟的共享存储功能</li>
</ul>
<h4 id="服务阵列"><a href="#服务阵列" class="headerlink" title="服务阵列"></a>服务阵列</h4><ul>
<li>采用商用服务器，属于大容量的胖节点</li>
</ul>
<h4 id="互连通信子系统"><a href="#互连通信子系统" class="headerlink" title="互连通信子系统"></a>互连通信子系统</h4><ul>
<li>互连网络是大规模并行处理系统的核心<ul>
<li>天河系列的超算使用的拓扑结构是胖树拓扑结构，可高效进行均衡扩展</li>
<li>支持基于硬件实现的自动消息交换机制的集体操作(广播、多播)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E4%BA%92%E8%BF%9E%E9%80%9A%E4%BF%A1%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="监控诊断子系统"><a href="#监控诊断子系统" class="headerlink" title="监控诊断子系统"></a>监控诊断子系统</h4><ul>
<li>实现了整体系统实时安全监测和诊断调试功能<ul>
<li>实时监控、控制、诊断和调试整个超级计算机系统的健康状态、功耗和温度信息</li>
</ul>
</li>
</ul>
<h2 id="高性能计算机体系结构分类"><a href="#高性能计算机体系结构分类" class="headerlink" title="高性能计算机体系结构分类"></a>高性能计算机体系结构分类</h2><h3 id="传统分类"><a href="#传统分类" class="headerlink" title="传统分类"></a>传统分类</h3><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ul>
<li>微型机</li>
<li>小型机<ul>
<li>VAX 11</li>
</ul>
</li>
<li>中型机<ul>
<li>IBM System/3</li>
</ul>
</li>
<li>大型机<ul>
<li>IBM Z9</li>
</ul>
</li>
<li>巨型机</li>
</ul>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul>
<li>模拟计算机</li>
<li>数字计算机</li>
<li>混合计算机</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>专用计算机</li>
<li>通用计算机</li>
</ul>
<h4 id="常见分类"><a href="#常见分类" class="headerlink" title="常见分类"></a>常见分类</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/classes_of_computers.png" alt="img"></p>
<ul>
<li>Internet of Things(IoT)/Embedded Computers<ul>
<li>connected to the Internet, typically wirelessly</li>
<li>Embedded Computers have the widest spread of processing power and cost(能耗和成本的分布很广，都是有低有高)<ul>
<li>Include 8-bit to 32-bit processors that may cost one peny, and high-end 64-bit processors for cars and network switches that cost $100(中控屏和交换机)</li>
<li>However, its primary goal is to meet the performance need at a minimum price</li>
</ul>
</li>
</ul>
</li>
<li>Personal Mobile Device(PMD)<ul>
<li>a collection of wireless devices with multimedia user interfaces, such as cell phones and tablet computers.</li>
<li>Application on PMDs are often web-based and media-oriented(应用通常是基于网络或面向多媒体)</li>
<li>Use the ability to run third-party software as dividing line between non-embedded and embedded computers<ul>
<li>能跑第三方软件的小型设备就是PMD，那这样树莓派也是PMD，只有裸机才是嵌入式设备？</li>
</ul>
</li>
<li>real-time, energy efficiency, memory usage minimization</li>
</ul>
</li>
<li>Desktop Computing(销量正在下降，不如手机和平板了)<ul>
<li>spans from low-end netbooks to high-end heavily configured workstation</li>
<li>Emphasis: optimize price-performance(强调性价比)<ul>
<li>performance is measured primarily in terms of computer performance and graphics performance(分为计算机本身的计算性能和图像处理性能)</li>
</ul>
</li>
<li>The newest, highest-performance microprocessors and cost-reduced microprocessors often appear first in desktop systems</li>
</ul>
</li>
<li>Servers<ul>
<li>to provide larger-scale and more reliable file and computig services(提高更大规模和更可靠的文件和计算服务)</li>
<li>Availability</li>
<li>Scalability</li>
<li>Throughout(吞吐量大)</li>
</ul>
</li>
<li>Clusters/Warehouse Scale Computers(largest of the clusters, tens of thousands of servers can act as one)<ul>
<li>collections of desktop computers or servers connected by local area networks to act as a single larger computer(多台计算机或服务器通过本地局域网连接在一起，表现为一台整体的计算机)<ul>
<li>each node runs its own operating system, and nodes communicate using a networking protocol</li>
</ul>
</li>
<li>price-performance and power are cirtical<ul>
<li>Supercomputers emphasize floating-point performance</li>
<li>Clusters emphasize interactive applications(交互式应用程序), large-scale storage(大规模存储), dependability(可靠性), and high Internet bandwidth(高带宽)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>由于计算机硬件技术的发展，划分标准需要跟随时代的变化<ul>
<li>有些上世纪的大型巨型计算机不如本世纪的中小型计算机</li>
</ul>
</li>
<li>不能反映机器的系统结构特征</li>
</ul>
<h3 id="Flynn分类法"><a href="#Flynn分类法" class="headerlink" title="Flynn分类法"></a>Flynn分类法</h3><ul>
<li>基于数据流和指令流的并行性关系<ul>
<li>指令流(Instruction): 机器执行的指令序列，即一系列将数据送入数据处理单元进行修改的命令</li>
<li>数据流(Data): 由指令流调用的数据序列，包括输入数据和中间结果，但不包括输出数据</li>
<li>多倍性(Multiple): 系统性能瓶颈部件上处于同一执行阶段的指令或数据的最大可能个数</li>
</ul>
</li>
<li>Michael J. Flynn提出，IEEE计算机体系结构技术委员会和ACM SIGARCH都他创立的<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Flynn.png" alt="img"></li>
</ul>
<h4 id="SISD"><a href="#SISD" class="headerlink" title="SISD"></a>SISD</h4><ul>
<li>单指令流和单数据流</li>
<li>传统冯诺依曼计算机(串行计算机)<ul>
<li>硬件上不支持任何并行化计算，所有指令串行执行</li>
<li>在一个时钟周期内只能执行一条数据流</li>
<li>早期的 IBM PC 机、Intel 8086/8088 微处理器、早期的巨型机<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SISD.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h4><ul>
<li>单指令流和多数据流</li>
<li>可实现数据级并行，对多个不同的数据流并行执行相同的数据处理操作<ul>
<li>主要适用于解决向量和矩阵等复杂的科学计算和大规模工程计算问题</li>
<li>如果没有和数据项一样多的ALU，需要将任务进行分割后分批并行处理</li>
<li>大多应用于数字信号处理、图像处理等领域<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SIMD.png" alt="img"></li>
</ul>
</li>
<li><p>阵列计算机</p>
<ul>
<li>用一个单一的控制单元提供信号驱动多个处理单元同时运行<ul>
<li>每个处理器单元都由功能增强版的计算单元和本地内存组成</li>
<li>每个处理单元可以选择执行或者不执行控制器发出的指令流</li>
<li>处理单元之间通过互连网络连接</li>
</ul>
</li>
<li>发展前景不好</li>
<li>ILLIAC IV<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ILLIAC%20IV.png" alt="img"><ul>
<li>64个处理单元、64个处理单元存储器和存储器逻辑部件组成<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ILLIAC%20IV1.png" alt="img"><ul>
<li>64个处理部件$PE<em>0～PE</em>{63}$排列成8×8的方阵，任何一个$PE_i$只与其上、下、左、右4个近邻$(PE_i-8)\mod64$、$(PE_i+8)\mod64$、$(PE_i-1)\mod64$和$(PE_i+1)\mod64$直接相连</li>
<li>循此规则，南北方向上同一列的PE两端相连成一个环，东西方向上每一行的东端PE与下一行的西端PE相连，最下面一行的东端PE则与最上面一行的西端PE相连，从而构成一个闭合的螺线形状，所以称其为闭合螺线阵列<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ILLIAC%20IV2.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>向量计算机</p>
<ul>
<li>专门对向量进行处理的计算机</li>
<li>主要以流水线结构为主，以向量作为基本操作单元，操作数和结果都以向量的形式存在</li>
<li>向量的处理方法有多种不同的，主要包括横向，纵向和纵横处理方法</li>
<li>主要部件<ul>
<li>向量寄存器<ul>
<li>能存储由多个操作数组成的向量</li>
<li>长度：4-128 个 64 位元素不等</li>
</ul>
</li>
<li>向量化和流水化的功能部件<ul>
<li>对向量中的每个元素执行同样的操作</li>
</ul>
</li>
<li>向量指令<ul>
<li>对向量进行操作的指令，而非标量</li>
</ul>
</li>
<li>交叉存储器(interleaved memory)<ul>
<li>内存系统由多个内存体组成</li>
<li>每个内存体能够独立同时访问</li>
</ul>
</li>
<li>步长式存储器访问(strided memory access)<ul>
<li>能够访问向量中固定间隔(步长)的元素</li>
</ul>
</li>
<li>硬件散射/聚集(hardware scatter/gather, 与上面步长式互补)<ul>
<li>指对无固定间隔的数据进行读(gather)和写(scatter)</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>速度快</li>
<li>容易使用</li>
<li>向量编译器擅长识别向量化的代码<ul>
<li>能识别不能向量化的循环，并提供循环不能向量化的原因</li>
<li>用户能对是否重写代码来支持向量化做出明智决定</li>
</ul>
</li>
<li>很高的内存带宽</li>
<li>充分利用高速缓存行中的每个元素</li>
</ul>
</li>
<li>缺点<ul>
<li>不能处理不规则的数据结构和其他并行结构</li>
<li>可扩展性受到限制<ul>
<li>能够处理更大问题的能力，新一代系统通过增加向量处理器的数目，而非增加向量长度来进行扩展</li>
</ul>
</li>
<li>因此对长向量的支持需要定制，非常昂贵</li>
</ul>
</li>
<li>Cray-1<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Cray_1.png" alt="img"><ul>
<li>向量寄存器组V<ul>
<li>由512个64位的寄存器组成，分成8块($V_0~V_7$)</li>
<li>每一个块称为一组向量寄存器(64个)，可存放长度(即元素个数)不超过64的向量</li>
<li>每个向量寄存器可以每拍向功能部件提供一个数据元素，或者每拍接收一个从功能部件发来的结果元素</li>
</ul>
</li>
<li>标量寄存器S<ul>
<li>8个: $S_0~S_7$，每个64位</li>
</ul>
</li>
<li>标量保存寄存器(后援寄存器, Scalar-save Register): 用于在标量寄存器和存储器之间提供缓存($T<em>0~T</em>{63}$)</li>
</ul>
</li>
<li>我国自主研发的第一台大型向量计算机“757”机</li>
</ul>
</li>
<li><p>阵列 vs 向量</p>
<ul>
<li>数据并行性<ul>
<li>阵列计算机以数据并行为主，将任务分配给多个处理器，每个处理器独立执行相同操作的不同数据元素。每个处理器通过独立处理多个数据元素来实现并行计算</li>
<li>向量计算机则通过执行相同的操作来同时处理大型连续数据向量，具有更高的数据并行性(感觉是不用大规模的处理器间通信)</li>
</ul>
</li>
<li>硬件架构<ul>
<li>阵列计算机通常是通过大量的相同处理器节点组成的，每个节点都有自己的本地存储器，可以独立访问和处理数据</li>
<li>向量计算机则具有特殊的硬件向量寄存器，可以在单个指令周期内同时处理整个向量。它们通常具有更高的数据带宽和更强大的浮点性能</li>
</ul>
</li>
<li>编程模型<ul>
<li>阵列计算机通常使用数据并行语言或库来编写程序，例如MATLAB和CUDA等。程序员需要显式地指定数据元素之间的并行性和通信操作(用的还是普通指令集？)</li>
<li>向量计算机有专门的向量指令集和编程模型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h4><ul>
<li>单指令流和多线程流</li>
<li>SIMT是一种并行计算中使用的模型，主要是将SIMD与多线程结合在一起，广泛应用于GPU(图形处理器)上的计算单元中<ul>
<li>GPU拥有实时图形应用编程接口<ul>
<li>使用点、线、三角形来表示物体的表面</li>
<li>使用图形处理流水线将物体表面的内部表示转换为一个像素的数组(该像素数组可以在屏幕上显示)</li>
<li>流水线的许多阶段是可编程的，通过着色函数(shader)来说明</li>
</ul>
</li>
<li>GPU使用SIMD并行来优化性能<ul>
<li>对邻近元素使用相同的着色函数，等同于使用相同的控制流</li>
</ul>
</li>
<li>GPU严重依赖硬件多线程<ul>
<li>避免内存访问的延迟</li>
</ul>
</li>
<li>GPU不是纯粹的SIMD系统<ul>
<li>在一个给定的核上ALU使用了SIMD并行</li>
<li>GPU有很多个核，每个核都能独立执行指令流(多线程)</li>
</ul>
</li>
</ul>
</li>
<li>与SIMD相比<ul>
<li>更灵活<ul>
<li>SIMT允许一条指令的多数据分开寻址，而 SIMD 是必须连续在一起的片段</li>
<li>SIMT 可以支持编写线程级的并行代码，而 SIMD 不支持编写线程级的代码</li>
</ul>
</li>
<li>SIMD中的向量中元素相互之间可以自由通信(因为是取自相同的地址空间，元素是连续的？)</li>
<li>SIMT中的每个线程的寄存器都是私有的，线程之间只能通过共享内存和同步机制进行通信<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SIMT.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="MISD"><a href="#MISD" class="headerlink" title="MISD"></a>MISD</h4><ul>
<li>多指令流和单数据流</li>
<li>有人认为这种类型的计算机至今都未出现也有其他人认为有一些类似的例子，例如共享内存的多处理器系统和计算机中的流水线结构<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MISD.png" alt="img"></li>
</ul>
<h4 id="MIMD"><a href="#MIMD" class="headerlink" title="MIMD"></a>MIMD</h4><ul>
<li>多指令流和多数据流: 每个处理器有自己的指令流，也可和其他处理器共享指令流，对自己的数据进行处理</li>
<li>多处理器(多核)，多计算机系统</li>
<li>应用最广泛的并行体系结构，现代流行的并行处理结构都可以划分为这一类<ul>
<li>超算、计算机集群、分布式系统、多处理器计算机和多核计算机<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MIMD.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>分类的对象主要是控制驱动方式下的串行处理和并行处理计算机，对于非控制驱动方式的计算机不适合</li>
<li>把两个不同等级的功能并列对待导致MISD计算机不存在(存疑，有争议)</li>
<li>分类太粗，对流水线处理机的划分不明确，如标量流水线为SISD，向量流水线为SIMD</li>
</ul>
<h3 id="Flynn分类法扩展"><a href="#Flynn分类法扩展" class="headerlink" title="Flynn分类法扩展"></a>Flynn分类法扩展</h3><ul>
<li>根据不同的CPU是如何组织和共享内存的，将MIMD机器继续分类<ul>
<li>共享式内存</li>
<li>分布式内存</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Flynn1.png" alt="img"></p>
<h4 id="共享式内存-Shared-Memory"><a href="#共享式内存-Shared-Memory" class="headerlink" title="共享式内存(Shared Memory)"></a>共享式内存(Shared Memory)</h4><ul>
<li>处理器之间共享内存，通过共享内存通信(所有处理器都通过软件或硬件的方式连接到一个全局可用的存储器)</li>
<li>所谓共享内存就是将所有的存储器抽象成一个整体地址<ul>
<li>即使物理上是分布的，但通过互联网或总线连接，可以抽象成逻辑上的全局存储器(主要针对分布式共享内存)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%85%B1%E4%BA%AB%E5%BC%8F%E5%86%85%E5%AD%98.png" alt="img"></li>
</ul>
</li>
<li>集中共享内存系统(Centralized Shared Memory, CSM)<ul>
<li>多处理器系统中处理器数目较少，所以处理器之间能够共享一个集中式的存储器</li>
<li>又称对称多处理器系统(Symmetric Multiprocessors, SMP)<ul>
<li>所有的存储器能够<strong>平等地互相访问</strong>，这就是对称一词的由来</li>
</ul>
</li>
<li>一致存储访问系统(Uniform Memory Access, UMA)<ul>
<li>因为每个处理器都能平等地访问存储器，所以它们<strong>访问存储器的延迟都是相同的</strong>，因此又被叫做一致存储访问系统</li>
</ul>
</li>
<li>每个处理器可以拥有<strong>私有内存或高速缓存</strong></li>
<li>多核芯片的集中共享内存系统<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSM1.png" alt="img"></li>
<li>多处理器的集中共享内存系统<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CSM.png" alt="img"></li>
</ul>
</li>
<li>分布式共享内存系统(DSM, 非一致存储器访问系统(NUMA))<ul>
<li>每个处理器都拥有自己的存储器，也可以访问其他节点的存储器<ul>
<li>所有的处理器都能访问一个单一的地址空间</li>
<li>使用<code>LOAD</code>和<code>STORE</code>指令访问远程内存</li>
</ul>
</li>
<li>非一致存储访问系统(Non-Uniform Memory Access)<ul>
<li>每个结点访问本地内存和访问其它结点的远程内存的延迟是不同的</li>
<li>访问远程内存比访问本地内存延迟要高</li>
</ul>
</li>
<li>每个处理器可以使用高速缓存</li>
<li>NC-NUMA(不带缓存)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/NC_NUMA.png" alt="img"></li>
<li>CC-NUMA(带缓存)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CC_NUMA.png" alt="img"></li>
<li>利用分布式共享内存技术，可以把几十个甚至上百个 CPU 集中在一台计算机中</li>
<li>目前几乎所有的多核心多处理器系统采用这种方式<ul>
<li>华为鲲鹏处理器</li>
<li>多路服务器</li>
</ul>
</li>
<li>但这种技术需要在处理器之间的数据传送和同步上花费更多的资源，因此设计的协议规则也更加复杂，需要在软件层面进行专门设计以充分提升分布式共享内存的带宽</li>
</ul>
</li>
</ul>
<h4 id="分布式内存-Distributed-Memory-也称为基于消息驱动Message-passing的计算机"><a href="#分布式内存-Distributed-Memory-也称为基于消息驱动Message-passing的计算机" class="headerlink" title="分布式内存(Distributed Memory, 也称为基于消息驱动Message-passing的计算机)"></a>分布式内存(Distributed Memory, 也称为基于消息驱动Message-passing的计算机)</h4><ul>
<li>处理器之间不共享内存，通过消息驱动通信<ul>
<li>对于要共享的数据，必须作为消息从一个处理器传递到另一个处理器</li>
<li>如果两个处理器之间没有运行软件协议加以辅助，那么无法互相访问数据</li>
</ul>
</li>
<li>在这种计算机体系结构中，每台计算机使用消息机制（如以太网）连接起来</li>
<li>每台计算机都有自己的处理器，每个处理器都有自己的私有内存，私有内存只提供自己的处理器进行访问。其他的计算机不能直接访问，每个计算机都有自己独立的物理地址空间<ul>
<li>与分布式共享内存不同，分布式共享内存处理器可以互相访问内存<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98.png" alt="img"></li>
</ul>
</li>
<li>大规模并行处理器系统(Massively Parallel Processors, MPP)<ul>
<li>MPP系统是由成百上千台计算机组成的大规模高性能计算机系统<ul>
<li>MPP中一般每个节点可以认为是一个<strong>没有硬盘</strong>的计算机</li>
<li>MPP节点一般只驻留操作系统内核，由一条I/O总线连接到同一个硬盘上面</li>
<li>MPP使用的网络一般情况不是我们使用的高速以太网，它一般使用制造商专有的定制高速通信网络<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/MPP.png" alt="img"></li>
</ul>
</li>
<li>主要应用于科学技术、工程模拟等以计算为主的科研工作中</li>
<li>该系统一般开发困难，价格高，市场有限，是国家和公司综合实力的象征</li>
</ul>
</li>
<li>工作站机群系统(Cluster Of Workstations, COW)<ul>
<li>仓库级计算机 (Workstations Cluster)</li>
<li>由大量的家用计算机或者工作站通过商用网络连接在一起而构成的多计算机系统<ul>
<li>COW中每个节点都可以认为是一台独立的计算机，它们<strong>有自己的硬盘</strong>、CPU、存储器等，在商用网络的协作下组成一个工作站机群系统<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/COW.png" alt="img"></li>
</ul>
</li>
<li>COW 通常由多个服务器阵列排列而成<ul>
<li>服务器阵列是由多个机架排列而成，</li>
<li>机架是容纳服务器、交换机的外壳框架，一个机架上往往有多个服务器，服务器之间通过机架交换机(阵列交换机)进行通信<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/COW1.png" alt="img"></li>
</ul>
</li>
<li>随着云计算的蓬勃发展，COW正在变得越来越重要: 为全世界提供信息技术的基础</li>
<li>但COW的成本极高，它包含了机房、配电与制冷基础设施，服务器和联网设备，一般情况下一个COW能够容纳上万台服务器<ul>
<li>很多大公司的数据中心就是一个典型的例子</li>
</ul>
</li>
</ul>
</li>
<li>根据2018年6月全球超级计算机排行榜Top500名单中，有437台超算采用的是COW架构，另外63台采用的是MPP架构<ul>
<li>前十名中，有6台使用的是MPP架构，中国的神威·太湖之光使用的是MPP架构</li>
</ul>
</li>
<li>部分HPC采用的是COW的架构，但是一般不采用商业互联网和商业芯片，<strong>HPC一般使用定制的芯片和通信网络</strong><ul>
<li>HPC强调<strong>线程级并行或数据级并行</strong>，而COW则强调<strong>请求级并行</strong>，即可能有多个网络请求同时访问一台机器</li>
<li>HPC常常<strong>满负载</strong>持续数周完成大规模运行作业，而COW是面向并发请求的，通常<strong>不会满负载</strong></li>
</ul>
</li>
</ul>
<h3 id="按最大并行度的冯氏分类法"><a href="#按最大并行度的冯氏分类法" class="headerlink" title="按最大并行度的冯氏分类法"></a>按最大并行度的冯氏分类法</h3><h3 id="按并行度和流水线分类"><a href="#按并行度和流水线分类" class="headerlink" title="按并行度和流水线分类"></a>按并行度和流水线分类</h3><h3 id="按控制流和执行流分类"><a href="#按控制流和执行流分类" class="headerlink" title="按控制流和执行流分类"></a>按控制流和执行流分类</h3><h2 id="非冯·诺伊曼体系结构"><a href="#非冯·诺伊曼体系结构" class="headerlink" title="非冯·诺伊曼体系结构"></a>非冯·诺伊曼体系结构</h2><h3 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h3><ul>
<li>单处理机结构，机器以运算器为中心<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png" alt="img"></li>
<li>采用程序存储思想 <ul>
<li>指令和数据无差别的存储在存储器内 <ul>
<li>指令由操作码和操作数组成，都是顺序执行的 </li>
<li>数据以二进制形式表示<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC1.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>软件和硬件完全分离 </li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从本质上讲是<strong>采取串行顺序处理</strong>的工作机制<ul>
<li>即使有关数据已经准备好，也必须逐条执行指令序列</li>
</ul>
</li>
<li>指令与数据在<strong>同一存储器</strong><ul>
<li>在高速运行时，<strong>不能达到同时取指令和取操作数</strong>，从而形成了<strong>传输过程的瓶颈</strong></li>
</ul>
</li>
</ul>
<h3 id="非冯·诺伊曼结构的改造思路"><a href="#非冯·诺伊曼结构的改造思路" class="headerlink" title="非冯·诺伊曼结构的改造思路"></a>非冯·诺伊曼结构的改造思路</h3><ul>
<li>对传统冯·诺依曼机进行改造，如采用多个处理部件形成流水处理</li>
<li>用多个冯·诺依曼机组成多机系统，支持并行算法结构</li>
<li>从根本上改变冯·诺依曼机的控制流驱动方式，如采用数据流</li>
</ul>
<h3 id="非冯·诺伊曼结构计算机典例"><a href="#非冯·诺伊曼结构计算机典例" class="headerlink" title="非冯·诺伊曼结构计算机典例"></a>非冯·诺伊曼结构计算机典例</h3><ul>
<li>归约机和数据流计算机是两种传统的非冯·诺伊曼结构的计算机，而量子计算机和光子计算机是近年来出现的新型计算机，他们从计算机的原理方面有很大的改变，几乎完全不同于冯·诺伊曼体系结构</li>
</ul>
<h4 id="归约机-Reduction-Machine"><a href="#归约机-Reduction-Machine" class="headerlink" title="归约机(Reduction Machine)"></a>归约机(Reduction Machine)</h4><ul>
<li>一种基于函数式语言编程的计算机，可根据表达式中的运算信息处理相应的数据</li>
</ul>
<h4 id="数据流计算机-Data-Flow-Computer"><a href="#数据流计算机-Data-Flow-Computer" class="headerlink" title="数据流计算机(Data Flow Computer)"></a>数据流计算机(Data Flow Computer)</h4><ul>
<li>一种基于数据流的计算机，每条指令的执行都是由数据来驱动的(来了什么数据用什么指令？不是根据指令取数据？)</li>
<li>数据流计算思想回答了 “<strong>一个运算操作能够被执行的充分条件是什么</strong>” 这个科学问题<ul>
<li>即<strong>数据就绪开始计算</strong>，同时提出了用数据流图描述计算任务的具体方法</li>
<li>创新之处就在于打破了传统串行执行指令的思维禁锢 </li>
</ul>
</li>
<li>数据流计算思想给云计算与大数据分析系统领域的编程模型带来了重大变化 <ul>
<li>指令是根据数据的可用性而不是按照严格的控制流顺序来执行的</li>
</ul>
</li>
</ul>
<h4 id="量子计算机-Quantum-Computer"><a href="#量子计算机-Quantum-Computer" class="headerlink" title="量子计算机(Quantum Computer)"></a>量子计算机(Quantum Computer)</h4><ul>
<li>一种基于量子逻辑的计算设备，利用不同量子态来记录状态，并且使用量子算法来操作数据</li>
</ul>
<h4 id="光子计算机-Optical-Computer"><a href="#光子计算机-Optical-Computer" class="headerlink" title="光子计算机(Optical Computer)"></a>光子计算机(Optical Computer)</h4><ul>
<li>以光子替代电子的先进计算机，将光子设备集成到当前的电子计算机中，形成光电混合的系统</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机体系结构</category>
      </categories>
      <tags>
        <tag>高级计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction</title>
    <url>/2024/09/13/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2024-09-13-Introduction/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="The-different-views-of-Internet"><a href="#The-different-views-of-Internet" class="headerlink" title="The different views of Internet"></a>The different views of Internet</h2><h3 id="nuts-and-bolts-view"><a href="#nuts-and-bolts-view" class="headerlink" title="nuts and bolts view"></a>nuts and bolts view</h3><ul>
<li><p>Billions of connected computing devices</p>
<ul>
<li>host：end systems(中央的主机，终端系统)</li>
<li>running network apps at Internets’ edge(边缘网络的应用)</li>
</ul>
</li>
<li><p>Packet switches：forward packets(转发数据包，chunks of data，数据包)</p>
<ul>
<li>routers(路由器)</li>
<li>switches(交换机)</li>
</ul>
</li>
<li><p>Communication links(通信链路)</p>
<ul>
<li>fiber(光纤), copper(铜的双绞线), radio(无线电波), satellite(卫星通信)</li>
<li>transmission rate：bandwidth(带宽)</li>
</ul>
</li>
<li><p>Networks</p>
<ul>
<li>collection of devices, routers, links</li>
<li>managed by an organization</li>
</ul>
</li>
</ul>
<h3 id="service-view"><a href="#service-view" class="headerlink" title="service view"></a>service view</h3><ul>
<li>Infrastructure(基础架构)<ul>
<li>provides services to applications<ul>
<li>Web, streaming video, multimedia teleconferencing(多媒体电话会议), email, games, e-commerce(电子商务), social media, interconnected applicances(互联应用)</li>
</ul>
</li>
<li>provides programming interface to distributed applications(分布式应用的编程接口)<ul>
<li>hooks(句柄，like socket)<ul>
<li>allowing sending/receiving apps to connect to, use Internet transport service</li>
</ul>
</li>
<li>provides service options, analogous to postal service(邮件服务)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Needed-for-Networking"><a href="#Needed-for-Networking" class="headerlink" title="Needed for Networking"></a>Needed for Networking</h2><h3 id="Application-view"><a href="#Application-view" class="headerlink" title="Application view"></a>Application view</h3><ul>
<li>Applications</li>
<li>Application Characteristics</li>
<li>User perceptions(用户感知)</li>
</ul>
<h3 id="Control-view"><a href="#Control-view" class="headerlink" title="Control view"></a>Control view</h3><ul>
<li>Forwarding/Routing Decision(交换策略，路由策略)</li>
<li>Control</li>
<li>Monitoring(监控，如对整个网络的拥塞控制)</li>
<li>Error Reporting(差错控制)</li>
<li>Peer performance matching(流量控制)</li>
</ul>
<h3 id="Data-View"><a href="#Data-View" class="headerlink" title="Data View"></a>Data View</h3><ul>
<li>How Applications are break down into segment/packets/Frame(应用数据如何划分为报文段、分组、帧)</li>
<li>How Segment/Packet/Frame are transfered(如何传输分割好的报文段、分组、帧)</li>
<li>Error Detection/Handling(差错检错和控制)</li>
</ul>
<h2 id="Network-Protocols"><a href="#Network-Protocols" class="headerlink" title="Network Protocols"></a>Network Protocols</h2><ul>
<li>computers(devices) rather than humans is the role of protocols</li>
<li><p>all communication activity in Internet governed by protocols</p>
</li>
<li><p>Protocols define</p>
<ul>
<li>the format, order of message sent and received among network entities(所收发的信息的形式，顺序)</li>
<li>actions taken on msg transmission, receipt(收发时候采取的动作)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机网络</category>
      </categories>
      <tags>
        <tag>高级计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能处理器的并行计算技术</title>
    <url>/2024/10/23/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-23-%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="高性能处理器的并行计算技术"><a href="#高性能处理器的并行计算技术" class="headerlink" title="高性能处理器的并行计算技术"></a>高性能处理器的并行计算技术</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="现代处理器的特征"><a href="#现代处理器的特征" class="headerlink" title="现代处理器的特征"></a>现代处理器的特征</h3><ul>
<li>深度流水线<ul>
<li>十多个功能段的流水线</li>
</ul>
</li>
<li>多功能部件<ul>
<li>多个浮点乘法器、 加法器等</li>
</ul>
</li>
<li>一个时钟周期能够流出多条指令</li>
<li>发掘指令之间的并行性已成为现代处理器性能优化的重要方面</li>
</ul>
<h3 id="指令级并行的技术"><a href="#指令级并行的技术" class="headerlink" title="指令级并行的技术"></a>指令级并行的技术</h3><ul>
<li>软件技术: 循环展开、VLIW…</li>
<li>硬件技术: 分支预测、推测执行、动态调度</li>
</ul>
<h3 id="指令级并行存在的挑战"><a href="#指令级并行存在的挑战" class="headerlink" title="指令级并行存在的挑战"></a>指令级并行存在的挑战</h3><ul>
<li><p>指令之间存在一定的竞争或依赖关系</p>
<h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4></li>
<li><p>多条指令争用同一个功能部件<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9.png" alt="img"></p>
</li>
<li>如Cycle4中的访存和取指冲突<ul>
<li>因为数据和指令都存储在同一个内存中，而内存只有一个端口，不能被同时访问</li>
<li>可通过将L1缓存改造成数据Cache和指令Cache，即将指令和数据分开存储来解决内存争用</li>
<li>可通过分时解决争用问题，如上升沿读取指令，下降沿读取数据</li>
<li>也可通过延迟一个周期再执行指令避开争用情况<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><ul>
<li>数据之间存在真假依赖</li>
<li>数据相关类型<ul>
<li>Read After Write(RAW, 写后读): 真相关，上一个指令的结果作为下一个指令的参数，会造成冒险</li>
<li>Write After Read(WAR, 读后写): 名字相关、反相关，上一个指令的参数位置是下一个指令所输出的位置，不会造成冒险</li>
<li>Write After Write(WAW, 写后写): 名字相关、输出相关，上一个指令输出的位置是下一个指令输出的位置，不会造成冒险(只要中间不会有其他操作)</li>
<li>Read After Read(RAR, 读后读)</li>
</ul>
</li>
<li>数据相关的特性<ul>
<li>传递性: i与j相关，j与h相关，则i与h相关</li>
<li>不一定导致数据冒险(Hazard)<ul>
<li>数据相关是程序的属性</li>
<li>但是否发生冒险还取决于处理器的体系结构和功能部件，只要<strong>合理安排功能部件</strong>就能避免冒险</li>
<li>两条存在相关的指令，在指令序列中如果距离较远，也不会造成冒险(所以<strong>调度指令序列</strong>也能避免冒险)</li>
</ul>
</li>
<li>给出了可发掘的指令级并行的上限<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9.png" alt="img"></li>
</ul>
</li>
<li>数据相关的解决方法<ul>
<li>转发(Forward): 将计算出的结果尽早发送到等待该结果的部件<ul>
<li>例如ALU的运算结果先不访存和写回，直接传递给下一条指令作为运算参数<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E5%AF%B9alu%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="img"></li>
<li>但不能解决所有问题，例如对于load来说，结果在访存阶段结束才能拿到，但下一条指令在阶段结束前就需要该结果作为参数，只能辅以延时等待解决<br><img src="https://github.com/zjn-astonishe/image/blob/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E5%AF%B9load%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png?raw=true" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><ul>
<li>分支语句执行具有不确定性，无法确定后续执行的指令(跳还是不跳)</li>
<li>如果一条指令是否执行依赖于一条分支指令的执行结果，则不能把这条指令提到分支指令之前(否则会不受控于分支结果)</li>
<li>如果一条指令与一个分支指令没有控制相关，则不能把这条指令放在分支指令之后(否则会使这条指令受分支结果控制)</li>
<li>控制冒险在很大程度上限制了指令级并行(决定上限)<ul>
<li>对于典型的MIPS程序，分支频率在15%~25%，平均3~6条指令就有一个分支出现<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="发掘指令级并行的目的"><a href="#发掘指令级并行的目的" class="headerlink" title="发掘指令级并行的目的"></a>发掘指令级并行的目的</h3><ul>
<li>降低程序执行的平均CPI<ul>
<li>$Pipeline\quad CPI = Ideal\quad pipeline\quad CPI + Structural\quad stalls + Data\quad hazard\quad stalls + Control\quad stalls$</li>
<li>最小化冒险发生的可能性</li>
</ul>
</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">I1  FDIV.D  f6,  f6,  f4</span><br><span class="line">I2  FLD     f2,  <span class="number">45</span>(x3)</span><br><span class="line">I3  FMUL.D  f0,  f2,  f4</span><br><span class="line">I4  FDIV.D  f8,  f6,  f2</span><br><span class="line">I5  FSUB.D  f10, f0,  f6</span><br><span class="line">I6  FADD.D  f6,  f8,  f2</span><br></pre></td></tr></table></figure>
<h4 id="数据相关分析"><a href="#数据相关分析" class="headerlink" title="数据相关分析"></a>数据相关分析</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B.png" alt="img"></p>
<ul>
<li>红色代表真相关<ul>
<li>指令I1与指令I4、I5存在写后读(f6)真相关</li>
<li>指令I2与指令I3、I4、I6存在写后读(f2)真相关</li>
<li>指令I3与指令I5存在写后读(f0)真相关</li>
<li>指令I4与指令I6存在写后读(f8)真相关</li>
</ul>
</li>
<li>蓝色代表名字相关、反相关<ul>
<li>指令I4、I5与指令I6存在读后写(f6)反相关</li>
</ul>
</li>
<li>橙色代表输出相关<ul>
<li>指令I1与指令I6存在写后写(f6)输出相关</li>
</ul>
</li>
</ul>
<h4 id="执行顺序分析"><a href="#执行顺序分析" class="headerlink" title="执行顺序分析"></a>执行顺序分析</h4><ul>
<li><p>标准五段流水线的执行顺序</p>
<ul>
<li><p>顺序执行: </p>
<p>clk|1|2|3|4|5|6|7|8|9|10|11<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>in/out|I1|I2|stall|stall|stall|I3|I4|stall|stall|I5|I6</p>
</li>
<li><p>乱序执行: </p>
<p>clk|1|2|3|4|5|6|7|8|9|10|<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>in/out|I2|I1|stall|stall|I3|I4|stall|stall|I5|I6</p>
</li>
</ul>
</li>
<li><p>假定各种指令具有额外延迟</p>
<ul>
<li>相对标准的五段流水线需要额外时钟数，即如果下一条指令想要使用本指令的结果，必须延后几个周期发射</li>
</ul>
<p>Ins|I1|I2|I3|I4|I5|I6<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>Latency|4|1|3|4|1|1</p>
</li>
<li><p>按序发射/按序执行</p>
<p>clk|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>in/out|I1|I2|stall|stall|I1_c|I2_c|I3|I4|stall|I3_c|I5|I4_c|I6|I5_c|I6_c</p>
</li>
<li><p>按序发射/乱序执行</p>
<p>clk|1|2|3|4|5|6|7|8|9|10|11|12|<br>:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:<br>in/out|I1|I2|I2_c|I3|I1_c|I4|I3_c|I5|I5_c|I4_c|I6|I6_c</p>
</li>
</ul>
<h2 id="基于循环展开的指令调度"><a href="#基于循环展开的指令调度" class="headerlink" title="基于循环展开的指令调度"></a>基于循环展开的指令调度</h2><ul>
<li><p>基本假设</p>
<ul>
<li>五段流水线</li>
<li>分支延迟为1个额外时钟</li>
<li>定点计算的额外延迟为0</li>
<li>浮点单元足够多，能够充分流水</li>
</ul>
<p>产生结果指令|等待结果指令|延迟<br>:-:|:-:|:-:<br>FP ALU OP|Another FP ALU OP|3<br>FP ALU OP|Store double|2<br>Load double|FP ALU OP|1<br>Load double|Store double|0<br>FP ALU OP|Load double|1<br>Store double|ADR ALU OP|0<br>Load double|ADR ALU OP|0</p>
</li>
</ul>
<h3 id="循环展开的优势"><a href="#循环展开的优势" class="headerlink" title="循环展开的优势"></a>循环展开的优势</h3><ul>
<li>降低循环条件判断在代码中的比例，因为：<ul>
<li>分支指令本身会带来额外的延迟</li>
<li>分支指令会导致控制冒险</li>
</ul>
</li>
<li>提升循环体内可发掘的指令级并行性<ul>
<li>循环体内指令变多，能够充分占据功能部件</li>
<li>乱序执行调度的余地更大</li>
</ul>
</li>
</ul>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">999</span>; i&gt;=<span class="number">0</span>; i=i<span class="number">-1</span>)</span><br><span class="line">    x[i] = x[i] + s;</span><br><span class="line"></span><br><span class="line">Loop:   fld     f0, <span class="number">0</span>(x1)       <span class="comment">// f0=array element</span></span><br><span class="line">        fadd.d  f4, f0, f2      <span class="comment">// add scalar in f2</span></span><br><span class="line">        fsd     f4, <span class="number">0</span>(x1)       <span class="comment">// store result</span></span><br><span class="line">        addi    x1, x1, <span class="number">-8</span>      <span class="comment">// decrement pointer 8B(per DW)</span></span><br><span class="line">        bne     x1, x2, Loop    <span class="comment">// branch x1 != x2</span></span><br></pre></td></tr></table></figure>
<h4 id="未调度的执行"><a href="#未调度的执行" class="headerlink" title="未调度的执行"></a>未调度的执行</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clock</th>
<th style="text-align:center">Unscheduled</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">fld     f0, 0(x1) </td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Stall</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">fadd.d  f4, f0, f2    // Load后ALU，延迟为1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Stall</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">Stall</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">fsd     f4, 0(x1)     // ALU后Store，延迟为2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">addi    x1, x1, -8    // Store后ADR ALU，延迟为0</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">Stall</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">bne     x1, x2, Loop  // ALU后Load，延迟为1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">Stall                // 分支延迟为1</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>每次循环需要10个时钟周期</li>
<li>有效负荷较少： 只有fld、 fadd、 fsd三条指令<ul>
<li>有效负荷占30%</li>
<li>50%的时钟停顿(优化方案是尽可能消除停顿)</li>
<li>20%的时钟用于循环控制</li>
</ul>
</li>
</ul>
<h4 id="调度执行"><a href="#调度执行" class="headerlink" title="调度执行"></a>调度执行</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Clock</th>
<th style="text-align:center">Unscheduled</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">fld     f0, 0(x1) </td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">addi    x1, x1, -8    // Load后ADR ALU，延迟为0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">fadd.d  f4, f0, f2    // Load后ALU，延迟为1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Stall</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">bne     x1, x2, Loop  // 如果放在上一个Stall，下一次循环的第一条指令会和本次循环最后一条指令冲突？</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">fsd     f4, 8(x1)     // ALU后Store，延迟为2</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>每次循环需要6个时钟周期<ul>
<li>加速比： 10/6=1.67</li>
</ul>
</li>
<li>有效负荷仍然较少： 只有fld、 fadd、 fsd三条指令<ul>
<li>有效负荷占50%(优化方案是尽可能增加有效负荷——循环展开，增加一次循环的操作数)</li>
<li>一个时钟停顿， 占16.67%</li>
<li>两个时钟用于循环控制， 占33.33%(优化方案是减少循环控制开销——循环展开，减少循环的次数)</li>
</ul>
</li>
</ul>
<h4 id="未调度的循环展开"><a href="#未调度的循环展开" class="headerlink" title="未调度的循环展开"></a>未调度的循环展开</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:   fld f0,0(x1)        // 1</span><br><span class="line">        fadd.d f4,f0,f2     // 2,3</span><br><span class="line">        fsd f4,0(x1)        // 4,5,6</span><br><span class="line">        fld f6,8(x1)        // 7</span><br><span class="line">        fadd.d f8,f6,f2     // 8,9</span><br><span class="line">        fsd f8,8(x1)        // 10,11,12</span><br><span class="line">        fld f10,16(x1)      // 13</span><br><span class="line">        fadd.d f12,f10,f2   // 14,15</span><br><span class="line">        fsd f12,16(x1)      // 16,17,18</span><br><span class="line">        fld f14,24(x1)      // 19</span><br><span class="line">        fadd.d f16,f14,f2   // 20,21</span><br><span class="line">        fsd f16,24(x1)      // 22,23,24</span><br><span class="line">        addi x1,x1,32       // 25</span><br><span class="line">        bne x1,x2,Loop      // 26,27</span><br><span class="line">        Stall               // 28</span><br></pre></td></tr></table></figure>
<ul>
<li>展开4次循环，每次循环需要28个时钟周期<ul>
<li>发射14条指令<ul>
<li>12条指令的有效负荷(42.9%)</li>
<li>2个时钟周期用于循环控制(7.1%)</li>
<li>14个时钟周期的停顿(50%)</li>
</ul>
</li>
<li>但需要更多的寄存器</li>
<li>平均每个原始循环7个时钟(28/4)</li>
</ul>
</li>
</ul>
<h4 id="调度的循环展开"><a href="#调度的循环展开" class="headerlink" title="调度的循环展开"></a>调度的循环展开</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:   fld f0,0(x1)        // 1</span><br><span class="line">        fld f6,8(x1)        // 2</span><br><span class="line">        fld f10,16(x1)      // 3</span><br><span class="line">        fld f14,24(x1)      // 4</span><br><span class="line">        fadd.d f4,f0,f2     // 5</span><br><span class="line">        fadd.d f8,f6,f2     // 6</span><br><span class="line">        fadd.d f12,f0,f2    // 7</span><br><span class="line">        fadd.d f16,f14,f2   // 8</span><br><span class="line">        fsd f4,0(x1)        // 9</span><br><span class="line">        fsd f8,8(x1)        // 10</span><br><span class="line">        addi x1,x1,32       // 11</span><br><span class="line">        fsd f12,-16(x1)     // 12</span><br><span class="line">        bne x1,x2,Loop      // 13</span><br><span class="line">        fsd f16,-8(x1)      // 14        </span><br></pre></td></tr></table></figure>
<ul>
<li>每次循环需要14个时钟周期<ul>
<li>发射14条指令<ul>
<li>12条指令的有效负荷，占比85.7%</li>
<li>2个时钟周期用于循环控制(14.3%)</li>
<li>0个时钟周期的停顿</li>
</ul>
</li>
<li>平均每个原始循环3.5个时钟(14/4)</li>
</ul>
</li>
</ul>
<h4 id="Example-Conclusion"><a href="#Example-Conclusion" class="headerlink" title="Example Conclusion"></a>Example Conclusion</h4><ul>
<li>未调度未展开： 10个时钟周期</li>
<li>有调度未展开： 6个时钟周期</li>
<li>未调度有展开： 7个时钟周期</li>
<li>有调度有展开： 3.5个时钟周期</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>确认循环迭代是不相关的， 从而能够展开</li>
<li>使用不同的寄存器， 避免名字相关</li>
<li>去除多余的分支与条件指令， 调整循环终止与迭代代码</li>
<li>分析是否存在关于存储地址的相关性</li>
<li>对代码进行调度</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>代码量显著增长，并由此可能引起频繁的指令缓存缺失(Miss)，因为要存更多的指令在缓存</li>
<li>寄存器消耗较多，并由此可能引起不必要的访存操作</li>
</ul>
<h2 id="基于计分板的指令调度"><a href="#基于计分板的指令调度" class="headerlink" title="基于计分板的指令调度"></a>基于计分板的指令调度</h2><h3 id="静态调度的缺陷"><a href="#静态调度的缺陷" class="headerlink" title="静态调度的缺陷"></a>静态调度的缺陷</h3><ul>
<li>以循环展开为代表的静态调度需要对每个流水段的执行时间有明确的预期</li>
<li>然而实际上，指令执行有很多的不确定性<ul>
<li>同一种指令集体系结构具有不同的组成和实现方式，从而具有不同的微体系结构<ul>
<li>如果流水线不同，针对一种流水线的静态调度难以在另一种流水线上高效执行</li>
<li>不可能要求所有的软件为所有的微体系结构编译出一个可执行文件的版本</li>
</ul>
</li>
<li>一些相关性在编译阶段难以发现<ul>
<li>存储地址带来的相关性</li>
<li>大量的分支指令</li>
</ul>
</li>
<li>一些不可控的额外延迟，例如缓存缺失(miss)</li>
</ul>
</li>
</ul>
<h3 id="基于计分板的动态调度-CDC6600"><a href="#基于计分板的动态调度-CDC6600" class="headerlink" title="基于计分板的动态调度(CDC6600)"></a>基于计分板的动态调度(CDC6600)</h3><h4 id="计分板-ScoreBoard-的结构"><a href="#计分板-ScoreBoard-的结构" class="headerlink" title="计分板(ScoreBoard)的结构"></a>计分板(ScoreBoard)的结构</h4><ul>
<li>记录已发射指令的状态</li>
<li>记录各个寄存器的使用和等待情况</li>
<li>记录各个功能单元的使用和等待情况<ul>
<li>2个乘法器，1个除法器，1个加法器，1个与数据加载器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF%E7%BB%93%E6%9E%84.png" alt="img"></p>
<h4 id="动态调度机制"><a href="#动态调度机制" class="headerlink" title="动态调度机制"></a>动态调度机制</h4><ul>
<li>针对多个功能部件和流水线展开调度</li>
<li>针对RAW相关(写后读，真相关)<ul>
<li>设置数据就绪位，强制等待数据就绪</li>
</ul>
</li>
<li>针对WAR相关(读后写，反相关)<ul>
<li>在一个寄存器被读之前，不允许后续的指令写</li>
</ul>
</li>
<li>针对WAW相关(写后写，输出相关)<ul>
<li>延迟寄存器写回，避免覆盖</li>
</ul>
</li>
</ul>
<h4 id="定义流水线的各个阶段"><a href="#定义流水线的各个阶段" class="headerlink" title="定义流水线的各个阶段"></a>定义流水线的各个阶段</h4><ul>
<li>第一阶段: 发射阶段，负责译码、检查结构冒险(资源争用)<ul>
<li>按指令的原始顺序完成发射</li>
<li>有结构冒险的话，则不能发射</li>
<li>有WAW冒险(输出冒险)的话，也不能发射</li>
</ul>
</li>
<li>第二阶段: 读操作数，在没有冒险时读操作数<ul>
<li>在RAW消除后读操作数</li>
<li>计分板不考虑转发(Forward)，即上一条指令执行的结果不可能转发给下一条指令的操作数寄存器，必须遵循写回</li>
</ul>
</li>
<li>第三阶段: 执行阶段，对操作数进行运算(乱序执行)<ul>
<li>执行指令，并向计分板通知指令执行完成</li>
</ul>
</li>
<li>第四阶段: 写回阶段，写回结果到指定位置(乱序写回)<ul>
<li>在没有WAR冒险时写回结果</li>
</ul>
</li>
</ul>
<h4 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h4><ul>
<li>记录指令状态<ul>
<li>每条已发射指令处于流水线四个阶段的哪个</li>
</ul>
</li>
<li>记录寄存器状态<ul>
<li>记录每个寄存器是否会被某个功能单元写入，如果是，则还要记录将会被哪个功能单元写入</li>
</ul>
</li>
<li>记录功能单元状态  <ul>
<li>记录各个功能单元的使用和等待情况</li>
<li>9个字段的标记<ul>
<li>Busy: 当前单元是否空闲</li>
<li>Op: 当前单元执行的操作</li>
<li>Fi: 目的寄存器</li>
<li>Fj、Fk: 源寄存器的编号</li>
<li>Qj、Qk: 为源寄存器产生数据的功能单元</li>
<li>Rj、Rk: 源寄存器中数据是否就绪的标志位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L.D     F6, 34(R2)</span><br><span class="line">L.D     F2, 45(R3)</span><br><span class="line">MUL.D   F0,  F2, F4</span><br><span class="line">SUB.D   F8,  F2, F4</span><br><span class="line">DIV.D   F10, F0, F6</span><br><span class="line">ADD.D   F6,  F8, F2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一些关于延迟的假设</p>
<ul>
<li>ADD指令: 读到操作数后需要2时钟计算出结果(有一个加法器)</li>
<li>MULTIPLY指令: 读到操作数后需要10时钟计算出结果(有两个乘法器)</li>
<li>DIVIDE指令: 读到操作数后需要40时钟计算出结果(有一个除法器)</li>
<li>Load指令: 只需要1个时钟</li>
</ul>
</li>
<li><p>首先要找出上述指令中的各种相关：</p>
<ul>
<li>RAW相关:<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF%E7%9A%84RAW%E7%9B%B8%E5%85%B3.png" alt="img"> </li>
<li>WAR相关:<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF%E7%9A%84WAR%E7%9B%B8%E5%85%B3.png" alt="img"></li>
</ul>
</li>
<li>初始化计分板，为三个表<ul>
<li>Instruction status: 记录每个时钟周期的指令状态(或者说每个时钟周期流水线的状态)</li>
<li>Functional unit status: 记录每个时钟周期的功能单元状态</li>
<li>Register result status: 记录每个时钟周期的寄存器状态<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="img"></li>
</ul>
</li>
<li>第1个时钟周期<ul>
<li>Instruction status记录发射第1条指令</li>
<li>因为执行的是Load指令，所以Functional unit status记录Integer组件的使用情况，其中目的寄存器是F6，操作数的源寄存器是R2，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes，表示占用。另一个操作数是立即数，不需记录</li>
<li>Register result status记录F6寄存器需要被Integer功能组件写入<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF1.png" alt="img"></li>
</ul>
</li>
<li>第2个时钟周期<ul>
<li>Instruction status记录第1条指令读取操作数。不能发送第2条指令，因为有结构冒险，即第1条指令和第2条指令都是Load指令，都需要访问同一个功能组件(内存)</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF2.png" alt="img"></li>
</ul>
</li>
<li>第3个时钟周期<ul>
<li>Instruction status记录第1条指令处于执行完成阶段。依然不能发送第2条指令，也不能发送第3条指令，因为第3条指令的源操作数需要第2条指令指明，否则不知道该从哪里读取该操作数。</li>
<li>第1条指令操作数的源寄存器R2已不需再使用，因此设置Functional unit status中对应就绪标志位为No</li>
<li>Register result status不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF3.png" alt="img"></li>
</ul>
</li>
<li>第4个时钟周期<ul>
<li>Instruction status记录第1条指令处于写回完成阶段。不过下一周期才能发送后续指令</li>
<li>Functional unit status清空Integer功能组件的使用情况，因为第1条指令的Load已经完成，该时钟周期是要将结果写回指定位置(但是内存依然是被占用的，所以还不能发送第2条指令)</li>
<li>Register result status不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF4.png" alt="img"></li>
</ul>
</li>
<li>第5个时钟周期<ul>
<li>Instruction status记录发射第2条指令，因为第1条指令已经执行完毕，现在不存在结构冒险</li>
<li>因为执行的是Load指令，所以Functional unit status记录Integer组件的使用情况，其中目的寄存器是F2，操作数的源寄存器是R3，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes，表示占用。另一个操作数是立即数，不需记录</li>
<li>Register result status记录F2寄存器需要被Integer功能组件写入，将F6寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF5.png" alt="img"></li>
</ul>
</li>
<li>第6个时钟周期<ul>
<li>Instruction status记录第2条指令读取操作数，发射第3条指令</li>
<li>因为第3条执行的是Mult指令，所以Functional unit status记录Mult1组件的使用情况，其中目的寄存器是F0，一个操作数的源寄存器一个是F2，功能组件Integer尚未为此寄存器产生数据，因此设置就绪标志位为No。另一个操作数的源寄存器是F4，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes，表示占用</li>
<li>Register result status记录F0寄存器需要被Mult1功能组件写入<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF6.png" alt="img"></li>
</ul>
</li>
<li>第7个时钟周期<ul>
<li>Instruction status记录第2条指令处于执行完成阶段，第3条指令由于源寄存器F2的操作数需要在第2条指令完成写回后才能获得，因此不能进行读取操作数阶段。发射第4条指令</li>
<li>因为第4条执行的是Sub指令，所以Functional unit status记录Add组件的使用情况，其中目的寄存器是F8，一个操作数的源寄存器是F6，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes，表示占用。另一个操作数的源寄存器是F2，功能组件Integer尚未为此寄存器产生数据，因此设置就绪标志位为No。而第2条指令已经读取完了操作数，R3寄存器不需再使用，因此设置就绪标志位为No</li>
<li>Register result status记录F8寄存器需要被Add功能组件写入<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF7.png" alt="img"></li>
</ul>
</li>
<li>第8个时钟周期<ul>
<li>Instruction status记录第2条指令处于写回完成阶段，第3条指令和第4条指令由于源寄存器F2的操作数需要在第2条指令完成写回后才能获得，因此不能进行读取操作数阶段。发射第5条指令</li>
<li>因为第5条指令执行的是Div指令，所以Functional unit status记录Divide组件的使用情况，其中目的寄存器为F10，一个操作数的源寄存器是F0，功能组件Mult1尚未为此寄存器产生数据，因此设置就绪标志位为No。另一个操作数的源寄存器是F6，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes。清空Integer功能组件的使用情况，因为第2条指令的Load已经完成。而Integer已经为F2产生了数据，因此需修改第3条指令和第4条指令对应操作数源寄存器F2的就绪状态为Yes</li>
<li>Register result status记录F10寄存器需要被Divide功能组件写入，将F2寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF8_1.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF8_2.png" alt="img"></li>
</ul>
</li>
<li>第9个时钟周期<ul>
<li>Instruction status记录第3和第4条指令读取操作数(因为操作数源寄存器都已就绪)，第5条指令由于源寄存器F0的操作数需要在第3条指令完成写回后才能获得，因此不能进行读取操作数阶段。第6条指令与第4条指令都需要用到Add功能组件，存在结构冒险而不能发射</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF9.png" alt="img"></li>
</ul>
</li>
<li>第10个时钟周期<ul>
<li>由于第3和第4条指令都已经读取完了操作数，F2、F4、F6寄存器不需再使用，因此Functional unit status设置对应就绪标志位为No</li>
<li>其余两个表不变，因为第3和第4条指令执行需要不止1个时钟周期<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF10.png" alt="img"></li>
</ul>
</li>
<li>第11个时钟周期<ul>
<li>Instruction status记录第4条指令处于执行完成阶段</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF11.png" alt="img"></li>
</ul>
</li>
<li>第12个时钟周期<ul>
<li>Instruction status记录第4条指令处于写回完成阶段(有结构冒险的必须在写回完成后的下一周期才能发射指令)</li>
<li>Functional unit status清空Add功能组件的使用情况，因为第4条指令已经完成。</li>
<li>Register result status将F8寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF12.png" alt="img"></li>
</ul>
</li>
<li>第13个时钟周期<ul>
<li>Instruction status记录发射第6条指令</li>
<li>因为第5条指令执行的是ADD指令，所以Functional unit status记录Add组件的使用情况，其中目的寄存器为F6，一个操作数的源寄存器是F8，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes。另一个操作数的源寄存器是F2，流水线上看不需要依赖任何功能组件，因此设置就绪标志位为Yes。</li>
<li>Register result status记录F6寄存器需要被Add功能组件写入<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF13.png" alt="img"></li>
</ul>
</li>
<li>第14个时钟周期<ul>
<li>Instruction status记录第6条指令读取操作数</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF14.png" alt="img"></li>
</ul>
</li>
<li>第15个时钟周期<ul>
<li>由于第6条指令已经读取完了操作数，F8、F2寄存器不需再使用，因此Functional unit status设置对应就绪标志位为No</li>
<li>其余两个表不变，因为第3和第6条指令执行需要不止1个时钟周期<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF15.png" alt="img"></li>
</ul>
</li>
<li>第16个时钟周期<ul>
<li>Instruction status记录第6条指令处于执行完成阶段</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF16.png" alt="img"></li>
</ul>
</li>
<li>第17个时钟周期<ul>
<li>所有表都不变，因为第5条指令的源寄存器F6处于就绪状态，与第6条指令的目的寄存器现在存在WAR相关，因此在第5条指令读完操作数之前，第6条指令还不能进行写回<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF17.png" alt="img"></li>
</ul>
</li>
<li>第18个时钟周期<ul>
<li>所有表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF18.png" alt="img"></li>
</ul>
</li>
<li>第19个时钟周期<ul>
<li>Instruction status记录第3条指令处于执行完成阶段</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF19.png" alt="img"></li>
</ul>
</li>
<li>第20个时钟周期<ul>
<li>Instruction status记录第3条指令处于写回完成阶段</li>
<li>Functional unit status清空Mult1功能组件的使用情况，因为第3条指令已经完成。且Mult1功能组件已经为第5条指令的操作数源寄存器F0产生了数据，因此修改对就绪标志位为Yes</li>
<li>Register result status将F0寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF20.png" alt="img"></li>
</ul>
</li>
<li>第21个时钟周期<ul>
<li>Instruction status记录第5条指令读取操作数(第6条指令可以进行写回了)</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF21.png" alt="img"></li>
</ul>
</li>
<li>第22个时钟周期<ul>
<li>Instruction status记录第6条指令处于写回完成阶段</li>
<li>Functional unit status清空Add功能组件的使用情况，因为第6条指令已经完成。由于第5条指令已经读取完了操作数，F0、F6寄存器不需再使用，因此设置对应就绪标志位为No</li>
<li>Register result status将F6寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF22.png" alt="img"></li>
</ul>
</li>
<li>第61个时钟周期<ul>
<li>Instruction status记录第5条指令处于执行完成阶段</li>
<li>其余两个表不变<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF61.png" alt="img"></li>
</ul>
</li>
<li>第62个时钟周期<ul>
<li>Instruction status记录第5条指令处于写回完成阶段</li>
<li>Functional unit status清空Divide功能组件的使用情况，因为第5条指令已经完成。</li>
<li>Register result status将F10寄存器状态置空<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E5%88%86%E6%9D%BF62.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><ul>
<li>没有转发(Forward)</li>
<li>没有考虑分支指令，只能处理基本块内的调度，窗口较小</li>
<li>发生结构冒险时，选择不发射指令，但实际是可以发射的，因为有流水线，只需小小延迟</li>
<li>没有对名字相关采取重命名<ul>
<li>等待WAR冒险(改名即可避免)</li>
<li>阻止WAW冒险(改名即可避免)</li>
</ul>
</li>
<li>写寄存器与读该寄存器的数据不能同时进行，需要一个额外时钟(出现写回和读操作数需要两个周期)</li>
</ul>
<h2 id="基于Tomasulo算法的指令调度"><a href="#基于Tomasulo算法的指令调度" class="headerlink" title="基于Tomasulo算法的指令调度"></a>基于Tomasulo算法的指令调度</h2><h3 id="数据相关分析-1"><a href="#数据相关分析-1" class="headerlink" title="数据相关分析"></a>数据相关分析</h3><h4 id="真数据相关-True-Data-Dependence"><a href="#真数据相关-True-Data-Dependence" class="headerlink" title="真数据相关(True Data Dependence)"></a>真数据相关(True Data Dependence)</h4><ul>
<li>只有当指令的操作数可用时，才能执行指令，从而避免RAW冒险</li>
<li>计分板已经提供了解决方法</li>
</ul>
<h4 id="名字相关-Name-Dependence"><a href="#名字相关-Name-Dependence" class="headerlink" title="名字相关(Name Dependence)"></a>名字相关(Name Dependence)</h4><ul>
<li>WAR和WAW冒险实际源于名字相关<ul>
<li>WAR: 读后写的反相关</li>
<li>WAW: 写后写的输出相关</li>
</ul>
</li>
<li>计分板并没有完美解决，选择了不发送指令延时的方法</li>
<li>可以通过寄存器重命名(Register Renaming)消除</li>
</ul>
<h3 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h3><ul>
<li>为IBM 360/91设计的，在CDC 6600(上节的<a href="#基于计分板的动态调度cdc6600">基于计分板的动态调度(CDC6600)</a>)三年之后(1966)<ul>
<li>IBM的每条指令有两个寄存器描述符(register specifiers)，CDC 6600有三个(前者没有结果寄存器？)</li>
<li>IBM有四个浮点寄存器，而CDC 6600有八个</li>
</ul>
</li>
</ul>
<h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><ul>
<li>跟踪操作数何时可用</li>
<li>控制&amp;缓冲器分布于功能部件(FU)与集中于计分板<ul>
<li>功能部件缓冲器称为”保留站(RS)”</li>
<li>用于存放未决的操作数</li>
</ul>
</li>
<li>在硬件中引入寄存器重命名</li>
<li>指令中的寄存器被数值或者指向保留站的指针替代，即寄存器重命名(Register Renaming)<ul>
<li>消除WAR、WAW冒险</li>
<li>保留站比实际寄存器多，因为可以完成优化编译器所不能完成的一些工作结果</li>
<li>从RS直接到FU，无需通过寄存器，而是通过公共数据总线(Common Data Bus)把结果广播到所有FU(如上图)<ul>
<li>Normal data bus(正常数据总线): <ul>
<li>data + destination(“go to” bus)</li>
</ul>
</li>
<li>Common data bus(通用数据总线): <ul>
<li>data + source(“come from” bus)</li>
<li>64 bits of data + 4 bits of Functional Unit source address(源地址)</li>
<li>Write if matches expected Functional Unit(produces result)(与预期功能单元匹配就写入)</li>
<li>Does the broadcast(广播)</li>
</ul>
</li>
</ul>
</li>
<li>载入(Load)和存储(Store)也像其他功能部件一样使用保留站</li>
</ul>
</li>
</ul>
<h4 id="Reservation-stations-RS-保留站"><a href="#Reservation-stations-RS-保留站" class="headerlink" title="Reservation stations(RS, 保留站)"></a>Reservation stations(RS, 保留站)</h4><ul>
<li>Register renaming is provided by reservation stations, contains:</li>
<li>Components<ul>
<li>The instruction(指令)</li>
<li>Buffered operand values(when available)(缓冲的操作数数值)</li>
<li>Reservation station number of instruction providing the operand values(提供操作数数值的指令的保留站编号)</li>
</ul>
</li>
<li>RS fetches and buffers an operand as soon as it becomes available(RS在操作数可用的时候立即获取并缓存该操作数)<ul>
<li>not necessarily involving register file(不一定涉及寄存器文件)</li>
</ul>
</li>
<li>Pending instructions designate the RS to which they will send their output(待定指令指定了它们将要将输出发送到哪个RS)<ul>
<li>Result values broadcast on a result bus, called Common Data Bus(CDB, 结果在结果总线上广播，该总线叫做通用数据总线)</li>
</ul>
</li>
<li>Only the last output updates the register file(只有最后一个输出会更新寄存器文件)</li>
<li>As instructions are issued, the register specifiers are renamed with the reservation station(指令发送后，寄存器说明符将用保留站进行重命名)<ul>
<li>May be more reservation stations than registers(也许保留站甚至比寄存器还要多，因为寄存器名称冲突了才重命名的)</li>
</ul>
</li>
<li><p>Load and store buffers(加载和保存缓存，也就是保留站的工作)</p>
<ul>
<li>Contain data and addresses, act like reservation stations(包括了数据和地址)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo%20Reservation%20Station.png" alt="img"></p>
</li>
</ul>
<h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><ul>
<li>Issue(Sometimes called dispatch调度 in a dynamically scheduled processor)<ul>
<li>Get next instruction from FIFO queue(FIFO队列中获取下一条指令)</li>
<li>If available RS(no structural hazard, 没有结构冒险), issue the instruction to the RS with operand values if avaliable(renames registers)(没有结构冒险就发射指令到RS，如此便能对寄存器进行重命名。如果操作数值可用，则带着操作数)</li>
<li>If operand values not available, stall the instruction(如果操作数值暂时不可用，则暂停该指令)</li>
</ul>
</li>
<li>Execute(执行)<ul>
<li>When operand becomes available, store it in any reservation stations waiting for it(操作数可用时)</li>
<li>When both operands ready, then execute(所有的操作数都就绪，执行它)</li>
<li>If not ready, watch Common Data Bus for result(不就绪，监听通用数据总线等待结果)</li>
</ul>
</li>
<li>Write result(写回)<ul>
<li>Write result on CDB, and from there into registers, reservation stations and store buffers waiting for this result(将结果写道通用数据总线，并从通用数据总线写入目标寄存器、保留站和等待此结果的存储缓冲区)</li>
<li>Stores must wait until store address and value to be stored are available(存储必须等到要存储的数据和存储目标地址可用才能存储)</li>
<li>Mark reservation station available(标记保留站可用)</li>
</ul>
</li>
</ul>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><ul>
<li>保留站中记录的信息<ul>
<li>$Op$: 操作类型 </li>
<li>$Busy$: 是否占用</li>
<li>$V_j$, $V_k$: 源操作数的值(已经就绪的源操作数才能保留在此)</li>
<li>$Q_j$, $Q_k$: 如果源操作数的值尚未就绪，该部分指向操作数的值依赖保留站中的哪一项<ul>
<li>当值为0的时候，说明操作数已经就绪了</li>
<li>对于一个源操作数，V和Q只有一个有效</li>
</ul>
</li>
<li>$A$: Load、Store指令对应的地址<ul>
<li>如果地址还未算出来，则保留立即数</li>
<li>如果地址已经算出来，则保留访存目标地址的值</li>
</ul>
</li>
</ul>
</li>
<li>寄存器组保留的信息<ul>
<li>$Q_i$: 第i号寄存器的值由哪个保留站计算出来的</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L.D     F6, 34(R2)</span><br><span class="line">L.D     F2, 45(R3)</span><br><span class="line">MUL.D   F0,  F2, F4</span><br><span class="line">SUB.D   F8,  F2, F4</span><br><span class="line">DIV.D   F10, F0, F6</span><br><span class="line">ADD.D   F6,  F8, F2</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化<ul>
<li>Instruction status: 记录指令所处状态</li>
<li>Load/Buffers: 缓存指令的操作数</li>
<li>Reservation Station: 记录操作数状态</li>
<li>Register result status: 记录寄存器状态<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="img"></li>
</ul>
</li>
<li>第1个时钟周期<ul>
<li>Instruction status: 发射第1条指令</li>
<li>Load/Buffers: 缓存第1条指令的操作数，所占位置设置为Busy</li>
<li>Reservation Station: 暂时为空</li>
<li>Register result status: 记录寄存器F6需要等待来自Buffer中Load1的结果<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo1.png" alt="img"></li>
</ul>
</li>
<li>第2个时钟周期<ul>
<li>Instruction status: 由于有缓冲区的存在，可以不管结构冒险发射第2条指令，即使和第一条指令可能会争用内存。(即可以发送多条Load指令)</li>
<li>Load/Buffers: 缓存第2条指令的操作数，所占位置Busy设置为Yes</li>
<li>Reservation Station: 暂时为空</li>
<li>Register result status: 记录寄存器F2需要等待来自Buffer中Load2的结果<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo2.png" alt="img"></li>
</ul>
</li>
<li>第3个时钟周期<ul>
<li>Instruction status: 发射第3条指令，第1条指令执行完毕(可以在CDB广播该结果)</li>
<li>Load/Buffers: 为空，不需要缓存操作数</li>
<li>Reservation Station: 记录第3条指令占用乘法器Mult1进行乘法操作，第1个操作数来自寄存器F2的值还未就绪，需要来自第2条指令的写回结果，因此在$Q_j$记录该操作数在Buffer的来源，第2个操作数则已就绪写在$V_k$(操作数都保留在此，寄存器F4和F2不需要使用)</li>
<li>Register result status: 记录寄存器F0需要等待来自第3条指令的乘法器Mult1的计算结果<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo3.png" alt="img"></li>
</ul>
</li>
<li>第4个时钟周期<ul>
<li>Instruction status: 发射第4条指令，第1条指令写回完成，第2条指令执行完成(可以在CDB广播该结果)</li>
<li>Load/Buffers: 第1条指令占据的位置可以空出来了，Busy设置为No</li>
<li>Reservation Station: 记录第4条指令占用加法器Add1进行减法操作，因为第1个操作数来自第1条指令的结果，而第1条指令已经写回，则在$V_j$表示就绪(其中A1为第1条指令里的地址)。第2个操作数来自寄存器F2的值还未就绪，需要来自第2条指令的写回结果，因此在$Q_k$记录该操作数在Buffer的来源</li>
<li>Register result status: 记录寄存器F8需要等待来自第4条指令的加法器Add1的计算结果，记录F6寄存器已取得写回结果(A1为第1条指令里的地址)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo4.png" alt="img"></li>
</ul>
</li>
<li>第5个时钟周期<ul>
<li>Instruction status: 发射第5条指令，第2条指令写回完成，第3、4条指令此时操作数才能就绪，尚未执行完成</li>
<li>Load/Buffers: 第2条指令占据的位置可以空出来了，Busy设置为No</li>
<li>Reservation Station: 记录第5条指令占用乘法器Mult2进行除法操作，因为第1个操作数来自寄存器F0还未就绪，需要乘法器Mult1写回计算结果，因此在$Q_j$记录该操作数在来源。第2个操作数来自第1条指令的结果，而第1条指令早已经写回，则在$V_k$表示就绪(其中A1为第1条指令里的地址)。由于第2条指令已经完成写回，则需要第2条指令写回结果作为源操作数的第3、4条指令的RS项可以将未就绪改为就绪，并注明来源自写回结果(A2为第2条指令里的地址)，然后两者现在可同时执行，由于没有用到相同的源寄存器，操作数都存在不同RS中，就相当于重命名了。</li>
<li>Register result status: 记录F2寄存器已取得写回结果(A2为第2条指令里的地址)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo5.png" alt="img"></li>
</ul>
</li>
<li>第6个时钟周期<ul>
<li>Instruction status: 发射第6条指令，由上节知道加减需要2个周期完成执行，乘法需要10个周期完成执行，所以第3、4条指令尚未执行完成</li>
<li>Load/Buffers: 无需改动</li>
<li>Reservation Station: 记录第6条指令占用加法器Add2进行加法操作，因为第1个操作数来自寄存器F8还未就绪，需要加法器Add1写回计算结果，因此在$Q_j$记录该操作数在来源。第2个操作数来自第2条指令的结果，而第2条指令早已经写回，则在$V_k$表示就绪(其中A2为第2条指令里的地址)</li>
<li>Register result status: 记录F6寄存器需要等待来自第6条指令的加法器Add2的计算结果<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo6.png" alt="img"></li>
</ul>
</li>
<li>第7个时钟周期<ul>
<li>Instruction status: 第4条指令执行完成</li>
<li>Load/Buffers: 无需改动</li>
<li>Reservation Station: 无需改动</li>
<li>Register result status: 无需改动<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo7.png" alt="img"></li>
</ul>
</li>
<li>第8个时钟周期<ul>
<li>Instruction status: 第4条指令写回完成</li>
<li>Load/Buffers: 无需改动</li>
<li>Reservation Station: 第4条指令已完成，所以需清空占用的加法器Add1的记录，且因此第6条指令第1个操作数就绪，清空$Q_j$，设置$V_j$(从CDB获得？)</li>
<li>Register result status: 记录F8寄存器从CDB获得的值<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo8.png" alt="img"></li>
</ul>
</li>
<li>第9个时钟周期<ul>
<li>Instruction status: 第3、6条指令在执行，第5条指令在等待，所以无需修改</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo9.png" alt="img"></li>
</ul>
</li>
<li>第10个时钟周期<ul>
<li>Instruction status: 第6条指令执行完成</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo10.png" alt="img"></li>
</ul>
</li>
<li>第11个时钟周期<ul>
<li>Instruction status: 第6条指令写回完成</li>
<li>Load/Buffers: 无需改动</li>
<li>Reservation Station: 第4条指令已完成，所以需清空占用的加法器Add2的记录</li>
<li>Register result status: 记录F6寄存器从CDB获得的值(因为其他操作数都不在寄存器，所以不存在RAW冒险)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo11.png" alt="img"></li>
</ul>
</li>
<li>第12个时钟周期<ul>
<li>Instruction status: 无需修改</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo12.png" alt="img"></li>
</ul>
</li>
<li>第13个时钟周期<ul>
<li>Instruction status: 无需修改</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo13.png" alt="img"></li>
</ul>
</li>
<li>第14个时钟周期<ul>
<li>Instruction status: 无需修改</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo14.png" alt="img"></li>
</ul>
</li>
<li>第15个时钟周期<ul>
<li>Instruction status: 第3条指令执行完成</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo15.png" alt="img"></li>
</ul>
</li>
<li>第16个时钟周期<ul>
<li>Instruction status: 第3条指令写回完成</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 第3条指令已完成，所以需清空占用的乘法器Mult1的记录，且因此第5条指令的第1个操作数就绪，清空$Q_j$，设置$V_j$(从CDB获得？)</li>
<li>Register result status: 记录F0寄存器从CDB获得的值<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo16.png" alt="img"></li>
</ul>
</li>
<li>第17-55个时钟周期<ul>
<li>Instruction status: 由上节知道除法指令要花费48个时钟周期，无需修改</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo55.png" alt="img"></li>
</ul>
</li>
<li>第56个时钟周期<ul>
<li>Instruction status: 第5条指令执行完成</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 无需修改</li>
<li>Register result status: 无需修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo56.png" alt="img"></li>
</ul>
</li>
<li>第57个时钟周期<ul>
<li>Instruction status: 第5条指令写回完成</li>
<li>Load/Buffers: 无需修改</li>
<li>Reservation Station: 第5条指令已完成，所以需清空占用的乘法器Mult2的记录</li>
<li>Register result status: 记录F10寄存器从CDB获得的值<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo57.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>按序发射</li>
<li>乱序执行</li>
<li>乱序完成</li>
</ul>
<h4 id="Tomasulo算法的优势"><a href="#Tomasulo算法的优势" class="headerlink" title="Tomasulo算法的优势"></a>Tomasulo算法的优势</h4><ul>
<li>分布式的冒险检测<ul>
<li>采用分布式的保留站: 每个保留站可以自主判断冒险</li>
<li>CDB的使用: 一个结果被多个功能单元等待，这些功能单元能够同时得到该结果的广播消息，同时记录(如果在寄存器，则只能一个功能单元访问，而总线能够被多个功能单元访问)</li>
</ul>
</li>
<li>能够消除WAW、WAR冒险<ul>
<li>利用保留站可实现寄存器的重命名</li>
<li>WAR: 一旦数据从寄存器读取到保留站，就不再依赖寄存器</li>
<li>WAW: 两条指令的目标寄存器相同，但结果由不同的功能单元等待，则不会出现WAW</li>
</ul>
</li>
</ul>
<h4 id="Tomasulo算法的劣势"><a href="#Tomasulo算法的劣势" class="headerlink" title="Tomasulo算法的劣势"></a>Tomasulo算法的劣势</h4><ul>
<li>主要缺点是复杂度太高<ul>
<li>要求大量的硬件</li>
<li>保留站必须维护一个高速运行和拥且复杂控制逻辑的关联缓冲器</li>
<li>单CDB总线可能也会由性能瓶颈，当太多功能部件共同访问的时候</li>
</ul>
</li>
</ul>
<h4 id="不精确的意外情况"><a href="#不精确的意外情况" class="headerlink" title="不精确的意外情况"></a>不精确的意外情况</h4><ul>
<li>动态地调度过程可能产生不精确的意外情况<ul>
<li>流水线可能已经完成了比异常产生时的指令在程序的顺序上更晚的指令(即先执行后面的指令去了，但前面的指令又异常了)</li>
<li>流水线可能还没完成异常产生时的指令在程序的顺序上之前的指令(即前面的指令还没完成，先执行后面指令，但又异常了)</li>
</ul>
</li>
</ul>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ul>
<li>寄存器较少的体系结构</li>
<li>代码难以调度的场景</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>基于保留站的动态调度<ul>
<li>允许发射很多指令，只要保留站够用</li>
<li>允许将寄存器的旧值保存在保留站，避免WAR冒险</li>
</ul>
</li>
<li>基于保留站的寄存器重命名<ul>
<li>解决寄存器不够用的问题</li>
</ul>
</li>
<li>解决访存时的地址冲突问题<ul>
<li>发射Load、Store指令的时候，仍需要检查是否有关于访存的WAW、WAR</li>
</ul>
</li>
<li>Tomasulo算法在代码执行过程中建立数据流依赖关系图</li>
</ul>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>典型的MIPS程序中，每3-6条指令会出现一条分支指令，使得动态调度的窗口变小</li>
<li>上面几节分享的调度算法都没有涉及分支</li>
<li>指令并行发掘得越多，分支带来的性能损失就越大</li>
</ul>
<h3 id="Branch-Hazards-分支冒险"><a href="#Branch-Hazards-分支冒险" class="headerlink" title="Branch Hazards(分支冒险)"></a>Branch Hazards(分支冒险)</h3><ul>
<li>造成比数据冒险更糟糕的性能损失<ul>
<li>大概10-30%的性能衰减</li>
<li>cycle stall in the pipeline(流水线中的循环等待？)<ul>
<li>在分支后的指令在分支被确认之前就进入了流水线，但分支预测到的实际结果并不需要执行该指令</li>
<li>而且一个分支出错，也会影响下一个分支</li>
</ul>
</li>
</ul>
</li>
<li>需要减少流水线的分支惩罚</li>
</ul>
<h3 id="过去的解决方案"><a href="#过去的解决方案" class="headerlink" title="过去的解决方案"></a>过去的解决方案</h3><h4 id="方案1-freeze-flush-pipeline-冻结或冲洗流水线"><a href="#方案1-freeze-flush-pipeline-冻结或冲洗流水线" class="headerlink" title="方案1: freeze/flush pipeline(冻结或冲洗流水线)"></a>方案1: freeze/flush pipeline(冻结或冲洗流水线)</h4><ul>
<li>保留或删除分支后的任何指令，直到得知分支的目的地(早期方法)</li>
<li>该方案的分支惩罚是固定的，而且不能被软件继续优化减少</li>
</ul>
<h4 id="方案2-预测每个分支都不发生跳转-not-taken-属于静态分支预测"><a href="#方案2-预测每个分支都不发生跳转-not-taken-属于静态分支预测" class="headerlink" title="方案2: 预测每个分支都不发生跳转(not taken, 属于静态分支预测)"></a>方案2: 预测每个分支都不发生跳转(not taken, 属于静态分支预测)</h4><ul>
<li>性能较好但稍微复杂<ul>
<li>只是允许硬件继续运行</li>
</ul>
</li>
<li>需要知道指令什么时候可能会变化状态，以及如何退出(back out)这种改变(也就是要知道什么情况下可能会预测不跳转出现错误，也就是实际要跳转。还要知道如何应对预测错误)<ul>
<li>当分支确实不需要跳转的时候，说明预测成功，继续执行就可以了</li>
<li>当分支是需要跳转的时候，说明预测失败，则需要先重新读取跳转后的指令到PC才能继续执行，也就是说后续指令会慢一个周期(因为目前的下一条指令是不进行跳转的，不能对它进行解码，所以也就延迟了)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/untaken_branch.png" alt="img"></p>
<h4 id="方案3-预测每个分支都要发生跳转-taken-属于静态分支预测"><a href="#方案3-预测每个分支都要发生跳转-taken-属于静态分支预测" class="headerlink" title="方案3: 预测每个分支都要发生跳转(taken, 属于静态分支预测)"></a>方案3: 预测每个分支都要发生跳转(taken, 属于静态分支预测)</h4><ul>
<li>由于是否发生跳转需要在流水线第三阶段的执行阶段才能知道，提前预测需要跳转，则能提前对跳转部分进行解码，也就是有一个时钟周期的提升</li>
</ul>
<h4 id="方案4-延迟分支-Delayed-Branch"><a href="#方案4-延迟分支-Delayed-Branch" class="headerlink" title="方案4: 延迟分支(Delayed Branch)"></a>方案4: 延迟分支(Delayed Branch)</h4><ul>
<li>在早期RISC架构的处理器中使用</li>
<li>无论分支是否需要跳转，都要在分支指令后插入一条指令(但不允许该指令也是个分支指令，否则会含义不清晰，可能是嵌套分支)作为延迟指令，然后才在再下一个指令周期读取分支要执行的指令</li>
<li>缺点<ul>
<li>需要重新定义架构</li>
<li>可能会导致轻微的代码扩展</li>
<li>中断处理变得更困难<ul>
<li>由延迟槽中的指令引起的中断请求必须与”正常”指令引起的中断请求做不同的处理</li>
</ul>
</li>
<li>需要额外的硬件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/delay_branch.png" alt="img"></p>
<h3 id="现在的解决方案-动态分支预测"><a href="#现在的解决方案-动态分支预测" class="headerlink" title="现在的解决方案: 动态分支预测"></a>现在的解决方案: 动态分支预测</h3><ul>
<li>基于程序的行为对分支做出预测</li>
<li>动态分支预测的改进将随着流水线长度的增加而增加，但因此分支延迟也会增加</li>
<li>更好的预测器将产生更好的性能</li>
<li>现代的高性能处理器都有大概15个时钟周期的分支预测失败延迟<ul>
<li>所以预测的准确度是很重要的</li>
</ul>
</li>
</ul>
<h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><ul>
<li>随着流水线变得更深，分支的潜在惩罚提高，过去的方案是不够的</li>
<li>需要更激进的方案来预测分支</li>
</ul>
<h4 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h4><ul>
<li>低成本的静态方案，依赖于编译时获得的可用信息</li>
<li>服从二项分布(要么跳转，要么不跳转)</li>
</ul>
<h4 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h4><ul>
<li>分支历史记录表(BHT, Branch History Table)<ul>
<li>存放在指令cache或由专门硬件实现</li>
</ul>
</li>
<li>分支预测缓冲器(BPB, Branch Prediction Buffer): 预测分支是否发生跳转<ul>
<li>根据同一分支以前是否跳转预测当前执行是否跳转</li>
<li>根据最近的几个分支是否跳转预测当前执行是否跳转</li>
<li>预测的准确度取决于程序的特性和预测缓存的大小(是否有足够多的参考)</li>
</ul>
</li>
<li><p>分支目标缓冲器(BTB, Branch Target Buffer)</p>
<ul>
<li>目的: 在取指IF阶段(译码ID之前)就能知道本指令是否为分支指令，如果是分支指令则知道是否需要转移，如果需要转移则知道转移目标是哪里</li>
<li><p>BTB是一个高速缓存，只用来保存需要跳转的分支指令或者无条件跳转的指令，必要字段包括:</p>
<ul>
<li>分支指令的PC值</li>
<li>要跳转的分支指令的转移地址</li>
<li><p>工作原理</p>
<ul>
<li>在取指阶段，将PC与BTB中的条目比较，看BTB中是否出现当前PC</li>
<li>如果当前PC出现在BTB中， 则返回所保存的转移目标地址<ul>
<li>返回的转移目标地址用于下一条指令取指</li>
<li>如果该指令实际是不需要跳转的，则要在取消转移目标地址的指令执行，重启不跳转指令执行的同时，删除BTB中关于该指令的记录</li>
</ul>
</li>
<li>如果当前PC未出现在BTB中，则根据<code>PC+4</code>取指<ul>
<li>如果该指令实际是要跳转的，则要把转移目标地址和该指令的PC添加到BTB中</li>
</ul>
</li>
<li>于是在分支指令的取指阶段就可以知道转移目标</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/BTB.png" alt="img"></p>
</li>
<li><p>失败的代价:<br>Instruction in BTB|Prediction|Actual branch|Penalty cycle<br>:-:|:-:|:-:|:-:<br>yes|Taken|Taken|0<br>yes|Taken|Not Taken|2<br>yes||Taken|2<br>yes||Not Taken|0</p>
</li>
<li><p>改进:</p>
<ul>
<li>将目标指令也保存在BTB中，于是可在取目标PC的同时，将目标指令也取出来，减少一次访存</li>
<li>记录返回地址，将Call指令的返回地址(下一条指令)记录在一个小的栈中<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/BTB%E4%BC%98%E5%8C%96.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="动态分支预测的基本原理"><a href="#动态分支预测的基本原理" class="headerlink" title="动态分支预测的基本原理"></a>动态分支预测的基本原理</h4><ul>
<li>利用最近的转移发生情况，预测下一次可能发生的转移(也就是看以前这条指令是跳还是不跳)</li>
<li>预测后，在实际发生时验证预测是否成功并调整再下一次的预测</li>
<li>转移发生的历史情况记录在BHT(Branch History Table)</li>
<li>每个表项由分支指令地址的低位作为索引，在IF阶段就可以获取预测位<ul>
<li>也就是不需要在ID进行解码才能获得</li>
<li>低位地址相同的分支指令共享一个表项，由此可能会有冲突</li>
<li>由于仅用于预测，所以不会影响实际的执行结果</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="img"></p>
<h4 id="简单的1位预测器"><a href="#简单的1位预测器" class="headerlink" title="简单的1位预测器"></a>简单的1位预测器</h4><ul>
<li>分支预测缓冲器只有一个预测位: 用于记录单个分支指令最近的一次历史<ul>
<li>只要预测出错就在下一次做相反预测</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1%E4%BD%8D%E9%A2%84%E6%B5%8B%E5%99%A8.png" alt="img"></p>
<h4 id="简单的2位预测器"><a href="#简单的2位预测器" class="headerlink" title="简单的2位预测器"></a>简单的2位预测器</h4><ul>
<li>采用2位记录历史: 与n位预测器效果差不多(也就是说还有3位4位等，但实际效果也没提升多少)<ul>
<li>采用有限状态机记录单个分支是否成功的历史情况</li>
<li>根据状态机的状态做出预测</li>
<li>根据真实分支情况修正预测器<ul>
<li>只有连续失败两次才改变下一次预测的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2%E4%BD%8D%E9%A2%84%E6%B5%8B%E5%99%A8.png" alt="img"></p>
<h4 id="相关预测器-两级预测器-correlating-predictor"><a href="#相关预测器-两级预测器-correlating-predictor" class="headerlink" title="相关预测器(两级预测器, correlating predictor)"></a>相关预测器(两级预测器, correlating predictor)</h4><ul>
<li>用移位寄存器记录最近m个分支指令的转移情况<ul>
<li>转移成功置1，不成功置0</li>
<li>可以寻址$2^m$个预测器，而每个预测器有n位<ul>
<li>如下图的16个预测器，每个预测器2位<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%9B%B8%E5%85%B3%E9%A2%84%E6%B5%8B%E5%99%A81.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>预测器根据分支指令地址低位+寄存器m位(最近全局发生的m次分支)得到的地址查询BPB(Branch Prediction Buffer)从$2^m$个n位预测器中选出一个<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%9B%B8%E5%85%B3%E9%A2%84%E6%B5%8B%E5%99%A82.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%9B%B8%E5%85%B3%E9%A2%84%E6%B5%8B%E5%99%A83.png" alt="img"></li>
<li>相关预测其的表现比单个分支预测的表现好很多，即使单个分支预测能记录所有该分支的跳转历史(局部性原理?)</li>
</ul>
<h4 id="局部预测器-local-predictor"><a href="#局部预测器-local-predictor" class="headerlink" title="局部预测器(local predictor)"></a>局部预测器(local predictor)</h4><ul>
<li>为每个分支设置$2^m$个n位的预测器</li>
<li>根据最近本身分支发生的m次分支从$2^m$个n位预测器中选出一个</li>
</ul>
<h4 id="竞赛预测器-Tournament-predictor"><a href="#竞赛预测器-Tournament-predictor" class="headerlink" title="竞赛预测器(Tournament predictor)"></a>竞赛预测器(Tournament predictor)</h4><ul>
<li>结合了相关预测器和本地预测器<ul>
<li>全局预测器(相关预测)使用最近的分支跳转历史作为索引</li>
<li>本地预测器使用分支地址作为索引(选择哪个预测器)</li>
</ul>
</li>
<li>其实就是单分支预测器和相关预测器分别进行各自的预测，然后用一个二路复用器选择用哪个预测结果作为最终预测结果<ul>
<li>二路复用器相当于一个2位预测器，如果当前选择的结果连续两次出错，就更改下次预测给出预测结果的预测器(所以也是用分支地址作为索引看怎么决定预测器的选择)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AB%9E%E4%BA%89%E9%A2%84%E6%B5%8B%E5%99%A8.png" alt="img"></p>
<h4 id="标记混合预测器-Tagged-Hybrid-Predictors-or-TAGE——Tagged-Geometic-Predictors"><a href="#标记混合预测器-Tagged-Hybrid-Predictors-or-TAGE——Tagged-Geometic-Predictors" class="headerlink" title="标记混合预测器(Tagged Hybrid Predictors, or TAGE——Tagged Geometic Predictors)"></a>标记混合预测器(Tagged Hybrid Predictors, or TAGE——Tagged Geometic Predictors)</h4><ul>
<li>需要为每个分支提供预测器和记录每个分支的跳转历史<ul>
<li>这会导致巨大的记录表，查询会有麻烦</li>
<li>用hash表(hash值由分支地址和分支历史计算出来)解决该问题</li>
<li>不过较长的历史记录可能会导致哈希冲突的机会增加，因此使用多个表(也就是分多个表去查历史)X</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%B7%B7%E5%90%88%E6%A0%87%E8%AE%B0%E9%A2%84%E6%B5%8B%E5%99%A8.png" alt="img"></p>
<h3 id="Intel-Core-i7的分支预测方法"><a href="#Intel-Core-i7的分支预测方法" class="headerlink" title="Intel Core i7的分支预测方法"></a>Intel Core i7的分支预测方法</h3><ul>
<li>综合了三种预测器<ul>
<li>简单的2位预测器</li>
<li>基于全局历史的相关预测器</li>
<li>循环跳出(Loop Exit)预测器<ul>
<li>当一个分支被判断为一个循环时，用一个计数器记录循环次数，也就知道什么时候可能不需要跳转或者需要跳转了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="推测执行"><a href="#推测执行" class="headerlink" title="推测执行"></a>推测执行</h2><h3 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念"></a>基本理念</h3><ul>
<li>推测执行是分支预测的目的所在</li>
<li>假定分支预测永远正确，则按预测结果发射指令</li>
<li>对发射的指令进行动态调度</li>
<li>设计一定的机制容忍预测出现错误</li>
</ul>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><h4 id="分支预测错误"><a href="#分支预测错误" class="headerlink" title="分支预测错误"></a>分支预测错误</h4><ul>
<li>可以按照分支预测执行，但是必须保证分支结果确定之后再提交(也就是不管预测执行，如果预测失败就不提交)</li>
</ul>
<h4 id="精确中断"><a href="#精确中断" class="headerlink" title="精确中断"></a>精确中断</h4><ul>
<li>一条指令发生中断/异常时，其后的指令不能已经提交</li>
</ul>
<h4 id="计分板和Tomasulo算法都不是按序提交"><a href="#计分板和Tomasulo算法都不是按序提交" class="headerlink" title="计分板和Tomasulo算法都不是按序提交"></a>计分板和Tomasulo算法都不是按序提交</h4><ul>
<li>都是按序发射，乱序执行，乱序提交</li>
</ul>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul>
<li>按序发射</li>
<li>乱序执行</li>
<li>按序提交</li>
<li>提交前阻止一切不可逆转的事件<ul>
<li>中断</li>
<li>异常</li>
</ul>
</li>
</ul>
<h3 id="硬件推测执行所需组件"><a href="#硬件推测执行所需组件" class="headerlink" title="硬件推测执行所需组件"></a>硬件推测执行所需组件</h3><ul>
<li>动态分支预测</li>
<li>动态指令调度<ul>
<li>跨基本块的调度</li>
</ul>
</li>
<li>指令推测执行</li>
<li>结果UNDO模块(不提交)</li>
</ul>
<h3 id="按序提交的实现——引入重排序缓存-ROB"><a href="#按序提交的实现——引入重排序缓存-ROB" class="headerlink" title="按序提交的实现——引入重排序缓存(ROB)"></a>按序提交的实现——引入重排序缓存(ROB)</h3><h4 id="回顾Tomasulo算法"><a href="#回顾Tomasulo算法" class="headerlink" title="回顾Tomasulo算法"></a>回顾Tomasulo算法</h4><ul>
<li>指令发射到保留站</li>
<li>保留站动态调度功能单元执行指令</li>
<li>功能单元发送结果到CDB(Common Data Bus)</li>
<li>CDB广播结果</li>
<li>寄存器组乱序提交结果<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Tomasulo.png" alt="img"></li>
</ul>
<h4 id="重排序缓存-Recorder-Buffer-ROB-的各个字段"><a href="#重排序缓存-Recorder-Buffer-ROB-的各个字段" class="headerlink" title="重排序缓存(Recorder Buffer, ROB)的各个字段"></a>重排序缓存(Recorder Buffer, ROB)的各个字段</h4><ul>
<li>指令类型<ul>
<li>分支指令: 无需提交结果</li>
<li>Store指令: 需要写内存</li>
<li>写寄存器指令: 需要写寄存器</li>
</ul>
</li>
<li>目标域<ul>
<li>寄存器编号</li>
<li>内存地址</li>
</ul>
</li>
<li>Value: 值</li>
<li>Ready: 指令是否已经执行完成，随时准备提交</li>
</ul>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>指令发射阶段<ul>
<li>将发射的指令按序保存在ROB中</li>
<li>记录指令的目的寄存器、PC值<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E6%8C%87%E4%BB%A4%E5%8F%91%E5%B0%84.png" alt="img"></li>
</ul>
</li>
<li>指令执行阶段<ul>
<li>将指令执行结果保存在ROB中<ul>
<li>暂时不提交</li>
<li>但可以广播到保留站各个等待该结果的单元中</li>
</ul>
</li>
<li>记录可能发生的中断和异常<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C.png" alt="img"></li>
</ul>
</li>
<li>结果写回阶段<ul>
<li>将ROB头部的指令结果提交<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E7%BB%93%E6%9E%9C%E6%8F%90%E4%BA%A4.png" alt="img"><ul>
<li>写寄存器</li>
<li>写存储器</li>
</ul>
</li>
<li>处理发生的中断和异常<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E7%BB%93%E6%9E%9C%E5%86%99%E5%9B%9E.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="可行优化——重排序缓存-Forwarding-推测执行"><a href="#可行优化——重排序缓存-Forwarding-推测执行" class="headerlink" title="可行优化——重排序缓存+Forwarding+推测执行"></a>可行优化——重排序缓存+Forwarding+推测执行</h4><ul>
<li>将已经确定提交的结果直接Forward到需要该结果的指令<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROBForwarding.png" alt="img"></li>
<li>发射分支指令到ROB<ul>
<li>但须标记这是预测执行的指令</li>
</ul>
</li>
<li>正常执行分支指令<ul>
<li>谨慎提交</li>
</ul>
</li>
<li>分支确定之后决定是否提交<ul>
<li>预测正确<ul>
<li>后续指令都可以提交</li>
</ul>
</li>
<li>预测错误<ul>
<li>清除ROB中的后续指令<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ROB%E4%BC%98%E5%8C%96.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>发射</li>
<li>执行</li>
<li>写结果</li>
<li>提交</li>
</ul>
]]></content>
      <categories>
        <category>高级计算机体系结构</category>
      </categories>
      <tags>
        <tag>高级计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Multimedia</title>
    <url>/2024/09/13/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2024-09-13-Multimedia/</url>
    <content><![CDATA[<h1 id="Multimedia-Networking-多媒体网络"><a href="#Multimedia-Networking-多媒体网络" class="headerlink" title="Multimedia Networking(多媒体网络)"></a>Multimedia Networking(多媒体网络)</h1><h2 id="Composition-of-Multimedia"><a href="#Composition-of-Multimedia" class="headerlink" title="Composition of Multimedia"></a>Composition of Multimedia</h2><ul>
<li><p>audio</p>
<ul>
<li>analog audio signal sampled at constant rate(以恒定速率采样的模拟音频信号)<ul>
<li>telephone：8000 samples/sec<ul>
<li>人声常用的频率范围是500~4000赫兹。</li>
<li>根据采样定理——为采样率设定了一个足够的条件，即采样频率必须大于信号中最高频率的两倍（fs.max &gt; 2fmax）。这样，采样后的数字信号才能完整地保留原始信号中的信息。因此为$4000 * 2 = 8000$</li>
</ul>
</li>
<li>CD music：44100 samples/sec</li>
</ul>
</li>
<li>each sample qunatized<ul>
<li>$2^8 = 256$，each quantized value represented by bits(采用8位来标志所采样品的种类，采用8位二进制数则一共能表示256种)</li>
<li>8000 samples/sec, 256 quantized values means each samples has 8 bits, therefore there are $8000 * 8 = 64000 bps$ in total</li>
</ul>
</li>
<li>receiver converts bits back to analog signal<ul>
<li>some quality reduction(模拟信号转数字信号再转模拟信号的过程中会有质量损失)</li>
</ul>
</li>
</ul>
</li>
<li><p>video is sequence of images displayed at constant rate(images/sec)</p>
<ul>
<li>digital image(数字图像)：array of pixels(像素阵列), each pixel represented by bits</li>
<li>coding：use redundancy(冗余) within and between images to decrease(bits used to encode image)<ul>
<li>spatial(within image)<ul>
<li>instead of sending N values of same color(all purple), send only two values: color value(purple) and number of repeated values(N, number of values)，也就是把相同的值存为值和数量对</li>
</ul>
</li>
<li>temporal(from one image to next)<ul>
<li>instead of sending complete frame at i+1, send only differences from frame(不同帧之传输与上一帧不同的部分)</li>
</ul>
</li>
</ul>
</li>
<li>CBR(constant bit rate)<ul>
<li>固定数据传输速率(video encoding rate fixed)</li>
</ul>
</li>
<li>VBR(variable bit rate)<ul>
<li>video encoding rate changes as amount of spatial, temporal coding changes(视频编码速率随着空间、时间编码量的变化而变化)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Application-types"><a href="#Application-types" class="headerlink" title="Application types"></a>Application types</h2><ul>
<li>streaming, stored audio, video<ul>
<li>streaming(流式)：can begin playout before downloading entire file(在下载全部文件之前也可以播放)</li>
<li>stored(at server，存储)：can transmit faster than audio/video will be rendered(implies storing/buffering at client)，传输速度可能快于音频/视频的渲染速度(意味着在客户端进行存储/缓冲)</li>
</ul>
</li>
<li>conversational voice/video over IP<ul>
<li>interactive nature of human-to=human conversation limits delay tolerance(人类对话的互动性限制了延迟容忍度)</li>
</ul>
</li>
<li>streaming live audio, video(直播)</li>
</ul>
<h2 id="服务质量-QoS-控制"><a href="#服务质量-QoS-控制" class="headerlink" title="服务质量(QoS)控制"></a>服务质量(QoS)控制</h2><ul>
<li>广义的网络服务质量<ul>
<li>考虑方向<ul>
<li>网络性能(主要介绍方向)<ul>
<li>性能相关的QoS参数指标<ul>
<li>带宽</li>
<li>延迟/延迟抖动</li>
<li>分组丢失率</li>
</ul>
</li>
<li>绝对的(确定性的)性能保证<ul>
<li>一条在任意时刻都可以提供100Mbps带宽的网络链路</li>
<li>绝对的带宽保证</li>
</ul>
</li>
<li>概率的(随机的)性能保证<ul>
<li>保证95%的分组的延迟不大于100ms</li>
<li>概率的延迟保证</li>
</ul>
</li>
<li>时间平均的性能保证<ul>
<li>保证一个月中的平均分组丢失率不高于$10^{-5}$</li>
<li>平均的丢失率保证</li>
</ul>
</li>
</ul>
</li>
<li>可用性</li>
<li>可靠性</li>
<li>安全性</li>
</ul>
</li>
<li>控制粒度<ul>
<li>Packet分组级(时间粒度大约1到100微秒)<ul>
<li>分组是互联网QoS控制机制的最小单位</li>
<li>流量调节机制(包括分组分类器、分组标记器和流量整形器)、分组调度机制、主动队列管理机制</li>
</ul>
</li>
<li>分组的往返时间(round trip time)，大约1到100微秒<ul>
<li>基于反馈的控制机制，拥塞控制和流量控制</li>
</ul>
</li>
<li>Session会话级(以秒和分钟为单位)，用户会话持续的时间(会话可以采用各种方式定义)<ul>
<li>准入控制和QoS路由</li>
</ul>
</li>
<li>长期的QoS控制机制<ul>
<li>流量工程、能力规划和服务定价</li>
</ul>
</li>
</ul>
</li>
<li>控制信息<ul>
<li>QoS控制机制使用的控制信息的粒度(granularity)<ul>
<li>根据每流(per-flow)状态对每个用户流进行控制<ul>
<li>采用IP源地址、目的地址、源端口号、目的端口号和协议域进行标识</li>
</ul>
</li>
<li>对流的聚集进行控制<ul>
<li>流聚集有各种方法：每台主机、每个网络前缀、每个服务类别</li>
</ul>
</li>
</ul>
</li>
<li>控制状态的携带者和控制本身的位置<ul>
<li>控制状态的携带者可以是路由器，也可以是分组</li>
<li>控制的位置可以在用户主机、网络边缘路由器或者是网络核心路由器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Streaming-stored-video"><a href="#Streaming-stored-video" class="headerlink" title="Streaming stored video"></a>Streaming stored video</h2><ul>
<li>streaming：<ul>
<li>at some time, client playing out early part of video, while server still sending later part of video</li>
</ul>
</li>
<li>step：<ul>
<li>video recorded(录制)</li>
<li>video sent(发送)</li>
<li>video received played out at client(播放)</li>
</ul>
</li>
<li>challenges<ul>
<li>continuous playout constraint(约束)<ul>
<li>once client playout begins, playback must match original timing(需要符合原始时间)</li>
<li>but network delays are variable(jitter，抖动), so will need client-side buffer to match playout requirements(需要客户端缓存)</li>
</ul>
</li>
<li>client interactivity ：pause(暂停), fast-forward(快进), rewind(回看), jump through video(跳过)</li>
<li>video packets may be lost, retransmitted(丢包重传)</li>
</ul>
</li>
<li>revisited(重放)<ul>
<li>client-side buffering and playout delay(客户端缓存和播放延迟)<ul>
<li>compensate for network-added delay, delay jitter(补偿网络增加的延迟、延迟抖动)</li>
<li>Initial fill of buffer until playout begins at $t_p$(初始时间接收到的帧存储在缓存区，直到缓冲了$t_p$时间后开始播放)</li>
<li>playout begins at $t_p$</li>
<li>buffer fill level varies over time as fill rate $x(t)$ varies and playout rate $r$ is constant(播放速率r恒定，缓冲存填充的速率$x(t)$不同，缓存被填满的时间也不同)</li>
</ul>
</li>
</ul>
</li>
<li>playout buffering(播放缓存)：average fill rate($\overline{X}$), playout rate($r$)<ul>
<li>$\overline{X} &lt; r$<ul>
<li>buffer eventually empties(causing freezing of video playout until buffer again fills)，缓存终究会被清空，播放会停滞直到缓存完全充满</li>
</ul>
</li>
<li>$\overline{X} &gt; r$<ul>
<li>buffer will not empty, provided initial playout delay is large enough to absorb variability in $x(t)$(只要初始播放延迟$t_p$足够大可以应对$x(t)$的变化，则缓存无论如何都不会被清空)<ul>
<li>initial playout delay tradeoff：buffer starvation less likely with large delay, but larger delay until user begins watching(用户观看前的延迟越大，缓存不足的可能性越小)</li>
</ul>
</li>
</ul>
</li>
<li>client-side buffering and playout delay(客户端缓存视频流，并延迟播放): compensate for network-added delay, delay jitter(补偿网络延迟和延迟抖动，采用恒定的服务端视频流发送速率和客户端视频流播放速率)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/playout%20buffering.png" alt="img"></li>
</ul>
</li>
<li>Video Streaming<ul>
<li>stream video traffic: major consumer of Internet bandwidth(流视频流量：互联网带宽的主要消费者)</li>
<li>challenge: <ul>
<li>scale(how to reach 1 Billion users): single mega-video server won’t work(单个大型视频服务器无法满足可扩展，总有上限)</li>
<li>heterogeneity: different users have different capabilities(wired vs. mobile; bandwidth rich vs. bandwidth poor)(异构性：不同的用户具有不同的能力)</li>
</ul>
</li>
<li>solution<ul>
<li>distributed(分布式)</li>
<li>application-level infrastructure(应用程序级基础架构)</li>
</ul>
</li>
</ul>
</li>
<li>challenges<ul>
<li>continuous playout constraint(连续播放的约束): once client playout begins, playback must match original timing(一旦客户端开始播放，播放的时间必须与原始时间相匹配)<ul>
<li>but network delays are variable(jitter), so will need client-side buffer to match playout requirements(网络的延迟由于抖动而变化，需要客户端有缓存匹配播放要求)</li>
</ul>
</li>
<li>client interactivity(客户端的交互): pause, fast-forward(快进), rewind(倒退), jump through video(跳过)</li>
<li>video packets may be lost, retransmitted(视频数据包可能丢包重传)</li>
</ul>
</li>
</ul>
<h3 id="Streaming-multimedia"><a href="#Streaming-multimedia" class="headerlink" title="Streaming multimedia"></a>Streaming multimedia</h3><ul>
<li>UDP<ul>
<li>server sends at rate appropriate for client(服务器以适应客户端的速率发送)<ul>
<li>often:send rate = encoding rate = constant rate(发送速率与编码速率和恒定速率相等)</li>
<li>transmission rate can be oblivious to congestion levels(传输速率可以忽略拥塞程度)</li>
</ul>
</li>
<li>short playout delay(2-5 seconds) to remove network jitter(缩短播放延迟以消除网络抖动)</li>
<li>error recovery: application-level, time permitting(错误恢复：应用级别和时间限制？允许？)</li>
<li>RTP[RFC 2326]: multimedia payload types(多媒体有效负载的类型)</li>
<li>UDP may not go through firewalls(可能通不过防火墙)</li>
</ul>
</li>
<li>HTTP<ul>
<li>multimedia file retrieved via <code>HTTP GET</code>(检索多媒体文件)</li>
<li>send at maximum possible rate under TCP<ul>
<li>Now many applications use HTTP under UDP</li>
</ul>
</li>
<li>fill rate fluctuates due to TCP congestion control, retransmissions(in-order delivery, 重传是为了按顺序交付)<ul>
<li>填充速率因TCP拥塞控制和重传发生波动</li>
</ul>
</li>
<li>larger playout delay: smooth TCP delivery rate(更大的播放延迟，使得TCP传输速率更加平滑)</li>
<li>HTTP/TCP passes more easily through firewalls(更容易通过防火墙)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B.png" alt="img"></li>
</ul>
</li>
<li>DASH(Dynamic, Adaptive Streaming over HTTP, HTTP的动态自适应视频流)<ul>
<li>server<ul>
<li>divides video file into multiple chunks(将视频文件分割成多个块)</li>
<li>each chunk stored, encoded at different rates(每个块存储、编码成不同的速率，满足不同的分辨率4K，2K等)</li>
<li>manifest file: provide URLs for different chunks(manifest file：提供不同的块的URL)</li>
</ul>
</li>
<li>client<ul>
<li>periodically measures server-to-client bandwidth(定期测量服务器到客户端之间的带宽)</li>
<li>consulting manifest, requests one chunk at a time (查询manifest，一次请求一个块)<ul>
<li>chooses maximum coding rate sustainable given current bandwidth(在给定当前带宽的情况下，选择可持续的最大编码速率)</li>
<li>can choose different coding rates at different points in time(depending on available bandwidth at time)在不同的时间点选择不同的编码速率，取决于当前时间可用的带宽</li>
</ul>
</li>
</ul>
</li>
<li>intelligence at client: client determines<ul>
<li>when to request chunk(so that buffer starvation, or overflow does not occur)，为了不让缓存饥饿或者过载发生，需要明确什么时候请求块</li>
<li>what encoding rate to request(higher quality when more bandwidth available)，当拥有更多的带宽可用时，可以获得更高的质量，以此确定编码速率</li>
<li>where to request chunk(can request from URL server that is “close” to client or has high available bandwidth)从更靠近客户端或更高的可用带宽的URL服务器请求块</li>
</ul>
</li>
<li>Streaming video = encoding + DASH + playout buffering<ul>
<li>待编码的部分 + 编码好准备传输的动态自适应HTTP块 + 已接收的播放缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Content-distribution-networks-CDNs"><a href="#Content-distribution-networks-CDNs" class="headerlink" title="Content distribution networks(CDNs)"></a>Content distribution networks(CDNs)</h3><ul>
<li>challenge: how to stream content(selected from millions of videos) to hundreds of thousands of simultaneous users如何从上百万的视频中找出目标发送给成千上万的同时请求的用户</li>
<li>solution<ul>
<li>single, large, “mega-server”(单大服务器)<ul>
<li>problem:<ul>
<li>single point of failure(单点故障，整体瘫痪)</li>
<li>point of network congestion(容易出现拥塞)</li>
<li>long path to distant clients(对于某些客户端距离太远)</li>
<li>multiple copies of video sent over outgoing link(多个用户请求同一文件会出现多个副本，对缓存要求大)</li>
<li>simple but doesn’t scale(可扩展性有限)</li>
</ul>
</li>
</ul>
</li>
<li>store/serve multiple copies of videos at multiple geographically distributed sites(CDN)将视频副本缓存到多个地域分布式服务器<ul>
<li>enter deep: push CDN servers deep into many access networks(CDN服务器放在许多的接入网络中)<ul>
<li>close to users(靠近用户)</li>
<li>Akamai: 240,000 servers deployed in more than 120 countries (2015)</li>
</ul>
</li>
<li>bring home: smaller number(10’s) of larger clusters in POPs near(but not within) access networks(POPs附近更少的大集群接入网络)<ul>
<li>used by Limelight</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CDN: stores copies of content at CDN nodes(CDN结点存储副本)<ul>
<li>suscriber requests content from CDN(从CDN订阅请求)<ul>
<li>directed to nearby copy, retrieves content(指向附近的副本，检索内容)</li>
<li>may choose different copy if network path congested(如果网络拥塞，可以选择其他不同的副本)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>OTT(over the top) challenges: coping with a congested Internet(应对拥塞网络)<ul>
<li>from which CDN node to retrieve content(如何选择检索内容的CDN结点)</li>
<li>viewer behavior in presence of congestion(拥挤情况下该怎么处理)</li>
<li>what content to place in which CDN node(CDN结点里放置什么内容)</li>
</ul>
</li>
<li>Example<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Example%20CDN.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Example%20CDN1.png" alt="img"><ul>
<li>参考DNS获得IP地址的过程，URL是唯一标识，但是可以映射到多个IP地址，根据距离和带宽条件选择最合适的IP地址</li>
</ul>
</li>
</ul>
<h2 id="Voice-over-IP-VoIP"><a href="#Voice-over-IP-VoIP" class="headerlink" title="Voice-over-IP(VoIP)"></a>Voice-over-IP(VoIP)</h2><h3 id="service-of-VoIP"><a href="#service-of-VoIP" class="headerlink" title="service of VoIP"></a>service of VoIP</h3><ul>
<li>end-end-delay requirement(端到端延迟需求)<ul>
<li>needed to maintain “conversational” aspect(需要维持会话)</li>
<li>higher delays noticeable, impair interactivity(高的延迟会很显著，影响到交互)<ul>
<li>小于150 msec: good</li>
<li>大于400 msec: bad</li>
</ul>
</li>
</ul>
</li>
<li>session initialization(会话初始化)<ul>
<li>how does callee advertise IP address, port number, encoding algorithms?(被呼叫者通告IP地址，端口号码，编码算法)</li>
</ul>
</li>
<li>value-addded services(增值服务)<ul>
<li>call forwarding, screening, recoding(呼叫的转发、筛选、解码)</li>
</ul>
</li>
<li>emergency services(紧急服务)<ul>
<li>911</li>
</ul>
</li>
</ul>
<h3 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h3><ul>
<li>speaker’s audio:<ul>
<li>alternating talk spurts: 通话期(终端上行链路发送语音帧或下行链路接收语音帧的时期)<ul>
<li>在通话期时期，达到速率64kbps</li>
<li>pkts(数据包)只在通话期内生成</li>
<li>20 msec的块，用8K 字节/秒的速度发送了160个字节的数据</li>
</ul>
</li>
<li>silent periods(静默期)</li>
</ul>
</li>
<li>application-layer header added to each chunk(每个块都要加应用层头部段)<ul>
<li>chunk + header encapsulated into UDP or TCP segment(再封装进TCP或UDP报文段)</li>
</ul>
</li>
<li>application sends segment into socket every 20 msec during talkspurt(通信期每20 msec发送一次报文段)</li>
</ul>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><ul>
<li>delays: processing, queueing in network(网络中处理和排队的延迟，路由器？), end-system(sender, receiver) delays(收发两端的延迟，也是处理和排队)</li>
<li><p>Delay jitter(延迟抖动)</p>
<ul>
<li>end-to-end delays of two consecutive packets, difference can be more or less than 20 msec(transmission time difference)(连续两个数据包的延迟可能不一样)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/playout%20buffering.png" alt="img"></li>
</ul>
</li>
<li><p>playout delay</p>
<ul>
<li>fixed playout delay(固定播放时延)<ul>
<li>receiver attempts to playout each chunk exactly q msecs after chunk was generated(倾向于在块生成的q msecs后进行播放)<ul>
<li>chunk has time stamp t: play out chunk at t + q</li>
<li>chunk arrives after t + q: data arrives too late for playout, so data “lost”(超时未能播出就是数据丢包)</li>
</ul>
</li>
<li>tradeoff in choosing q: 大则少丢包但实时性差，小则实时性好但丢包多<ul>
<li>large q: less packet loss</li>
<li>small q: better interactive experience<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VoIP%20fixed%20playout.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>adaptive playout delay<ul>
<li>goal: low playout delay and low late loss rate</li>
<li>approach: adaptive playout delay adjustment<ul>
<li>estimate network delay, adjust playout delay at beginning of each talkspurt<ul>
<li>EWMA: exponentially weighted moving average(指数加权移动平均), recall TCP RTT estimate</li>
<li>$d<em>i = (1-\alpha)d</em>{i-1} + \alpha(r_i-t_i)$<ul>
<li>$d_i$: delay estimate after $i^{th}$ packet(第i个包后的延迟估计)</li>
<li>$\alpha$: small constant(e.g. 0.1)</li>
<li>$r_i$: time received，用来测量第i个包的传输延迟</li>
<li>$t_i$: time sent(time stamp)，用来测量第i个包的传输延迟</li>
</ul>
</li>
</ul>
</li>
<li>chunks still played out every 20 msec during talkspurt<ul>
<li>silent periods compressed and elongated(调整静默期的长短，满足分块依然在通信期播放20msec)</li>
</ul>
</li>
<li>also useful to estimate average deviation of delay(评估延迟的平均偏差)<ul>
<li>$v_i = (1-\beta)v{i-1} + \beta(r_i - t_i - d_i)$</li>
</ul>
</li>
<li>每个包都会计算$d_i, v_i$，但是只在通信期开始的时候会使用<ul>
<li>for first packet in talkspurt, playout time is:<ul>
<li>$playout-time_i = t_i + d_i + Kv_i$</li>
</ul>
</li>
</ul>
</li>
<li>剩余数据包则定期播放</li>
</ul>
</li>
<li>接收方判断收到的数据包是否是通信期的第一个数据包<ul>
<li>if no loss, receiver looks at successive timestamps(无丢包看时间戳，最早的是第一个)</li>
<li>with loss possible, receiver must look at both time stamps and sequence numbers(有丢包就还要考虑数据包编号，编号越小越早)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="packet-loss"><a href="#packet-loss" class="headerlink" title="packet loss"></a>packet loss</h3><ul>
<li>network loss: IP datagram lost due to network congestion(router buffer overflow)，拥塞导致的丢包，没有足够空间进行接收</li>
<li>delay loss: IP datagram arrives too late for playout at receiver(时延超出阈值)</li>
<li>loss tolerance(容错): <ul>
<li>depending on voice encoding, loss concealement(取决于音频编码和丢失隐藏)</li>
<li>packet loss rates between 1% and 10% can be tolerated(1%-10%可以接受)</li>
</ul>
</li>
<li>recovery from packet loss<ul>
<li>challenges of retransmission:recover from packet loss given small tolerable delay between original transmission and playout(传输和播放之间延迟较小，还要实现重传)<ul>
<li>each ACK/NAK takes one RTT</li>
</ul>
</li>
<li>alternative: Forward Error Correction(FEC): send enough bits to allow recovery without retransmission(recall two-dimensional parity)，检错后直接在原数据包纠错，不需要进行重传<ul>
<li>simple FEC<ul>
<li>for every group of n chunks, create redundant chunk by exclusive OR-ing n original chunks(异或n个块的数据得到一个冗余块)</li>
<li>send $n + l$ chunks, increase bandwidth by factor $l/n$(所以是牺牲了带宽，不过应该不大)</li>
<li>can reconstruct original n chunks if at most one lost chunk from $n+ l$ chunks, with playout delay</li>
</ul>
</li>
<li>another FEC scheme<ul>
<li>piggyback lower quality stream(备份一个较低质量的流)</li>
<li>send lower resolution audio stream as redundant information(将这个低质量低分辨率的音频流作为下一个包的冗余信息一起发送)</li>
<li>non-consecutive loss: receiver can conceal loss(非连续损失：接收方可以进行隐瞒，因为容易复原，上一个丢了就到下一个冗余取质量较低的。但连续的话就会一起丢了)</li>
<li>generalization: can also append $(n-l)^{st}$ and $(n-2)^{nd}$ low-bit rate chunk(也可以带不止前一个的低质量流冗余，还可以前两个等)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/another%20FEC%20scheme.png" alt="img"></li>
</ul>
</li>
<li>interleaving to conceal loss(交叉掩盖)<ul>
<li>audio chunks divided into smaller units(块再分小块)</li>
<li>packet contains small units from different chunks(打乱小块的顺序组成数据包发送，接收到后在进行重组)</li>
<li>if packet lost, still have most of every original chunk(就是把丢包风险平摊到各个块而非集中到一个块)</li>
<li>no redundancy overhead, but increases playout delay(没有冗余，但是会增加播放时延)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/interleaving%20to%20conceal%20loss.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h3><ul>
<li>use proprietary application layer protocol, 即时通讯软件，专有应用层协议<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/skype.png" alt="img"></li>
<li>P2P components<ul>
<li>clients: Skype peers connect directly to each other for VoIP call<ul>
<li>joins Skype network by contacting SN (IP address cached) using TCP</li>
<li>logs-in (username, password) to centralized Skype login server</li>
<li>obtains IP address for callee from SN, SN overlay, or client buddy list</li>
<li>initiate call directly to callee<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Skype%20client1.png" alt="img"></li>
</ul>
</li>
<li>super nodes(SN): Skype peers with special functions(有特殊功能的对等设备，就像路由器一样负责用户接入工作，与中央服务器联系，边界跨域连接)</li>
<li>overlay network: among SNs to locate SCs(client)(SN之间的网络，边界)</li>
<li>login server：登录服务器，获得peers的资格，才可以直连</li>
<li>NAT<ul>
<li>prevents outside peer from initiating connection to insider peer, but inside peer can initiate connection to outside(也就是连接可以发起，但不能被接受)</li>
<li>relay solution(通过中继可以解决): maintain open connection to SNs, 由SN去实现跨域</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Protocols-for-real-time-conversational-applications-RTP-SIP"><a href="#Protocols-for-real-time-conversational-applications-RTP-SIP" class="headerlink" title="Protocols for real-time conversational applications: RTP, SIP"></a>Protocols for real-time conversational applications: RTP, SIP</h2><h3 id="Real-Time-Protocol-RTP"><a href="#Real-Time-Protocol-RTP" class="headerlink" title="Real-Time Protocol(RTP)"></a>Real-Time Protocol(RTP)</h3><ul>
<li><p>RTP specifies packet structure for packets carrying audio, video data (encapsulated in UDP segments, 传输层封装在UDP中，以下内容加上端口号和IP地址)</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RTP_UDP.png" alt="img"></p>
<ul>
<li>provides payload type identification(like audio encoding)</li>
<li>provides packet sequence numbering</li>
<li>provides time stamping</li>
</ul>
</li>
<li>document: RFC 3550</li>
<li>interoperability: if two VoIP applications run RTP, they may be able to work together(互操作性，可以实现异构共同工作)</li>
<li>QoS<ul>
<li>does not provide any mechanism to ensure timely data delivery or other QoS guarantees(不做保证)</li>
<li>encapsulation only seen at end systems(not by intermediate routers)封装和解封都在终端系统进行。中间路由器不能进行，只提供尽力传输服务，确保及时到达目的地<ul>
<li>routers provide best-effort service, making no special effort to ensure that RTP packets arrive at destination in timely matter</li>
</ul>
</li>
</ul>
</li>
<li>header</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">payload type</th>
<th style="text-align:center">sequence number</th>
<th style="text-align:center">time stamp</th>
<th style="text-align:center">Synchronization SOurce ID</th>
<th style="text-align:center">Miscellaneous fields</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>playload type(7 bits): indicates type of encoding currently being used.(说明目前正在使用的编码方式)  If sender changes encoding during call, sender informs receiver via  payload type field<ul>
<li>Payload type 0: PCM mu-law, 64 kbps</li>
<li>Payload type 3: GSM, 13 kbps</li>
<li>Payload type 7: LPC, 2.4 kbps</li>
<li>Payload type 26: Motion JPEG</li>
<li>Payload type 31: H.261</li>
<li>Payload type 33: MPEG2 video</li>
</ul>
</li>
<li>sequence(16 bits): increment by one for each RTP packet sent(数据包编号，用于检测丢包和重传)<ul>
<li>detect packet loss</li>
<li>restore packet sequence</li>
</ul>
</li>
<li>timestamp field (32 bits long): sampling instant of first byte in this RTP data packet(对每个RTP数据包的第一个字节进行采样)<ul>
<li>for audio, timestamp clock increments by one for each sampling period (e.g., each 125 usecs for 8 KHz sampling clock) 对于音频，增量为1，因为连续采样？</li>
<li>if application generates chunks of 160 encoded samples(每个块160个编码样本), timestamp increases by 160 for each RTP packet when source is active(source是active的时候增加160). Timestamp clock continues to increase at constant rate when source is inactive(inactive的时候以恒定速率增加，就是跟着时钟走？).</li>
</ul>
</li>
<li>SSRC field (32 bits long):  identifies source of  RTP stream. Each stream in RTP session has distinct SSRC(标识RTP流的来源)<ul>
<li>RTSP/RTP programming assignment</li>
</ul>
</li>
<li>build a server that encapsulates stored video frames into RTP packets(RTSP)<ul>
<li>grab video frame, add RTP headers, create UDP segments, send segments to UDP socket</li>
<li>include seq numbers and time stamps</li>
</ul>
</li>
<li>also write client side of RTSP<ul>
<li>issue play/pause commands(播放与暂停)</li>
</ul>
</li>
</ul>
<h3 id="Real-Time-Control-Protocol-RTCP"><a href="#Real-Time-Control-Protocol-RTCP" class="headerlink" title="Real-Time Control Protocol(RTCP)"></a>Real-Time Control Protocol(RTCP)</h3><ul>
<li>works in conjunction with RTP(与RTP协同工作)</li>
<li>each participant in RTP session periodically sends RTCP control packets to all other participants(每个RTP会话的参与者定期向其他参与者发送RTCP控制包)</li>
<li>each RTCP packet contains sender and/or receiver reports(发送者或接收者的报告)<ul>
<li>report statistics useful to  application: <ul>
<li>packets sent, 已发送</li>
<li>packets lost, 丢包</li>
<li>interarrival jitter，到达间隔抖动</li>
</ul>
</li>
</ul>
</li>
<li>feedback used to control performance<ul>
<li>sender may modify its transmissions based on feedback(根据反馈结果调整策略)</li>
</ul>
</li>
<li>multiple multicast senders(多个多播发送方)<ul>
<li>each RTP session: typically a single multicast address; all RTP /RTCP packets belonging to session use multicast address(一个会话的所有RTP/RTCP数据包都是用多播地址)</li>
<li>RTP, RTCP packets distinguished from each other via distinct port numbers(用端口号去区分彼此，因为地址是同样的多播)</li>
<li>to limit traffic, each participant reduces RTCP traffic as number of conference participants increases (随着会话参与者数量增加，每个参与者减少RTCP流量以限制整体流量)</li>
</ul>
</li>
<li>packet types<ul>
<li>receiver report packets:<ul>
<li>fraction of packets lost丢包率, last sequence number最后一个接收到的数据包, average interarrival jitter平均到达间隔抖动</li>
</ul>
</li>
<li>sender report packets: <ul>
<li>SSRC of RTP stream(RTP流的同步信源标识符), current time, number of packets sent, number of bytes sent </li>
</ul>
</li>
<li>source description packets: <ul>
<li>e-mail address of sender, sender’s name, SSRC  of associated RTP stream </li>
<li>provide mapping between the SSRC and the user/host name</li>
</ul>
</li>
</ul>
</li>
<li>synchronization(同步)<ul>
<li>RTCP can synchronize different media streams within a RTP session(同步不同的媒体流) </li>
<li>e.g., videoconferencing app(视频会议应用): each sender generates one RTP stream for video, one for audio. (发送者两个流——视频流和音频流)</li>
<li>timestamps in RTP packets tied to the video, audio sampling clocks时间戳与采样时间相关<ul>
<li>not tied to wall-clock time</li>
</ul>
</li>
<li>each RTCP sender-report packet contains (for most recently generated packet in associated RTP stream):<ul>
<li>timestamp of RTP packet 与wall-clock time无关，与sampling clock相关</li>
<li>wall-clock time for when packet was created</li>
</ul>
</li>
<li>receivers uses association to synchronize playout of audio, video </li>
</ul>
</li>
<li>bandwidth scaling<ul>
<li>RTCP attempts to limit its traffic to 5% of session bandwidth(会话带宽的5%)</li>
<li>example : one sender, sending video at 2 Mbps<ul>
<li>RTCP attempts to limit RTCP traffic to 100 Kbps</li>
<li>RTCP gives 75% of  rate to receivers; remaining 25% to sender<ul>
<li>75 kbps is equally shared among receivers: with R receivers,  each receiver gets to send RTCP traffic at 75/R kbps.</li>
<li>sender gets to send RTCP traffic at 25 kbps. </li>
</ul>
</li>
</ul>
</li>
<li>participant determines RTCP packet transmission period by calculating avg RTCP packet size (across entire session) and dividing by allocated rate(传送周期=平均大小除以被分配到的速率)</li>
</ul>
</li>
</ul>
<h3 id="Session-Initiation-Protocol-SIP-RFC-3261"><a href="#Session-Initiation-Protocol-SIP-RFC-3261" class="headerlink" title="Session Initiation Protocol(SIP, RFC 3261)"></a>Session Initiation Protocol(SIP, RFC 3261)</h3><ul>
<li>long term vision<ul>
<li>all telephone calls, video conference calls take place over Internet</li>
<li>people identified by names or e-mail addresses, rather than by phone numbers</li>
<li>can reach callee (if callee so desire), no matter where callee roams(无论被呼叫者在哪漫游), no matter what IP device callee is currently using(无论被呼叫者使用的是什么IP地址)</li>
</ul>
</li>
</ul>
<h4 id="SIP-service"><a href="#SIP-service" class="headerlink" title="SIP service"></a>SIP service</h4><ul>
<li>SIP provides mechanisms for all setup(SIP建立的机制):<ul>
<li>for caller to let callee know caller wants to establish a call(发起)</li>
<li>so caller, callee can agree on media type, encoding(协商媒体类型和编码)</li>
<li>to end call(终止)</li>
</ul>
</li>
<li>determine current IP address of callee(确定当前被呼叫者的IP地址)<ul>
<li>maps mnemonic identifier to current IP address(将助记标识符与当前IP地址进行映射)</li>
</ul>
</li>
<li>call management(通话管理):<ul>
<li>add new media streams during call(在通话期间添加新的媒体流，如音频流添加视频流)</li>
<li>change encoding during call(通话期间改变编码方式，如高清、超清切换)</li>
<li>invite others(邀请其他人加入通话)</li>
<li>transfer, hold calls(转接和挂断通话)</li>
</ul>
</li>
<li>setting up call<ul>
<li>known IP address<ul>
<li>SIP invite message indicates port number(default: 5060), IP address, encoding prefer to receive(倾向于收到的编码形式)</li>
<li>SIP OK message indicates port number(default: 5060), IP address, preferred encoding(发送的编码形式)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SIP%20setting%20up%20call%20to%20known%20IP%20address.png" alt="img"></li>
</ul>
</li>
<li>codec negotiation<ul>
<li>suppose callee doesn’t have caller’s preference, callee will instead reply with <code>606 Not Acceptable Reply</code>, and listing his encoders. caller can then send new INVITE message, advertising different encoder</li>
</ul>
</li>
<li>reject a call<ul>
<li>callee can reject with replies <code>busy</code>, <code>gone</code>, <code>payment required</code>, <code>forbidden</code></li>
</ul>
</li>
<li>media can be sent over RTP or some other protocol</li>
</ul>
</li>
</ul>
<h4 id="SIP-message"><a href="#SIP-message" class="headerlink" title="SIP message"></a>SIP message</h4><ul>
<li>can be sent over TCP or UDP(UDP不容易穿透防火墙)</li>
<li>uses HTTP message syntax(报文用的HTTP语法)</li>
<li>sdp = session description protocol</li>
<li>Call-ID is unique for every call(呼叫ID是独一无二的)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INVITE sip:bob@domain.com SIP/2.0</span><br><span class="line">Via: SIP/2.0/UDP 167.180.112.24</span><br><span class="line">From: sip:alice@hereway.com</span><br><span class="line">To: sip:bob@domain.com</span><br><span class="line">Call-ID: a2e3a@pigeon.hereway.com</span><br><span class="line">Content-Type: application/sdp</span><br><span class="line">Content-Length: 885</span><br><span class="line"></span><br><span class="line">c=IN IP4 167.180.112.24</span><br><span class="line">m=audio 38060 RTP/AVP 0</span><br></pre></td></tr></table></figure></li>
<li>caller don’t know callee’s IP address of current host, only has callee’s name or e-mail address<ul>
<li>user moves around</li>
<li>DHCP protocol</li>
<li>user has different IP devices(PC, smartphone, car device)</li>
</ul>
</li>
<li>result can be based on<ul>
<li>time of day(daytime or night)</li>
<li>location(workplace or home)</li>
<li>caller(boss or family)</li>
<li>status of callee(busy or available)</li>
</ul>
</li>
</ul>
<h4 id="SIP-registrar-注册"><a href="#SIP-registrar-注册" class="headerlink" title="SIP registrar(注册)"></a>SIP registrar(注册)</h4><ul>
<li>one function of SIP server: registrar</li>
<li>callee starts SIP client, client sends <code>SIP REGISTER</code> message to callee’s registrar server<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REGISTER sip:domain.com SIP/2.0</span><br><span class="line">Via: SIP/2.0/UDP 193.64.210.89</span><br><span class="line">From: sip:bob@domain.com</span><br><span class="line">To: sip:bob@domain.com</span><br><span class="line">Expires: 3600 # 有效时间, 属于软状态(soft state)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SIP-proxy-代理"><a href="#SIP-proxy-代理" class="headerlink" title="SIP proxy(代理)"></a>SIP proxy(代理)</h4><ul>
<li>caller sends invite message to its proxy server(呼叫者向代理服务器发送邀请被呼叫者的消息)<ul>
<li>contains address sip:callee@domain.com(包含被呼叫者的名称或E-Mail地址)</li>
<li>proxy responsible for routing SIP message to callee, possibly through multiple proxies(代理负责转发SIP消息到被呼叫者，可能还要通过多个代理转发)</li>
</ul>
</li>
<li>callee sends response back through same set of SIP proxies(被呼叫者发送回复通过相同的代理路径)</li>
<li>proxy returns callee’s SIP response message to caller(代理再返回给呼叫者)<ul>
<li>contains callee’s IP address(回复消息中包含被呼叫者的IP地址)</li>
</ul>
</li>
<li>SIP proxy analogous to local DNS server plus TCP setup(类似于DNS服务器)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SIP%20example-proxy.png" alt="img"></li>
</ul>
<h4 id="Comparison-with-H-323"><a href="#Comparison-with-H-323" class="headerlink" title="Comparison with H.323"></a>Comparison with H.323</h4><ul>
<li>another signaling protocol for real-time, interactive multimedia</li>
<li>H.323 <ul>
<li>has complete, vertically integrated suite of protocols(完整的、垂直集成的协议套件，固定灵活性差) for multimedia conferencing(多媒体会议), signaling(信号), registration(注册), admission control(准入控制), transport(传输) and codecs(编码)</li>
<li>comes from the ITU(telephony)</li>
</ul>
</li>
<li>SIP <ul>
<li>has single component(单一组件但是很灵活，可以与很多协议组合). Works with RTP, but does not mandate it. Can be combined with other protocols, service</li>
<li>comes from IETF: borrows much of its concepts from HTTP, SIP has Web flavor, H.323 has telephony flavor</li>
<li>uses KISS principle(Keep It Simple Stupid，让中间的传输过程保持简单)，将复杂的功能放在终端</li>
</ul>
</li>
</ul>
<h2 id="network-support-for-multmeida-支持多媒体的网络"><a href="#network-support-for-multmeida-支持多媒体的网络" class="headerlink" title="network support for multmeida(支持多媒体的网络)"></a>network support for multmeida(支持多媒体的网络)</h2>]]></content>
      <categories>
        <category>高级计算机网络</category>
      </categories>
      <tags>
        <tag>高级计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Security</title>
    <url>/2024/10/10/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2024-10-10-Security/</url>
    <content><![CDATA[<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-does-network-security-include"><a href="#What-does-network-security-include" class="headerlink" title="What does network security include"></a>What does network security include</h3><h4 id="confidentiality-保密性，对消息加密"><a href="#confidentiality-保密性，对消息加密" class="headerlink" title="confidentiality(保密性，对消息加密)"></a>confidentiality(保密性，对消息加密)</h4><ul>
<li>research object: sender</li>
<li>but intended receiver should “understand” message contents<ul>
<li>sender encrypts message</li>
<li>receiver decrypts message</li>
</ul>
</li>
</ul>
<h4 id="authentication-身份认证"><a href="#authentication-身份认证" class="headerlink" title="authentication(身份认证)"></a>authentication(身份认证)</h4><ul>
<li>research object: sender, receiver<ul>
<li>want to confirm identity of each other</li>
</ul>
</li>
</ul>
<h4 id="message-integrity-消息完整"><a href="#message-integrity-消息完整" class="headerlink" title="message integrity(消息完整)"></a>message integrity(消息完整)</h4><ul>
<li>research object: sender, receiver<ul>
<li>want to ensure message not altered(in transit, or afterwards) without detection<ul>
<li>attacker may intercept, delete, add message<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF%E6%A8%A1%E5%9E%8B.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="access-and-availability-可访问且可用"><a href="#access-and-availability-可访问且可用" class="headerlink" title="access and availability(可访问且可用)"></a>access and availability(可访问且可用)</h4><ul>
<li>services must be accessible and available to users</li>
</ul>
<h3 id="What-can-a-“bad-guy”-do"><a href="#What-can-a-“bad-guy”-do" class="headerlink" title="What can a “bad guy” do?"></a>What can a “bad guy” do?</h3><ul>
<li>eavesdrop(窃听): intercept message</li>
<li>alter(篡改): actively insert message into connection</li>
<li>impersonation(伪装): can fake(spoof) source address in packet(or any field in packet)</li>
<li>hijacking(劫持): “take over” ongoing connection by removing sender or receiver, inserting himself in place</li>
<li>denial of service(拒绝服务): prevent service from being used by others(like overloading resources, TCP flooding attack)</li>
</ul>
<h3 id="How-is-network-security-different-与普通安全相比"><a href="#How-is-network-security-different-与普通安全相比" class="headerlink" title="How is network security different?(与普通安全相比)"></a>How is network security different?(与普通安全相比)</h3><ul>
<li>From software and crypto(不仅和软件设计相关，还和密码学相关)</li>
<li>“Shared” resource(要进行资源共享)</li>
<li>Often “default open”(网路默认是对所有人开放的)</li>
<li>No built-in security in the beginning(起初就没考虑过安全问题), so it is vulnerable at every layer<ul>
<li>Network-layer(网络层)<ul>
<li>IP-level attack<ul>
<li>If you use IP Address for authentication, it will occur that ‘A’ receives responses from ‘S’, which are actually spoofed packets. But ‘A’ doesn’t know, so it will respond with a TCP Reset(RST) packet which closes the connection</li>
<li>Maybe you can solve it by overflowing the queues of ‘A’ with connection requests, because it is likely that ‘A’ drops the replies from ‘S’.</li>
<li>However, it also causes another attack, such as DDos attack.</li>
</ul>
</li>
<li>Routing attack<ul>
<li>篡改路由转发表</li>
</ul>
</li>
</ul>
</li>
<li>Transport-layer(传输层)<ul>
<li>针对三次握手协议，曾经是序号是从0开始的，所以会被预测。现在已经得到解决，使用随机序号</li>
</ul>
</li>
<li>Application-layer(应用层)<ul>
<li>DNS cache poisoning(利用DNS缓存机制下毒): 在向DNS服务器注册自己的DNS信息的时候附带进去对其他信息的错误重定向，使得用户在访问相关域名的时候被DNS服务器误导到攻击者指定的网站<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%20cache%20poisoning.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Principles-of-cryptography"><a href="#Principles-of-cryptography" class="headerlink" title="Principles of cryptography"></a>Principles of cryptography</h2><h3 id="The-language-of-cryptography"><a href="#The-language-of-cryptography" class="headerlink" title="The language of cryptography"></a>The language of cryptography</h3><ul>
<li>假设有明文$m$，发送方有密钥$K_A$，接收方有密钥$K_B$。则发送方在发送时，用$K_A(m)$对明文进行加密，接收方接收到消息后，用$K_B(K_A(m))$将明文再解密出来</li>
</ul>
<h3 id="How-to-break-an-encryption-scheme"><a href="#How-to-break-an-encryption-scheme" class="headerlink" title="How to break an encryption scheme"></a>How to break an encryption scheme</h3><ul>
<li>cipher-text only attack(只知道密文)<ul>
<li>brute force: search through all keys(暴力破解，通常是穷举法)</li>
<li>statistical analysis(统计分析，例如福尔摩斯小说的跳舞小人)</li>
</ul>
</li>
<li>known-plaintext attack(已知明文攻击)<ul>
<li>根据明文和密文的对应关系(最简单的是解决凯撒加密法)</li>
</ul>
</li>
<li>chosen-plaintext attack(知道部分明文的密文)</li>
</ul>
<h3 id="Simple-encryption-scheme-substitution-cipher"><a href="#Simple-encryption-scheme-substitution-cipher" class="headerlink" title="Simple encryption scheme: substitution cipher"></a>Simple encryption scheme: substitution cipher</h3><ul>
<li>substituting one or more things for another(凯撒加密法)<ul>
<li>encryption key: mapping from set of plaintext’s letters to set of cipher-text’s letters, some even have unique design patterns </li>
</ul>
</li>
</ul>
<h3 id="Symmetric-key-cryptography-对称加密法，对称指的是密钥相不相同"><a href="#Symmetric-key-cryptography-对称加密法，对称指的是密钥相不相同" class="headerlink" title="Symmetric key cryptography(对称加密法，对称指的是密钥相不相同)"></a>Symmetric key cryptography(对称加密法，对称指的是密钥相不相同)</h3><ul>
<li>share same(symmetric) key: $K_S$</li>
<li>It is hard to agree on key in first place and without eavesdrop<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Symmetric%20key%20cryptography.png" alt="img"></li>
</ul>
<h4 id="DES-Data-Encryption-Standard"><a href="#DES-Data-Encryption-Standard" class="headerlink" title="DES: Data Encryption Standard"></a>DES: Data Encryption Standard</h4><ul>
<li>processes data in 64-bit blocks(一次处理64bit明文)</li>
<li>56-bit symmetric key(too simple, just need less than a day be decrypted through brute force)<ul>
<li>3DES: encrypt 3 times with 3 different keys</li>
</ul>
</li>
<li>block cipher with cipher block chaining(分块链式加密)<ul>
<li>initial permutation(交换中轴线分成的左右两边)</li>
<li>16 identical “rounds” of function Application, each using different 48 bits of key<ul>
<li>右侧数据直接复制作为下一层的左侧数据，本层所有数据和56-bit密钥中抽出形成的48-bit新密钥加密运算得到下一轮的右侧数据</li>
</ul>
</li>
<li>final permutation(交换中轴线分成的左右两边)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DES.png" alt="img"></li>
</ul>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/715713979">DES具体算法</a></li>
</ul>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><ul>
<li>processes data in 128 bit blocks(一次处理128bit明文)</li>
<li>128, 192, or 256 bit keys</li>
<li><a href="https://zhuanlan.zhihu.com/p/716048861">AES具体算法</a></li>
</ul>
<h3 id="Public-key-cryptography"><a href="#Public-key-cryptography" class="headerlink" title="Public key cryptography"></a>Public key cryptography</h3><ul>
<li>sender, receiver do not share secret key<ul>
<li>public encryption key known to all</li>
<li>private decryption key known only to receiver</li>
</ul>
</li>
<li>algorithms<ul>
<li>need $K_B^+(\cdot)$ and $K_B^-(\cdot)$: $K_B^-(K_B^+(m)) = m$</li>
<li>given public key $K_B^+$ and should be impossible to compute private key $K_B^-$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Public%20Key.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><ul>
<li>Prerequisite: modular arithmetic<ul>
<li>$x\mod n$: remainder of x when divede by n(求余数)</li>
<li>facts:<ul>
<li>$[(a\mod n)+(b\mod n)]\mod n=(a+b)\mod n$</li>
<li>$[(a\mod n)-(b\mod n)]\mod n=(a-b)\mod n$</li>
<li>$[(a\mod n)<em>(b\mod n)]\mod n=(a</em>b)\mod n$<ul>
<li>$(a\mod n)^d\mod n=a^d\mod n$</li>
</ul>
</li>
<li>$x^y\mod n=x^{y \mod z}\mod n$<ul>
<li>$z = (p-1)(q-1)$ and $n = pq$<ul>
<li>$p$ and $q$ are two large prime numbers</li>
<li>欧拉函数特殊情况: $\phi(n)=n-1$, if n is a prime number</li>
<li><a href="https://zhuanlan.zhihu.com/p/151756874">欧拉函数和欧拉定理</a></li>
<li><a href="https://pages.cs.wisc.edu/~agorenst/rsa.pdf">证明的参考论文</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Converting message into a number<ul>
<li>message is just a bit pattern, and it can be uniquely represented by an integer number, thus, encrypting a message is equivalent to encrypting a number<ul>
<li>to encrypt $m$, we encrypt the corresponding number, which gives a new number(the ciphertext)</li>
<li>$m$ can be converted into binary, and then into decimal</li>
</ul>
</li>
</ul>
</li>
<li>Creating public/private key pair(找一对足够大的互质数)<ul>
<li>choose two large prime numbers $p$, $q$(1024 bits each)</li>
<li>compute $n=pq$, $z=(p-1)(q-1)$</li>
<li>choose $e(e&lt;n)$ that has no common factors with $z$<ul>
<li>$e$, $z$ are relatively prime(相对质数)</li>
</ul>
</li>
<li>choose $d$ such that $ed-1$ is exactly divisible by $z$<ul>
<li>$ed\mod z = 1$</li>
</ul>
</li>
<li>public key is $K_B^+=(n, e)$</li>
<li>private key is $K_B^-=(n, d)$</li>
</ul>
</li>
<li>Encryption: <ul>
<li>$c = m^e\mod n$</li>
</ul>
</li>
<li>Decryption: <ul>
<li>$m = c^d\mod n = (m^e\mod n)^d\mod n = m^{ed}\mod n = m^{(ed\mod z)}\mod n = m\mod n = m$</li>
</ul>
</li>
<li>The result of using public key first, followed by private key is the same as the result of using private key first, followed by public key<ul>
<li>$K_B^-(K_B^+(m)) = m = K_B^+(K_B^-(m))$</li>
</ul>
</li>
<li>RSA is secure<ul>
<li>attacker just know total number $n=pq$ and a number $e$, but they don’t know $p$, $q$, $d$<ul>
<li>factoring a big number is hard</li>
</ul>
</li>
</ul>
</li>
<li>exponentiation in RSA is computationally intensive<ul>
<li>In practice, usinig public key crypto to establish secure connection, then establish second key – symmetric session key $K_S$ – for encrypting data</li>
</ul>
</li>
</ul>
<h2 id="Message-integrity-authentication"><a href="#Message-integrity-authentication" class="headerlink" title="Message integrity, authentication"></a>Message integrity, authentication</h2><ul>
<li>打过来显示的呼叫号码可以作假，但是自己手机打过去的号码是没问题的</li>
</ul>
<h3 id="Attempt-at-authentication-method"><a href="#Attempt-at-authentication-method" class="headerlink" title="Attempt at authentication method"></a>Attempt at authentication method</h3><ul>
<li>无论对消息中的标识加不加密发送，都容易遭受playback attack</li>
<li>采用nonce验证码的形式:<ul>
<li>nonce: number(R) used only once-in-a-lifetime</li>
<li>接收请求方向发送方发送一个验证码，<ul>
<li>发送方根据收到的验证码用两人都知道的密钥加密再发给接收方，由接收方比对<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ap4_0.png" alt="img"></li>
<li>发送方根据收到的验证码用自己的公钥加密发给接收方，接收方向发送方索要公钥后解密比对<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ap5_0.png" alt="img"></li>
</ul>
</li>
<li>由于所有信息都走的互联网(用手机发验证码也许不会？)，中间的攻击者也能收到这些信息，便可假扮双方骗取加密的密钥<ul>
<li>下图表示，攻击者收到Bob发送的$R$，用自己的私钥$K_T$加密$R$后发给Bob，但Bob不知道这个结果不适用正确用户Alice的密钥加密的，于是向攻击者索要公钥$K_T$，解密后当然没问题，Bob就把攻击者当成了Alice，用攻击者的密钥加密了信息，攻击者便窃取了信息。攻击者还可以把接收到的$R$发给Alice，Alice将用自己私钥加密后的$R$发给攻击者，接着攻击者便可向Alice索要公钥$K_A^+$，然后攻击者便可用公钥$K_A^+$加密篡改的消息$m’$假扮Bob发给Alice<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ap5_0_1.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Public-key-certification"><a href="#Public-key-certification" class="headerlink" title="Public-key certification"></a>Public-key certification</h3><ul>
<li>上节的问题会出现是因为Bob并不知道攻击者发送的公钥$K_T$并不是真正用户Alice的公钥$K_A$</li>
</ul>
<h3 id="Certification-authorities-CA"><a href="#Certification-authorities-CA" class="headerlink" title="Certification authorities(CA)"></a>Certification authorities(CA)</h3><ul>
<li>CA: binds public key to particular entity, E.</li>
<li>E(person, router) registers its public key with CA<ul>
<li>E provides “proof of identity” to CA. </li>
<li>CA creates certificate binding E to its public key.</li>
<li>certificate containing E’s public key digitally signed by CA – CA says “this is E’s public key”<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CA.png" alt="img"></li>
<li>when want public key $K_B^+$<ul>
<li>get certificate</li>
<li>apply CA’s public key $K<em>{CA}^+$ to certificate, get public key $K_B^+ = K</em>{CA}^+(K_{CA}^-(K_B^+))$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CA1.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Message-integrity-信息摘要，数字签名-digitally-signs"><a href="#Message-integrity-信息摘要，数字签名-digitally-signs" class="headerlink" title="Message integrity: 信息摘要，数字签名(digitally signs)"></a>Message integrity: 信息摘要，数字签名(digitally signs)</h3><ul>
<li>MD5(王晓云已破解，用另一串文本可以生成一样的MD5码)</li>
<li>SHA</li>
</ul>
<h2 id="Securing-e-mail"><a href="#Securing-e-mail" class="headerlink" title="Securing e-mail"></a>Securing e-mail</h2><h3 id="只加密邮件消息-send-confidential-e-mail"><a href="#只加密邮件消息-send-confidential-e-mail" class="headerlink" title="只加密邮件消息(send confidential e-mail)"></a>只加密邮件消息(send confidential e-mail)</h3><ul>
<li>sender <ul>
<li>generates random symmetric private key $K_S$</li>
<li>encrypts message $m$ with $K_S$(for efficiency)</li>
<li>encrypts $K_S$ with receiver’s public key $K_B^+$</li>
<li>sends both $K_S(m)$ and $K_B^+(K_S)$ to receiver</li>
</ul>
</li>
<li>receiver <ul>
<li>uses its own private key $K_B^-$ to decrypt $K_S$, and then uses $K_S$ to decrypt $m$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Secure%20email1.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="只加密数字签名-send-authentication-message-integrity"><a href="#只加密数字签名-send-authentication-message-integrity" class="headerlink" title="只加密数字签名(send authentication message integrity)"></a>只加密数字签名(send authentication message integrity)</h3><ul>
<li>sender<ul>
<li>digitally signs message $m$ as $H(m)$</li>
<li>encrypts $H(m)$ with its own private key $K_A^-$</li>
<li>sends both message $m$(in the clear) and digital signature $K_A^-(H(m))$</li>
</ul>
</li>
<li>receiver<ul>
<li>uses sender’s public key $K_A^+$ to decrypt $K_A^-(H(m))$</li>
<li>digitally signs received message $m’$ as $H(m’)$</li>
<li>compares whether $H(m) = H(m’)$, if so, then $m=m’$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Secure%20email2.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="两者都需加密-provide-secrecy-sender-authentication-message-integrity"><a href="#两者都需加密-provide-secrecy-sender-authentication-message-integrity" class="headerlink" title="两者都需加密(provide secrecy sender authentication, message integrity)"></a>两者都需加密(provide secrecy sender authentication, message integrity)</h3><ul>
<li>sender<ul>
<li>digitally signs message $m$ as $H(m)$</li>
<li>encrypts $H(m)$ with its own private key $K_A^-$</li>
<li>combine digital signature $K_A^-(H(m))$ and message $m$ together, then encrypts them with a symmetric private key $K_S$ which generates randomly</li>
<li>encrypts $K_S$ with receiver’s public key $K_B^+$</li>
<li>sends both $K_S(K_A^-(H(m))+m)$ and $K_B^+(K_S)$ to receiver</li>
</ul>
</li>
<li>receiver<ul>
<li>uses its own private key $K_B^-$ to decrypt $K_S$, and then uses $K_S$ to decrypt $m’$ and $K_A^-(H(m))$</li>
<li>uses sender’s public key $K_A^+$ to decrypt $K_A^-(H(m))$</li>
<li>digitally signs received message $m’$ as $H(m’)$</li>
<li>compares whether $H(m) = H(m’)$, if so, then $m’=m$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Secure%20email3.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="Securing-TCP-connections-TLS-SSL"><a href="#Securing-TCP-connections-TLS-SSL" class="headerlink" title="Securing TCP connections: TLS/SSL"></a>Securing TCP connections: TLS/SSL</h2><ul>
<li>provides<ul>
<li>confidentiality(保密性)</li>
<li>integrity(完整性)</li>
<li>authentication(认证)</li>
</ul>
</li>
<li>application domain<ul>
<li>Web e-commerce transactions(电子商务)<ul>
<li>minimum hassle in doing business with new merchant</li>
</ul>
</li>
<li>encryption(especially credit-card numbers)</li>
<li>Web-server or optional client authentication</li>
<li>optional client authentication</li>
</ul>
</li>
<li>original goal<ul>
<li>send byte stream &amp; interactive data</li>
<li>set of secret keys for entire connection(该协议用来交换整个连接过程要用到的密钥)</li>
<li>certificate exchange as part of protocol: handshake phase(连接建立握手阶段的互相认证)</li>
<li>available to all TCP applications<ul>
<li>provides application programming interface(API) to applications<ul>
<li>C and Java SSL libraries/classes readily available</li>
</ul>
</li>
<li>secure socket interface(TCP的接口)</li>
</ul>
</li>
</ul>
</li>
<li>SSL适用于TCP协议和HTTP1.0</li>
<li>TLS适用于TCP协议和HTTP2.0，TLS1.0即SSL3.0</li>
<li>QUIC适用于UDP协议和HTTP2.0以上如HTTP3.0，包含了TLS<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSLTLSQUIC.png" alt="img"></li>
</ul>
<h3 id="SSL-Secure-Sockets-Layer-已经基本淘汰"><a href="#SSL-Secure-Sockets-Layer-已经基本淘汰" class="headerlink" title="SSL: Secure Sockets Layer(已经基本淘汰)"></a>SSL: Secure Sockets Layer(已经基本淘汰)</h3><h4 id="Toy-SSL-a-simple-secure-channel-简单模型"><a href="#Toy-SSL-a-simple-secure-channel-简单模型" class="headerlink" title="Toy SSL: a simple secure channel(简单模型)"></a>Toy SSL: a simple secure channel(简单模型)</h4><ul>
<li>handshake: users use their certificates, private keys to authenticate each other and exchange shared secret(互相认证并共享后面要用的某些加密密钥)</li>
<li>key derivation: users use shared secret to derive set of keys(用共享密钥和一些附加信息生成各自的密钥集), through key derivation function(KDF)<ul>
<li>use different keys for message authentication code(MAC) and encryption(前者是消息完整性验证码，后者是加密数据)</li>
<li>$K_c$: encryption key for data sent from client to server </li>
<li>$M_c$: MAC key for data sent from client to server</li>
<li>$K_s$: encryption key for data sent from server to client</li>
<li>$M_s$: MAC key for data sent from server to client</li>
</ul>
</li>
<li>data transfer: data to be transferred is broken up into series of records(将数据分片传输)<ul>
<li>with instant messaging, we cannot do integrity check over all bytes sent before displaying, thus break stream in series of records<ul>
<li>each record carries a MAC</li>
<li>receiver can act on each record as it arrives</li>
</ul>
</li>
<li>use variable-length records to distinguish MAC from data(用长度位确认MAC和数据的分界)</li>
<li>put sequence number into MAC to prevent attacker capturing and re-ordering records<ul>
<li>$MAC = MAC(M_x, sequence || data)$(用密钥$M_x$计算加了编号后的数据的完整性验证码，但要注意传输的数据里不包括序号)</li>
</ul>
</li>
<li>use nonce to prevent attacker capturing and replaying record(一次性验证码) </li>
</ul>
</li>
<li>connection closure: special messages to securely close connection(用特殊的消息来确保安全地关闭连接)<ul>
<li>use record types, with one type for closure to prevent attacker forging TCP connection close segment(truncation attack，用约定好的加密的类型来表示结束)<ul>
<li>$MAC=MAC(M_x, sequence||type||data)$<br>length|type|data|MAC<br>:-:|:-:|:-:|:-:<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ToySSL.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>allow client and server to support different encryption algorithms and to choose together specific algorithm before data transfer(允许自行协商选择加密算法)</li>
</ul>
<h4 id="SSL-cipher-suite-密码套件"><a href="#SSL-cipher-suite-密码套件" class="headerlink" title="SSL cipher suite(密码套件)"></a>SSL cipher suite(密码套件)</h4><ul>
<li>cipher suite: algorithms that can be used for key generation, encryption, MAC, digital signature<ul>
<li>public-key algorithm<ul>
<li>RSA</li>
</ul>
</li>
<li>symmetric encryption algorithm<ul>
<li>DES: block</li>
<li>3DES: block</li>
<li>Rivest Cipher 2: block</li>
<li>Rivest Cipher 4: stream</li>
</ul>
</li>
<li>MAC algorithm</li>
</ul>
</li>
<li>negotiation between client and server<ul>
<li>client offers choice of cipher suite</li>
<li>server picks one </li>
</ul>
</li>
</ul>
<h4 id="Real-SSL"><a href="#Real-SSL" class="headerlink" title="Real SSL"></a>Real SSL</h4><ul>
<li>The purpose of handshake<ul>
<li>server authentication(服务器认证客户端，例如确定客户端的权限)</li>
<li>negotiation: agree on crypto algorithms(协商加密用到的算法)</li>
<li>establish keys(根据选定的算法生成密钥)</li>
<li>client authentication(optional, 可选客户端认证服务器)</li>
</ul>
</li>
<li>The step of handshake <ul>
<li>client sends list of algorithms it supports, along with client nonce(用一次性验证码是避免被攻击者发动重放攻击)<ul>
<li>client typically offers range of algorithms, some strong, some weak</li>
</ul>
</li>
<li>server chooses algorithms from list; sends back: choice + certificate + server nonce</li>
<li>client verifies certificate, extracts server’s public key, generates pre_master_secret, encrypts with server’s public key, sends to server</li>
<li>client and server independently compute encryption and MAC keys from pre_master_secret and nonces(前面是握手时的协商)</li>
<li>client sends a MAC of all the handshake messages to protect handshake from tampering(最后用MAC验证握手消息的完整性，就是用接收到的消息计算MAC，然后发回给服务器，与服务器正确的MAC的比对消息完整性)</li>
<li>server sends a MAC of all the handshake messages to protect handshake from tampering<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Real%20SSL%20connection.png" alt="img"></li>
</ul>
</li>
<li>SSL record protocol<ul>
<li>record header<ul>
<li>content type</li>
<li>version</li>
<li>length</li>
</ul>
</li>
<li>data fragment<ul>
<li>each SSL data fragment has $2^14(16K)$bytes </li>
</ul>
</li>
<li>MAC<ul>
<li>calculated by sequence number, MAC key $M_x$, and data fragment<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSL%20record%20protocol.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>SSL record format<ul>
<li>data and MAC use symmetric algorithm to be encrypted</li>
<li>record header don’t need to be encrypted<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSL%20record%20format.png" alt="img"></li>
</ul>
</li>
<li>key derivation<ul>
<li>client nonce, server nonce, and pre-master secret input into pseudo random-number generator to produce master secret(共享密钥的生成)</li>
<li>master secret and new nonces input into another random-number generator: “key block”(工作密钥集合)</li>
<li>key block sliced and diced(将工作密钥集按照顺序和长度划分各个要用到的密钥)<ul>
<li>client MAC key</li>
<li>server MAC key</li>
<li>client encryption key</li>
<li>server encryption key</li>
<li>client initialization vector (IV)</li>
<li>server initialization vector (IV)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TLS-Transport-layer-security"><a href="#TLS-Transport-layer-security" class="headerlink" title="TLS: Transport-layer security"></a>TLS: Transport-layer security</h3><ul>
<li>is a widely deployed security protocol above the transport layer<ul>
<li>supported by almost all browsers, web servers: https(port 443)</li>
</ul>
</li>
<li>provides<ul>
<li>confidentiality: via symmetric encryption</li>
<li>integrity: via cryptographic hashing</li>
<li>authentication: via public key cryptography</li>
</ul>
</li>
</ul>
<h4 id="Toy-TLS"><a href="#Toy-TLS" class="headerlink" title="Toy TLS"></a>Toy TLS</h4><ul>
<li>handshake<ul>
<li>B establishes TCP connection with A</li>
<li>B verifies that A is really A</li>
<li>B sends A a master secret key(MS), used to generate all other keys for TLS session</li>
<li>potential issues: 3 RTT before client can start receiving data(including TCP handshake)(时延太长)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/t-tls%20handshake.png" alt="img"></li>
</ul>
</li>
<li>cryptographic keys<ul>
<li>like <a href="#toy-ssl-a-simple-secure-channel简单模型">SSL</a></li>
</ul>
</li>
<li>encrypting data<ul>
<li>like <a href="#toy-ssl-a-simple-secure-channel简单模型">SSL</a></li>
<li>but record encrypted using symmetric key, $Kc$, passed to TCP:$K_c(length||type||data||MAC)$</li>
</ul>
</li>
<li>connection close<ul>
<li>like <a href="#toy-ssl-a-simple-secure-channel简单模型">SSL</a></li>
<li>For example: type 0 for data, type 1 for close</li>
</ul>
</li>
</ul>
<h4 id="TLS-1-3-cipher-suite"><a href="#TLS-1-3-cipher-suite" class="headerlink" title="TLS:1.3 cipher suite"></a>TLS:1.3 cipher suite</h4><ul>
<li>TLS: 1.3 (2018): more limited cipher suite choice than TLS 1.2 (2008)<ul>
<li>only 5 choices, rather than 37 choices(5种加密算法选择？)</li>
<li>requires Diffie-Hellman (DH) for key exchange, rather than DH or RSA(密钥交换的方法)</li>
<li>combined encryption and authentication algorithm (“authenticated encryption”) for data rather than serial encryption, authentication<ul>
<li>4 based on AES</li>
</ul>
</li>
<li>HMAC uses SHA (256 or 284) cryptographic hash function(MAC使用的是SHA)</li>
<li><a href="https://www.rfc-editor.org/rfc/rfc8446">rfc8446</a></li>
</ul>
</li>
<li>handshake<ul>
<li>1 RTT<ul>
<li>client TLS hello msg: <ul>
<li>guesses key agreement protocol, parameters</li>
<li>indicates cipher suites it supports</li>
</ul>
</li>
<li>server TLS hello msg chooses <ul>
<li>key agreement protocol, parameters</li>
<li>cipher suite</li>
<li>server-signed certificate</li>
</ul>
</li>
<li>client:<ul>
<li>checks server certificate</li>
<li>generates key</li>
<li>can now make application request (e.g.., HTTPS GET)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1RTT.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>0 RTT<ul>
<li>initial hello message contains encrypted application data!<ul>
<li>“resuming” earlier connection between client and server (恢复早期连接)</li>
<li>application data encrypted using “resumption master secret” from earlier connection</li>
</ul>
</li>
<li>vulnerable to replay attacks!(对于重放攻击来说很脆弱)<ul>
<li>maybe OK for get HTTP GET or client requests not modifying server state<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0RTT.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Network-layer-security-IPSec-Routing"><a href="#Network-layer-security-IPSec-Routing" class="headerlink" title="Network layer security: IPSec, Routing"></a>Network layer security: IPSec, Routing</h2><h3 id="Network-layer-security"><a href="#Network-layer-security" class="headerlink" title="Network layer security"></a>Network layer security</h3><ul>
<li>between two network entities:<ul>
<li>sending entity encrypts datagram payload(发送实体加密的数据负载), payload could be:<ul>
<li>TCP or UDP segment, ICMP message, OSPF message</li>
</ul>
</li>
<li>all data sent from one entity to other would be hidden<ul>
<li>web pages, e-mail, P2P file transfer, TCP SYN packets</li>
</ul>
</li>
</ul>
</li>
<li>blanket coverage</li>
</ul>
<h3 id="Virtual-Private-Networks-VPNs"><a href="#Virtual-Private-Networks-VPNs" class="headerlink" title="Virtual Private Networks(VPNs)"></a>Virtual Private Networks(VPNs)</h3><ul>
<li>motivation:<ul>
<li>insinstitutions often want private networks for security(机构需求拥有安全的内网)<ul>
<li>costly: separate routers, links, DNS infrastructure.(如果使用单独的专有设备去实现会很昂贵，因此采用软件实现的虚拟的私密内网)</li>
</ul>
</li>
<li>institution’s inter-office traffic is sent over public Internet instead(机构间的通信需要经过公网)</li>
</ul>
</li>
<li>implementation: <ul>
<li>encrypted before entering public Internet(在进入公网前进行加密)</li>
<li>logically separate from other traffic(逻辑上与其他流分开，方便后续解密)</li>
</ul>
</li>
<li>其实就是在终端或者网关上安装一个软件，以实现不在内网时依然可以通过公网访问内网</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN.png" alt="img"></p>
<h3 id="IPSec-services"><a href="#IPSec-services" class="headerlink" title="IPSec services"></a>IPSec services</h3><ul>
<li>including<ul>
<li>data integrity(数据完整性)</li>
<li>origin authentication(认证)</li>
<li>replay attack prevention(防止重放攻击)</li>
<li>confidentiality(保密性)</li>
</ul>
</li>
<li>transport mode<ul>
<li>IPsec datagram emitted and received by end-system(端到端发送和接收IPsec数据报)</li>
<li>protects upper level protocols(保护网络层及上层的协议)</li>
</ul>
</li>
<li>IPsec protocols<ul>
<li>Authentication Header (AH) Protocol: provides source authentication and data integrity but not confidentiality</li>
<li>Encapsulation Security Protocol(ESP): provides source authentication, data integrity, and confidentiality(more widely used than AH, 因为AH不支持保密性)</li>
</ul>
</li>
<li>tunneling mode(隧道模式)<ul>
<li>edge routers IPsec-aware(在边缘路由器上实现IPsec)<ul>
<li>tunnel mode with ESP(most common and most important)</li>
<li>tunnel mode with AH</li>
</ul>
</li>
<li>hosts IPsec-aware(在终端主机实现IPsec)<ul>
<li>host mode with ESP</li>
<li>tunnel mode with AH</li>
</ul>
</li>
</ul>
</li>
<li>IPsec peers can be <ul>
<li>two end systems, </li>
<li>two routers/firewalls, </li>
<li>a router/firewall and an end system</li>
</ul>
</li>
</ul>
<h4 id="Security-associations-SAs"><a href="#Security-associations-SAs" class="headerlink" title="Security associations(SAs)"></a>Security associations(SAs)</h4><ul>
<li>before sending data, “security association(SA)” established from sending to receiving entity(在发送数据之前要先在发送方和接收方之间建立SA)<ul>
<li>SAs are simplex: for only one direction(单向的，只有从发送者到接收者)</li>
</ul>
</li>
<li>ending, receiving entitles maintain state information about SA<ul>
<li>recall: TCP endpoints also maintaain state info</li>
<li>IP is connectionless while IPsec is connection-oriented(IP不是面向连接的，IPsec则是面向连接的)</li>
</ul>
</li>
<li>Example SA from R1 to R2(R1 stores for SA)<ul>
<li>32-bit SA identifier: Security Parameter Index(SPI, 32位的SA标识)</li>
<li>origin SA interface(200.168.1.100, 发送方的边缘路由接口)</li>
<li>destination SA interface(193.68.2.23, 接收方的边缘路由接口)</li>
<li>type of encryption used(like 3DES with CBC, 加密算法)</li>
<li>encryption key(加密密钥)</li>
<li>type of integrity check used(like HMAC with MD5, 数据完整性检验方法)</li>
<li>authentication key(完整性?认证密钥)</li>
<li>with n salespersons, there are $2+2n$ SAs in R1’s SAD<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SA%20from%20R1%20to%20R2.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="Security-Association-Database-SAD"><a href="#Security-Association-Database-SAD" class="headerlink" title="Security Association Database(SAD)"></a>Security Association Database(SAD)</h4><ul>
<li>endpoint holds SA state in security association database(SAD, 用于保存终端的SA状态), where it can locate them during processing</li>
<li>when sending IPsec datagram, The sending router accesses SAD to determine how to process datagram(发送IPsec数据报的时候，路由器访问SAD确认如何处理数据报，说明是考虑的tunnel mode with ESP)</li>
<li>when IPsec datagram arrives to the receiving router, router examines SPI in IPsec datagram, indexes SAD with SPI, and processes datagram accordingly(从IPsec数据报中找到SPI，即Security Parameter Index，然后根据Index查找SAD，最后根据查到的信息处理数据报)</li>
</ul>
<h4 id="IPsec-datagram-focus-on-tunnel-mode-with-ESP-for-now"><a href="#IPsec-datagram-focus-on-tunnel-mode-with-ESP-for-now" class="headerlink" title="IPsec datagram(focus on tunnel mode with ESP for now)"></a>IPsec datagram(focus on tunnel mode with ESP for now)</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPsec%20datagram.png" alt="img"></p>
<ul>
<li>ESP trl(trailer): Padding for block ciphers(尾部填充，用于分块加密凑长度)<ul>
<li>appends to back of original datagram (which includes original header fields!) an “ESP trailer” field. </li>
</ul>
</li>
<li>encrypts result using algorithm &amp; key specified by SA.(对整个数据报和填充的ESP trl加密)</li>
<li>ESP hdr(header):<ul>
<li>appends to front of this encrypted quantity the “ESP header, creating “enchilada”(墨西哥辣肉馅玉米卷). </li>
<li>SPI, receiving entity knows what to do</li>
<li>Sequence number: thwart replay attacks(应对重放攻击，因为如果收到同样序号的文件大概率会默认丢弃)<ul>
<li>for new SA, sender initializes seq# to 0(从0开始计数)</li>
<li>each time datagram in sent on SA:<ul>
<li>sender increments seq# counter(序号靠计数器累加)</li>
<li>places value in seq# field(序号靠直接分配)</li>
</ul>
</li>
<li>goal:<ul>
<li>prevent attacker from sniffing and replaying a packet</li>
<li>destination checks for duplicates</li>
</ul>
</li>
<li>method:<ul>
<li>receipt of duplicate, authenticated IP packets may disrupt service(重复的通过验证的IP数据报引起中断服务)</li>
<li>doesn’t keep track of all received packets; instead uses a window(不持续跟踪所有接收到的数据报，只在接收窗口检查序号？)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>creates authentication MAC over the whole enchilada, using algorithm and key specified in SA; (对ESP hdr+IP数据报+ESP trl做完整性认证)<ul>
<li>MAC in ESP auth field is created with shared secret key</li>
</ul>
</li>
<li>ESP auth: appends MAC to back of enchilada, forming payload;(认证结果放在数据报后面)</li>
<li>new IP header: creates brand new IP header, with all the classic IPv4 header fields, which it appends before payload</li>
</ul>
<h4 id="Security-Policy-Database-SPD"><a href="#Security-Policy-Database-SPD" class="headerlink" title="Security Policy Database(SPD)"></a>Security Policy Database(SPD)</h4><ul>
<li>policy: <ul>
<li>For a given datagram, sending entity needs to know if it should use IPsec(确认是否使用了IPsec)</li>
<li>needs also to know which SA to use(使用的是哪个SA)<ul>
<li>may use: source and destination IP address; protocol number(通过IP header包含的源IP地址和目的IP地址，所用协议的序号)</li>
</ul>
</li>
</ul>
</li>
<li>info in SPD indicates “what” to do with arriving datagram(SPD决定要对数据报做什么动作) </li>
<li>info in SAD indicates “how” to do it(SAD说明要做的动作怎么做)</li>
</ul>
<h4 id="Internet-Key-Exchange-IKE"><a href="#Internet-Key-Exchange-IKE" class="headerlink" title="Internet Key Exchange(IKE)"></a>Internet Key Exchange(IKE)</h4><ul>
<li>manual keying is impractical for VPN with many endpoints, instead use IPsec IKE(Internet Key Exchange)</li>
<li>IKE message exchange for algorithms, secret keys, SPI numbers, and authenticating (prove who you are) with either<ul>
<li>pre-shared secret (PSK, 预公钥): both sides start with secret<ul>
<li>run IKE to authenticate each other and to generate IPsec SAs (one in each direction, 所以有两遍，一遍一个方向), including encryption, authentication keys</li>
</ul>
</li>
<li>PKI(pubic/private keys and certificates): both sides start with public/private key pair, certificate<ul>
<li>run IKE to authenticate each other, obtain IPsec SAs (one in each direction).</li>
<li>similar with handshake in SSL.</li>
</ul>
</li>
</ul>
</li>
<li>IKE has two phase<ul>
<li>phase 1: establish bi-directional IKE SA<ul>
<li>note: IKE SA different from IPsec SA</li>
<li>has two mode:<ul>
<li>aggressive mode: using fewer messages</li>
<li>main mode: providing identity protection and is more flexible</li>
</ul>
</li>
</ul>
</li>
<li>phase 2: ISAKMP is used to securely negotiate IPsec pair of SAs<ul>
<li>aka ISAKMP security association: Internet Security Association and Key Management Protocol(ISAKMP)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><h4 id="Internet-approach-to-scalable-routing-增加路由的方法"><a href="#Internet-approach-to-scalable-routing-增加路由的方法" class="headerlink" title="Internet approach to scalable routing(增加路由的方法)"></a>Internet approach to scalable routing(增加路由的方法)</h4><ul>
<li>aggregate routers into regions known as “autonomous systems” (AS，聚合路由器形成自治系统) (a.k.a. “domains”)<ul>
<li>intra-AS (aka “intra-domain”，内部自治系统，管理同一IP网络号内的多个子网): routing among within same AS (“network”)<ul>
<li>all routers in AS must run same intra-domain protocol(相同域内协议)</li>
<li>routers in different AS can run different intra-domain routing protocols</li>
<li>gateway router(网关路由器，也称边缘路由器): at “edge” of its own AS, has link(s) to router(s) in other AS’es</li>
</ul>
</li>
<li>inter-AS (aka “inter-domain”，域间自治系统): routing among AS’es<ul>
<li>gateways perform inter-domain routing (as well as intra-domain routing，边缘路由器扮演域内域间两种角色)</li>
</ul>
</li>
</ul>
</li>
<li>The Internet comprises of Autonomous Routing Domains (ARDs)<ul>
<li>An ARD is a collection of resources under the administrative control of a single entity<ul>
<li>CMU network is an ARD</li>
<li>Routers, links, networks, etc</li>
<li>Policies, interconnections with other ARDs(ARDs们如何互联)</li>
<li>Big or small: Campus, corporate, ISP networks</li>
<li>Allocated numbers, names and addresses</li>
</ul>
</li>
</ul>
</li>
<li>scale: billions of destinations:(AS规模不能太大，否则一是记录路由表会占据内存，二是频繁交换路由表会覆盖有效链路通信)<ul>
<li>can’t store all destinations in routing tables!</li>
<li>routing table exchange would swamp links! </li>
</ul>
</li>
<li>administrative autonomy:<ul>
<li>Internet: a network of networks</li>
<li>each network admin may want to control routing in its own network</li>
</ul>
</li>
</ul>
<h4 id="Autonomous-Systems-自治系统"><a href="#Autonomous-Systems-自治系统" class="headerlink" title="Autonomous Systems(自治系统)"></a>Autonomous Systems(自治系统)</h4><ul>
<li>An Autonomous System (AS) is an ARD with an AS number assigned by IANA<ul>
<li>AS number(ASN): <ul>
<li>16-bit, 1 to 64511 are public, 64512 to 65535 are private<ul>
<li>CMU has ASN 9, UUNet has ASN 701, 702, 703, 704, 705(An organization can have multiple AS numbers)</li>
<li>This can be there is one AS number for each geographical region, one for America, one for Asia, one for Europe.</li>
<li>Can also be a result of consolidation of companies and their networks. So when ISPs merge right the bubble burst, they probably keep all the AS numbers from the individual companies. </li>
<li>Last count, there are more than 46,000 ASs (CIDR report, mar 2014)</li>
</ul>
</li>
<li>Not every ARD has a public AS number(不一定有ASN)<ul>
<li>Only if talks to more than one ASs(只在三个以上ASs的情景需要ASs拥有ASN)</li>
<li>Nowadays, must justify to IANA why you need one(名额有限，所以申请要向IANA说明原因)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Interconnected-ASes"><a href="#Interconnected-ASes" class="headerlink" title="Interconnected ASes"></a>Interconnected ASes</h4><ul>
<li><p>forwarding tableL configured by intra-AS routing algorithms and inter-AS routing algorithms</p>
<ul>
<li>intra-AS routing determine entries for destinations within AS(内部自治系统的路由决定内部的目的地址)</li>
<li>inter-AS and intra-AS determine entires for external destinations(自治系统间的路由决定外部的目的地址)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/edge%20routing.png" alt="img"></li>
</ul>
</li>
<li><p>Example:</p>
<ul>
<li>AS1 inter-domain routing(边缘路由器) must:<ul>
<li>learn which destinations reachable through AS2, which through AS3(了解可通过其他邻域到达的目标)</li>
<li>propagate this reachablility info to all routers in AS1(让AS1中所有路由器知道可达的这些目标)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/inter-domian%20routing%20example.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Most-common-intra-AS-routing-protocols"><a href="#Most-common-intra-AS-routing-protocols" class="headerlink" title="Most common intra-AS routing protocols"></a>Most common intra-AS routing protocols</h4><ul>
<li>RIP: Routing Information Protocol [RFC 1723]<ul>
<li>classic DV: DVs exchanged every 30 secs(distance vector, 距离向量)</li>
<li>no longer widely used(不怎么用了)</li>
</ul>
</li>
<li>EIGRP: Enhanced Interior Gateway Routing Protocol<ul>
<li>DV based</li>
<li>formerly Cisco-proprietary for decades (became open in 2013 [RFC 7868])</li>
</ul>
</li>
<li>OSPF: Open Shortest Path First  [RFC 2328]<ul>
<li>link-state routing(基于链路状态)</li>
<li>IS-IS protocol (ISO standard, not RFC standard) essentially same as OSPF</li>
</ul>
</li>
</ul>
<h4 id="Internet-inter-AS-routing-BGP"><a href="#Internet-inter-AS-routing-BGP" class="headerlink" title="Internet inter-AS routing: BGP"></a>Internet inter-AS routing: BGP</h4><ul>
<li>BGP(Boder Gateway Protocol, 边界网关协议, 域间路由协议): the de facto inter-domain routing protocol<ul>
<li>allows subnet to advertise its existence, and the destinations it can reach, to rest of Internet: “I am here, here is who I can reach, and how”</li>
<li>允许子网自发向其他广播自己的相关路由信息</li>
</ul>
</li>
<li>BGP provides each AS a means to:<ul>
<li>eBGP: obtain subnet reachability information from neighboring ASes(边缘路由器从相邻AS获取子网的可达性信息)</li>
<li>iBGP: propagate reachability information to all AS-internal routers.(边缘路由器将获得的可达性信息告知内部AS的所有路由器)</li>
<li>determine “good” routes to other networks based on reachability information and policy(基于可达性信息和策略决定一个路由是不是好的路由选择)</li>
</ul>
</li>
<li>BGP advertised route: prefix + attributes<ul>
<li>prefix: destination being advertised</li>
<li>two important attributes:<ul>
<li>AS-Path: list of ASes through which prefix advertisement has passed</li>
<li>NEXT-HOP: indicates specific internal-AS router to next-hop AS(下一跳的AS)</li>
</ul>
</li>
</ul>
</li>
<li>BGP policy-based routing:<ul>
<li>gateway receiving route advertisement uses import policy to accept/decline path (e.g., never route through AS Y).</li>
<li>AS policy also determines whether to advertise path to other neighboring ASes(是否告知相邻AS)</li>
</ul>
</li>
<li>Example1: 路径广告的运作原理<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPExample1.png" alt="img"><ul>
<li>AS2的路由器2c通过eBGP接收到来自AS3路由器3a的路径广告(path advertisement)<code>AS3, X</code></li>
<li>基于AS2的策略，AS2路由器2c将接收到的<code>AS3, X</code>通过iBGP广播到AS2中的所有路由器</li>
<li>基于AS2的策略，AS2的路由器2a通过eBGP向AS1的路由器1c发出路径广告<code>AS2, AS3, X</code></li>
</ul>
</li>
<li>Example2: 网关路由器(gateway router)可能获得不止一条到达目的地的路径<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPExample2.png" alt="img"><ul>
<li>AS1的网关路由器1c从AS2的网关路由器2a获得路径<code>AS2, AS3, X</code></li>
<li>AS1的网关路由器1c从AS3的网关路由器3a获得路径<code>AS3, X</code></li>
<li>基于AS1的策略，网关路由器1c会选择路径<code>AS3, X</code>(最短？)并将该路径通过iBGP告知AS1中的所有路由器</li>
</ul>
</li>
<li>Example3<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPExample3.png" alt="img"><ul>
<li>AS1的路由器1d是OSPF域内路由器(OSPF intra-domain routing)，要到达AS1的路由器1c或AS3的路由器X，会使用自身的1号接口</li>
<li>AS1的路由器1a是OSPF域内路由器(OSPF intra-domain routing)，要到达AS1的路由器1c或AS3的路由器X，会使用自身的2号接口</li>
</ul>
</li>
<li>BGP messages: BGP messages exchanged between peers over TCP connection(TCP连接中的连接对互相交换BGP消息)<ul>
<li><code>OPEN</code>: opens TCP connection to remote BGP peer and authenticates sending BGP peer(打开连接并验证)</li>
<li><code>UPDATE</code>: advertises new path or withdraws old(广播新路径或撤回旧路径)<ul>
<li>Announced prefixes(通告前缀), a.k.a. NLRI(network layer reachability information) </li>
<li>Path attributes associated with annoucement(路径长度?下一跳地址?)</li>
<li>Withdrawn prefixes(撤回前缀)</li>
</ul>
</li>
<li><code>KEEPALIVE</code>: keeps connection alive in absence of UPDATES; also ACKs <code>OPEN</code> request(在没有<code>UPDATES</code>的情况下保持有效连接，确认<code>OPEN</code>的请求)</li>
<li><code>NOTIFICATION</code>: reports errors in previous msg; also used to close connection(报告错误消息，也用于关闭连接)</li>
</ul>
</li>
<li>Hot potato routing(烫山芋路由策略)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/hot%20potato%20routing.png" alt="img"><ul>
<li>AS2的路由器2d通过iBGP有两条到达AS3的路由器X的路径<ul>
<li>2d-&gt;2a-&gt;1c-&gt;3a-&gt;3d-&gt;X(选择这个，因为2d到2a比2d到2c成本低)</li>
<li>2d-&gt;2c-&gt;3a-&gt;3d-&gt;X</li>
</ul>
</li>
<li>choose local gateway that has least intra-domain cost (域内成本最低的本地网关，即使可能跳数会更多。e.g., 2d chooses 2a, even though more AS hops to X): don’t worry about inter-domain cost!</li>
</ul>
</li>
<li>ISP(互联网服务供应商)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGP%20policy.png" alt="img"><ul>
<li>The ISP can offer a service to its customers where the ISP creates and maintains CA certificates for the customers’ resources and ROAs for the customers’ prefixes.(为客户提供服务，为客户的资源创建和维护CA证书，为客户的前缀创建和维护ROA) </li>
<li>only wants to route traffic to/from its customer networks(只将路由信息发送给消费者网络，不发给其他提供转发服务的网络?即不会出现转发环) (does not want to carry transit traffic between other ISPs – a typical “real world” policy)</li>
<li>provider networks: 包含提供转发服务的网络</li>
<li>customer networks: 包含使用转发服务的网络</li>
<li>dual-homed: attached to two provider networks</li>
</ul>
</li>
<li>BGP route selection: router may learn about more than one route to destination AS, selects route based on(多条路径，即多个下一跳路由)<ul>
<li>local preference value attribute: policy decision</li>
<li>shortest AS-PATH (最短的路径)</li>
<li>closest NEXT-HOP router: hot potato routing (最低的成本)</li>
<li>additional criteria <ul>
<li>Drop routes with inaccessible Nexthops(不选择没有下一跳的路由器)</li>
<li>Prefer route with largest LocalPref(偏爱有最大优先级的路由器)</li>
<li>Prefer lowest origin type IGP&lt; EGP &lt; Incomplete</li>
<li>Prefer route with smallest MED Compare MEDs from same AS only</li>
<li>Prefer path with lowest IGP metric</li>
<li>Prefer path by lowest BGP IDs</li>
<li>(vendor-specific hacks …)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BGP-Attack"><a href="#BGP-Attack" class="headerlink" title="BGP Attack"></a>BGP Attack</h3><h4 id="BGP-Vulnerabilities"><a href="#BGP-Vulnerabilities" class="headerlink" title="BGP Vulnerabilities"></a>BGP Vulnerabilities</h4><ul>
<li>Routers run an operating system which hackers now target(路由器有操作系统，容易受到攻击)</li>
<li>Potential attack objectives<ul>
<li>Blackholing: make something unreachable(使消息无法到达目的地，如何进入转发死循环)</li>
<li>Redirection(重定向，篡改转发方向): congestion(拥塞), eavesdropping(窃听)<ul>
<li>Unauthorized origin ISP(未经验证的宣称，被误导)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/unauthorized%20origin%20ISP.png" alt="img"></li>
<li>AS-path truncation(截断)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/truncation.png" alt="img"></li>
<li>AS-path alteration(篡改)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/alteration.png" alt="img"></li>
</ul>
</li>
<li>Instability(不稳定)</li>
</ul>
</li>
</ul>
<h4 id="Attack-method"><a href="#Attack-method" class="headerlink" title="Attack method"></a>Attack method</h4><ul>
<li>Prefix Hijacking and Announcement of Unallocated Address Space <ul>
<li>an autonomous system (AS) accidentally or maliciously originates a prefix that it is not authorized (by the prefix owner) to originate(即实际不能到达该前缀对应的网络，因为没有被授权，会被拒绝)</li>
<li>IP route selection: most specific (i.e., longest) matching entry in a router’s FIB. Offending AS falsely announces a more-specific prefix, the longer, unauthorized prefix will be widely accepted and used to route data.(利用最长匹配规则，扩大前缀的掩码，误导路由选择错误的下一跳地址) </li>
<li>AS may also falsely originate allocated but currently unused address space(for send spam or for some other malicious purpose.)(伪装成合法的但暂时无人使用的地址)</li>
<li>sub-prefix hijack can be serious(可能很严重)</li>
<li>DOS, eavesdropping, misdirection to imposter servers (to steal login credentials or inject malware)(DOS攻击，窃取，误导以冒名顶替服务器从而窃取登录姘居或注入恶意软件)</li>
<li>defeat of IP reputation systems to launch spam email. (破坏IP的信誉系统以发送垃圾邮件)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Attack%20method1.png" alt="img"></li>
</ul>
</li>
<li>AS-path Modification<ul>
<li>AS-path是一个AS数字序列，表示数据将在互联网流过的路径，用于实现路由策略(reflect the business agreements and peering policies that have been negotiated between networks.<br>)</li>
<li>a malicious AS which receives a BGP update may illegitimately remove some of the preceding ASes in the AS_PATH attribute of the update to make the path length seem shorter.(由于BGP是广播的，因此可能有接收到BGP更新的恶意AS。它可以在更新AS-path属性时非法删除一些前面的AS，以使得通过自己的那条路径的长度看起来更短)<ul>
<li>illegitimately increase its revenue from its customers(从而可以非法增大它的客户的成本，因为实际路径长度没那么短)</li>
<li>may be able to eavesdrop on traffic that would otherwise not transit through their AS. (也能够窃听原本不会通过该恶意AS传输的流量，因为修改了传播路径)</li>
</ul>
</li>
<li>adversary AS replaces a prefix in a received update with a more-specific prefix(利用最长匹配原则，恶意AS将接收到的BGP更新消息中的前缀替换为更具体的前缀) and then forwards the update to neighbors.(然后将该更新消息转发给邻居) <ul>
<li>ASes on the internet would widely accept and use the adversary AS’s advertisement for the more-specific prefix. (于是根据最长匹配原则，接收到该更新消息的AS都会使用这个更具体的前缀)</li>
<li>The adversary would be able to force almost all traffic for the more-specific prefix to be routed via their AS. Therefore, the adversary can eavesdrop on the data without being detected, because data reach destination correctly!(恶意AS可以汇聚几乎所有的流量，因为都通过它更具体的前缀进行转发。从而能够窃听数据而不被发现，因为数据确实成功到达了目的地)</li>
</ul>
</li>
</ul>
</li>
<li>Route Leaks: is the propagation of routing announcements beyond their intended scope(路由的作用范围超出了预期)<ul>
<li>Peering policies often specify limits on what routing announcements will be accepted by each party. (限制路由广告)</li>
<li>a stub or customer AS should never be used to route between two transit ASes.(使用转发服务的AS不应该告知两个本身就已有连接的AS自己与它们各自的路由信息) </li>
<li>The result of a route leak can include redirection of traffic through an unintended path, (会有重定向问题)<ul>
<li>enable eavesdropping or malicious traffic analysis. (窃听或恶意流量分析)</li>
<li>causes blackholing and denial-of-service for the affected prefixes. (前缀出现黑点和拒绝服务)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/route%20leak.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>IP Address Spoofing &amp; Reflection Amplification Attack <ul>
<li>Spoofed Source Addresses(伪造源地址，可以发起DDoS攻击，即不断发送请求使服务器宕机)</li>
<li>Reflection and Amplification Attacks<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DDos.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="Securing-BGP"><a href="#Securing-BGP" class="headerlink" title="Securing BGP"></a>Securing BGP</h3><h4 id="BGP-Security-Requirements"><a href="#BGP-Security-Requirements" class="headerlink" title="BGP Security Requirements"></a>BGP Security Requirements</h4><ul>
<li>Verification of address space “ownership”(需要验证地址空间的所有权)</li>
<li>Authentication of Autonomous Systems (AS)(AS认证)</li>
<li>Router authentication and authorization (relative to an AS)(相对于AS来说进行路由器身份验证和授权，防止AS中的非法路由器?还是防止路由器并不是在AS中)</li>
<li>Route and address advertisement authorization(路由和地址的广告授权)</li>
<li>Route withdrawal authorization(路由撤回授权)</li>
<li>Integrity and authenticity of all BGP traffic on the wire(线路上所有BGP流量的完整性和真实性)</li>
<li>Timeliness of BGP traffic(BGP流量的及时性)</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul>
<li>Authentication at BGP layer(BGP层的认证)<ul>
<li>MD5 checksum option protects TCP layer connection in BGP, provides authentication between BGP speakers(MD5校验和用来保护BGP中的TCP层连接，保障BGP路由之间的身份验证)<ul>
<li>Prevents external attacker from injecting bogus information into TCP connection, e.g., TCP poisoning(防止外部攻击者窃取TCP连接的数据报并注入虚假信息)</li>
<li>Does not provide authenticity for routing information, all 3 attacks are still possible!(但不提供路由信息的真实性认证，仍然可能受到除修改路由信息外其他攻击方式攻击)</li>
</ul>
</li>
</ul>
</li>
<li>Route filtering<ul>
<li>Use Internet routing registries<ul>
<li>Database of who owns what prefix</li>
</ul>
</li>
<li>Typically route filtering used for “business”<ul>
<li>don’t want to go through this AS</li>
<li>don’t want to reveal route to this AS</li>
</ul>
</li>
<li>Ingress filters: Does AS own the prefix? If no, don’t accept</li>
<li>Problem is incomplete databases, multiorigin conflicts etc</li>
</ul>
</li>
</ul>
<h4 id="S-BGP-design-overview"><a href="#S-BGP-design-overview" class="headerlink" title="S-BGP design overview"></a>S-BGP design overview</h4><ul>
<li>IPSec: authenticity and integrity of peer-to-peer communication, automated key management(用于对等通信的真实性和完整性认证，自动密钥的管理)</li>
<li>Public Key Infrasturctures(PKIs): secure identification of BGP speakers and of owners of AS’s and of address blocks(BGP发言人和AS所有者以及地址块所有者的安全识别)</li>
<li>Attestations -&gt; authorization: of the subject (by the issuer) to advertise specified address blocks(由发行人即主体发布指定地址块的广告)</li>
<li>Validation of UPDATEs: based on a new path attribute, using certificates and attestations(基于新的路径属性，使用证书和认证验证BGP的更新消息)<ul>
<li>Internet Corporation for Assigned Names and Numbers(ICANN，用于名称与数字地址分配的互联网机构) issues certificates(颁布证书) for AS ownership(AS所有权证书) to ISPs and organizations that run BGP</li>
<li>AS operators issue certificates to routers, as AS representatives(AS运营商作为AS代表向路由器颁发证书)</li>
<li>Holders of AS(or router) certificates generate route attestations(AS或路由的证书持有人生成路由证明), authorizing advertisement of a route by a specified next hop AS(授权指定的下一跳AS发布路由广告)</li>
<li>Route attestations are used to express a secure route as a sequence of AS hops(路由证明用于将安全路由表示为AS跳的序列)</li>
</ul>
</li>
<li>Distribution of countermeasure data(分布式的对策数据): certificates(证书), Certificate Revocation List (CRLs，证书吊销列表，即黑名单?), attestations(证明)</li>
</ul>
<h4 id="Registration-of-Route-Objects-in-Internet-Routing-Registries"><a href="#Registration-of-Route-Objects-in-Internet-Routing-Registries" class="headerlink" title="Registration of Route Objects in Internet Routing Registries"></a>Registration of Route Objects in Internet Routing Registries</h4><ul>
<li>Internet路由注册表中路由对象的注册</li>
<li>regional internet registries (RIRs, 区域互联网注册中心)<ul>
<li>ARIN in North America</li>
<li>LACNIC in Latin America,</li>
<li>RIPE in Europe</li>
<li>APNIC in Asia-Pacific</li>
<li>AfriNIC in Africa</li>
</ul>
</li>
<li>internet routing registries (IRRs, 互联网路由注册中心)<ul>
<li>RIPE NCC, APNIC, AfriNIC, and ARIN </li>
<li>major internet service providers (ISPs, 互联网服务供应商) </li>
</ul>
</li>
<li>Roles of RIRs and IRRs<ul>
<li>Maintain declarative data about internet resource allocations and routing policies(维护有关互联网资源分配和路由策略的声明性数据) </li>
<li>route objects available in the IRRs provide routing information declared by network operators (IRR中可用的路由对象提供由网络运营商声明的路由信息)</li>
<li>Merit’s Routing Assets Database (RADb) and other similar entities provide a collective routing information base consisting of registered (at their site) as well as mirrored (from the IRRs) data. (路由资产数据库RADb和其他类似实体提供一个由注册和镜像数据组成的集体路由信息库，其中注册数据在站点，镜像在IRR)</li>
<li>Network operators often obtain route object information from the IRRs and/or RADb, and they can make use of the data in the creation of prefix filters  in their BGP routers. (网络运营商经常从IRR或RADb获取路由对象信息，利用这些数据在BGP路由器中创建前缀过滤器，过滤掉不符合标准的过长前缀，防止最长匹配机制被利用)</li>
</ul>
</li>
<li>data exchanged in RIRs/IRRs<ul>
<li>Routing Policy Specification Language (RPSL, 路由策略规范语言)  (most RIR and ISP use)</li>
<li>Shared Whois Project (SWIP, 共享Whois项目)  (ARIN, LACNIC) </li>
</ul>
</li>
</ul>
<ul>
<li><p>greater efforts should be devoted to creating route origin authorizations (ROAs, 路由源授权)</p>
<ul>
<li>because RPKI provides a stronger authentication and validation framework for network operators than IRR(RPKI为网络运营商提供了比IRR更强的身份验证和确认框架)</li>
</ul>
</li>
<li><p>Security Recommendation 1: All internet number resources (e.g., address blocks and AS numbers) should be covered by an appropriate registration services agreement with an RIR, and all point-of-contact (POC) information should be up to date. The granularity of such registrations should reflect all sub-allocations to entities (e.g., enterprises within the parent organization, branch offices) that operate their own network services (e.g., internet access, DNS). </p>
<ul>
<li>所有的互联网号码资源(地址块，AS号码)都应该与RIR签订适当的注册服务协议</li>
<li>所有的联系点(POC)信息都应该是最新的</li>
<li>此类注册的粒度应该能反映对运营自己网络服务(如互联网接入、DNS)的实体(如母组织内的企业、分支机构)的所有子分配</li>
</ul>
</li>
<li>Security Recommendation 2: In the case of address block (NetRange) registration in ARIN, the originating autonomous system (origin AS) should be included. <ul>
<li>在ARIN中进行地址块(NetRange)注册的情况下，应该包括地址块对应的原始自治系统(原始AS)</li>
</ul>
</li>
<li>Security Recommendation 3: Route objects corresponding to the BGP routes originating from an AS should be registered and actively maintained in an appropriate RIR’s IRR. Enterprises should ensure that appropriate IRR information exists for all IP address space used directly and by their outsourced IT systems and services. <ul>
<li>与源自AS的BGP路由相对应的路由实体对象应该在恰当的RIR的IRR中注册和积极维护。</li>
<li>企业应该确保其外包的IT系统和服务直接使用的所有IP地址空间都有恰当的IRR信息(都合法)</li>
</ul>
</li>
</ul>
<h4 id="Certification-of-Resources-in-Resource-Public-Key-Infrastructure-（RPKI）"><a href="#Certification-of-Resources-in-Resource-Public-Key-Infrastructure-（RPKI）" class="headerlink" title="Certification of Resources in Resource Public Key Infrastructure （RPKI）"></a>Certification of Resources in Resource Public Key Infrastructure （RPKI）</h4><ul>
<li>资源公钥基础设施(RPKI)中的资源认证</li>
<li>RPKI is standards-based approach for providing cryptographically secured registries of internet resources and routing authorization(基于标准的方法，用于提供安全加密的互联网资源注册表和路由授权)</li>
<li>global certificate authority (CA, 全球证书颁发机构) and registry service offered by all regional internet registries (RIRs, 提供注册服务)<ul>
<li>five RIRs (AFRINIC, APNIC, ARIN, LACNIC, and RIPE) maintains an independent trust anchor (TA) for RPKI certification services in its respective region.(五个RIR为其各自地区的RPKI认证服务维护独立的信任锚) </li>
</ul>
</li>
<li>The Internet Assigned Numbers Authority (ICANA, 互联网号码分配机构) allocates resources to the regional internet registries (RIRs, 为区域互联网注册中心分配资源) <ul>
<li>Internet Corporation for Assigned Names and Numbers (ICANN, 互联网名称与号码分配机构)</li>
<li>RIRs suballocate to local internet registries (LIRs, RIRs分配给本地互联网注册中心, RIRs &gt; LTRs), </li>
<li>LIRs suballocate to ISPs and enterprises. (LIRs分配给ISPs互联网服务供应商和公司)</li>
</ul>
</li>
<li>RPKI is based on the X.509 standard with RFC 3779 extensions that describe special certificate profiles for internet number resources (prefixes and AS numbers) <ul>
<li>描述了互联网号码资源(如前缀和号码)的特殊证书配置文件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPKI.png" alt="img"></p>
<ul>
<li>Security Recommendation 4: Internet number resource holders with IPv4/IPv6 prefixes and/or AS numbers (ASNs) should obtain RPKI certificate(s) for their resources. (具有IPv4/IPv6前缀和/或AS号码ASN这些互联网号码资源的持有者应该为其拥有的这些资源获取RPKI证书，保证其合法性)</li>
<li>Security Recommendation 5: Transit providers should provide a service where they create, publish, and manage subordinate resource certificates for address space and/or ASNs suballocated to their customers.(传输服务供应商应该提供额外一项服务，为分配给客户的地址空间和/或ASN创建、发布和管理从属资源证书)</li>
</ul>
<h4 id="BGP-Origin-Validation-BGP-OV"><a href="#BGP-Origin-Validation-BGP-OV" class="headerlink" title="BGP Origin Validation (BGP-OV)"></a>BGP Origin Validation (BGP-OV)</h4><ul>
<li>BGP源验证</li>
<li>Once an address prefix owner obtains a CA certificate, they can generate an end-entity (EE) certificate and use the private key associated with the EE certificate to digitally sign a route origin authorization (ROA).(一旦地址前缀所有者获得了CA证书，就可以生成端实体EE证书，并使用与EE证书关联的私钥对路由源授权ROA进行数字签名) <ul>
<li>An ROA declares a specific AS as an authorized originator of BGP announcements for the prefix (ROA声明特定AS作为授权发起者，授权BGP发布前缀相关的广告)</li>
<li>ROAs can also be created (signed) by an ISP (transit provider) on behalf of its customer based on a service agreement provided that the ISP suballocated the address space to the customer. (如果ISP将地址空间重新分配给客户，则ISP或传输供应商也可以根据服务协议代表其客户创建或签署ROA)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Creation%20of%20Route%20Origin%20Authorization%20(ROA" alt="img">%20by%20prefix%20owner.png)</li>
</ul>
</li>
<li>Once created, RPKI data is used throughout the internet by relying parties (RPs).(一旦创建，依赖方RP会在整个互联网上使用RPKI数据) <ul>
<li>RPs, such as RPKI-validating servers, can access RPKI data from the repositories  using either the rsync protocol or the RPKI Repository Delta Protocol (RRDP) [RFC8182].(例如RPKI验证服务器的RP，可以使用rsync协议或RPKI存储库增量协议RRDP从存储库访问RPKI数据) <ul>
<li>The RRDP protocol is often called “delta protocol” as shorthand. A BGP router typically accesses the required ROA data from one or more RPKI cache servers that are maintained by its AS. (RRDP协议通常被速记为delta协议，BGP路由器通常从其AS维护的一个或多个RPKI缓存服务器访问所需的ROA数据)</li>
</ul>
</li>
</ul>
</li>
<li>The RPKI-to-router protocol is used for communication between the RPKI cache server and the router (RPKI到路由器协议用于RPKI缓存服务器和路由器之间的通信)</li>
<li>A BGP router can use the ROA information retrieved from an RPKI cache server to mitigate the risk of prefix hijacks and some forms of route leaks in advertised routes.(BGP路由器可以使用从RPKI缓存服务器检索到的ROA信息降低前缀劫持和广告路由器中某些形式的路由泄露风险)  </li>
<li><p>A BGP router would typically receive a validated white list of {prefix, maxlength, origin AS} tuples (derived from valid ROAs) from one or more RPKI cache servers. A BGP route is deemed to have a “Valid” origin if the {prefix, origin AS} pair in the advertised route can be corroborated with the white list (i.e., the pair is permissible in accordance with at least one ROA; (BGP路由器通常会从一个或多个RPKI缓存服务器接收经过验证的{prefix, maxlength, originAS}元组白名单，该白名单从有效的ROA派生。如果广告路由器中的{prefix, originAS}对可以用白名单验证，即根据至少一个ROA，该对是允许的，则BGP路由被视为具有”有效”的起点，)</p>
<ul>
<li>The router makes use of this white list with the BGP origin validation (BGP-OV) process depicted to determine the validation state of an advertised route [RFC6811].(路由器利用此白名单和描述的BGP源验证过程，即BGP-OV，来确定广告路由的验证状态) </li>
<li>A BGP route is deemed to have a “Valid” origin if the {prefix, origin AS} pair in the advertised route can be corroborated with the white list (i.e., the pair is permissible in accordance with at least one ROA; A route is considered “Invalid” if there is a mismatch with the white list (i.e., AS number does not match, or the prefix length exceeds maxlength) (如果广告路由中的{prefix, originAS}对可以用白名单证实，则BGP路由被称为具有有效的源，如果与白名单不匹配，则是无效的)</li>
<li>a route is deemed “NotFound” if the prefix announced is not covered by any prefix in the white list (i.e., there is no ROA that contains a prefix that equals or subsumes the announced prefix).(如果路由所宣布的前缀未被白名单中的任何前缀匹配，没有包含或等于所宣布前缀的ROA，则该路由被称为未发现NotFound)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPKI%20data%20retrieval%2C%20caching%2C%20and%20propagation%20to%20routers.png" alt="img"></li>
</ul>
</li>
<li><p>The RPKI-based origin validation may be supplemented by validation based on IRR data.(基于RPKI的源验证可以通过基于IRR数据的验证来作为补充)</p>
<ul>
<li>Although RPKI-based BGP- OV is already implemented in commercial BGP routers[Juniper1] [Cisco1] [Patel] [Scudder] [NIST-SRx] [Parsons2] [goBGP] [RTRlib]. , the activation and ubiquitous use of RPKI and BGP-OV in BGP routers require motivation and commitment on the part.(即使基于RPKI的BGP-OV已经在商业BGP路由器中实现，但并没有完全覆盖所有的路由器，目前大概只有60%)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Algorithm%20for%20origin%20validation%20(based%20on%20RFC%206811" alt="img">.png)</li>
</ul>
</li>
<li>Security Recommendation 6: Resource holders should register Route Origin Authorization (ROA(s) in the global RPKI for all prefixes that are announced or intended to be announced on the public internet. (资源持有者应该在全球RPKI中注册路由源授权ROA，用于在公共互联网上宣布或计划宣布前缀)</li>
<li>Security Recommendation 7: Each transit provider should provide a service where they create, publish, and maintain ROAs for prefixes suballocated to their customers. Alternatively, as part of the service, customers can be allowed to create, publish, and maintain their ROAs in a repository maintained by the transit provider. (每个传输供应商都应该提供一项服务，在其中创建、发布和维护分配给用户的前缀ROA。或者作为服务的一部分，可以允许客户在运输供应商维护的存储库中创建、发布和维护它们的ROA。要么自己做，要么客户做)</li>
<li>Security Recommendation 8: If a prefix that is announced (or intended to be announced) is multi-homed and originated from multiple ASes, then one ROA per originating AS should be registered for the prefix (possibly in combination with other prefixes which are also originated from the same AS). (如果宣布或打算宣布的前缀是多归属的，并且源自多个AS，则每个源AS都应该为该前缀注册一个ROA，可能与源自同一AS的其他前缀组合注册到一个ROA)</li>
<li>Security Recommendation 9: When an ISP or enterprise owns multiple prefixes that include less-specific and more-specific prefixes, they should ensure that the more- specific prefixes have ROAs before creating ROAs for the subsuming less-specific prefixes. (当ISP或企业拥有多个不太具体和更具体的前缀时，应该在为包含不太具体的前缀的前缀创建ROA之前，确保更具体的前缀具有ROA，即先具体后不太具体)</li>
<li>Security Recommendation 10: An ISP should ensure that more specific prefixes announced from within their customer cone have ROAs prior to the creation of its own ROAs for subsuming less-specific prefix(es).(ISP应该确保在为包含不太具体的前缀创建ROA之前，其客户群体中宣布的更具体的前缀都具有ROA) </li>
<li>Security Recommendation 11: An ISP or enterprise should create an AS0 ROA (Route Origin Authorization) for any prefix that is currently not announced to the public internet. However, this should be done only after ensuring that ROAs exist for any more-specific prefixes subsumed(纳入) by the prefix that are announced or are intended to be announced. (ISP或企业为目前未向公共互联网公布的任何前缀创建AS0 ROA。但只有在确保已宣布或打算宣布的任何更具体的前缀都存在ROA后，才能这么做。先公布具体的，后未公布的)</li>
<li>Security Recommendation 12: A BGP router should not send updates with AS_SET or AS_CONFED_SET in them (in compliance with BCP 172 [RFC6472]). (BGP路由器不应该发送包含AS_SET或AS_CONFED_SET的更新)<ul>
<li>When an AS_SET is present in a BGP update, it is not possible to clearly determine the origin AS from the AS_PATH [RFC6811]. Thus, an update containing an AS_SET in its AS_PATH can never receive an assessment of “Valid” in the origin validation process(如果BGP更新中包含AS_SET，无法从AS_PATH中清楚地确定源AS。因此在AS_PATH中包含的AS_SET的更新在源验证过程中永远不会收到结果为”有效”的评估) </li>
</ul>
</li>
<li>Security Recommendation 13: ISPs and enterprises that operate BGP routers should also operate one or more RPKI-validating caches. (运营BGP路由器的ISP和企业也应该运行一个或多个RPKI验证缓存)</li>
<li>Security Recommendation 14: A BGP router should maintain an up-to-date white list consisting of {prefix, maxlength, origin ASN} that is derived from valid ROAs (Route Origin Authorization ) in the global RPKI. The router should perform BGP-OV. (BGP路由器应该维护一个最新的白名单，其中包括从全局RPKI中的有效ROA导出的{prefix, maxlength, origiin ASN}。路由器应该执行BGP-OV)</li>
<li>Security Recommendation 15: In partial/incremental deployment state of the RPKI, the permissible {prefix, origin ASN} pairs for performing BGP-OV should be generated by taking the union of such data obtained from ROAs, IRR data, and customer contracts. (在RPKI的部分部署或增量部署状态下，应该通过合并从ROA、IRR数据和客户合同中获得的数据来生成用于执行BGP-OV的可行的{prefix, origin ASN}对)</li>
<li>Security Recommendation 16: BGP-OV results should be incorporated into local policy decisions to select BGP best paths. (BGP-OV的结果应该纳入本地策略决策，以选择BGP最佳路径，保证路径的可靠性)</li>
</ul>
<h4 id="Minimize-Forged-Origin-Hijacks"><a href="#Minimize-Forged-Origin-Hijacks" class="headerlink" title="Minimize Forged-Origin Hijacks"></a>Minimize Forged-Origin Hijacks</h4><ul>
<li>a purposeful malicious hijacker can forge the origin AS of any update by prepending the number of an AS found in an ROA (Route Origin Authorization ) for the target prefix onto their own unauthorized BGP announcement. (有目的的恶意劫持者可以通过将目标前缀的ROA中发现的ASN预先添加到他们自己的未经授权的BGP广告中，伪造来自源AS的更新)<ul>
<li>With ROA-based origin validation alone, it is possible to prevent accidental misoriginations. (仅通过基于ROA的源验证，就可以防止意外的源错误)</li>
</ul>
</li>
<li>replace the prefix in the route with a more-specific prefix that has a length not exceeding the maxlength in the ROA. (将路由器中的前缀替换为长度不超过ROA最大长度的更具体的前缀，利用了最大匹配机制)<ul>
<li>subsumed(包含在) under the announced prefix</li>
</ul>
</li>
<li>Security Recommendation 17: The maxlength in the ROA should not exceed the length of the most specific prefix (subsumed under the prefix in consideration) that is originated or intended to be originated from the AS listed in the ROA. (ROA中的最大长度不应该超过源自或意图源自ROA中列出的AS的最具体前缀的长度)</li>
<li>Security Recommendation 18: If a prefix and select more-specific prefixes subsumed under it are announced or intended to be announced, then instead of specifying a maxlength, the prefix and the more-specific prefixes should be listed explicitly in multiple ROAs (i.e., one ROA per prefix or more-specific prefix). (对于被宣布或打算被宣布的一个前缀和其包含的更具体的前缀，与其指定最大长度，不如在多个ROA中明确列出前缀和更具体的前缀，即一个ROA一个前缀)</li>
</ul>
<h4 id="Enable-Prefix-Filters"><a href="#Enable-Prefix-Filters" class="headerlink" title="Enable Prefix Filters"></a>Enable Prefix Filters</h4><ul>
<li>Prefix Filtering with Lateral Peer</li>
<li>Prefix Filtering with Transit Provider </li>
<li>Prefix Filtering with Customer </li>
<li>Prefix Filtering Performed in a Leaf Customer Network </li>
<li>Role of RPKI in Prefix Filtering </li>
</ul>
<h4 id="AS-Path-Validation-Emerging-Future"><a href="#AS-Path-Validation-Emerging-Future" class="headerlink" title="AS Path Validation (Emerging/Future)"></a>AS Path Validation (Emerging/Future)</h4><h4 id="Generalized-TTL-Security-Mechanism-GTSM"><a href="#Generalized-TTL-Security-Mechanism-GTSM" class="headerlink" title="Generalized TTL Security Mechanism (GTSM)"></a>Generalized TTL Security Mechanism (GTSM)</h4><h4 id="Route-Leak-Detection-and-Mitigation"><a href="#Route-Leak-Detection-and-Mitigation" class="headerlink" title="Route Leak Detection and Mitigation"></a>Route Leak Detection and Mitigation</h4>]]></content>
      <categories>
        <category>高级计算机网络</category>
      </categories>
      <tags>
        <tag>高级计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>消息序和组通信</title>
    <url>/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="消息序和组通信"><a href="#消息序和组通信" class="headerlink" title="消息序和组通信"></a>消息序和组通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>消息顺序<ul>
<li>非FIFO和FIFO</li>
<li>因果顺序(causal order)</li>
<li>同步顺序(synchronous order)</li>
</ul>
</li>
<li>多播组通信<ul>
<li>因果顺序(causal order)</li>
<li>完全顺序(total order)</li>
</ul>
</li>
<li>故障发生时的预期行为语义</li>
<li>多播<ul>
<li>应用层和网络层参与</li>
</ul>
</li>
</ul>
<h3 id="一些符号"><a href="#一些符号" class="headerlink" title="一些符号"></a>一些符号</h3><ul>
<li>网络$(N, L)$</li>
<li>事件集合$(E, \prec)$</li>
<li>消息$m^i$: <ul>
<li>发送该消息的事件: $s^i$</li>
<li>接收该消息的事件: $r^i$</li>
</ul>
</li>
<li>发送事件: $s$</li>
<li>接收事件: $r$</li>
<li>消息$M$:<ul>
<li>发送: send(M)</li>
<li>接收: receive(M)</li>
</ul>
</li>
<li>对应事件: $a\sim b$，表示两个事件在同一个进程中发生</li>
<li>发送接收对: $T={(s, r)\in E_i\times E_j | s\quad corresponds\quad to\quad r}$</li>
</ul>
<h3 id="异步和FIFO执行"><a href="#异步和FIFO执行" class="headerlink" title="异步和FIFO执行"></a>异步和FIFO执行</h3><h4 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h4><ul>
<li>$(E, \prec)$，因果关系是一个偏序关系。</li>
<li>没有因果循环</li>
<li>逻辑链路上的交付不一定遵循FIFO顺序，例如，网络层IPv4无连接服务。</li>
</ul>
<h4 id="FIFO执行"><a href="#FIFO执行" class="headerlink" title="FIFO执行"></a>FIFO执行</h4><ul>
<li>对于所有的$(s, r)\in T$和$(s’, r’)\in T$<ul>
<li>如果$s\sim s’ \And r\sim r’ \And s\prec s’$，则$r\prec r’$($\prec$的意思是顺序，前面先发生，后面后发生)</li>
</ul>
</li>
<li>所有物理链路都遵循FIFO顺序。</li>
<li>逻辑链路本质上是非FIFO的。</li>
<li>为了在非FIFO链路上实现FIFO: <ul>
<li>每条消息中使用$⟨seq_num,conn_id⟩$(序号，连接号)。</li>
<li>接收者使用缓冲区排序消息</li>
<li>例如传输层的面向连接的服务TCP。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Asynchronous%20and%20FIFO%20Executions.png" alt="img"></p>
<ul>
<li>左图是非FIFO执行，右图是FIFO执行</li>
</ul>
<h2 id="因果序-Causal-Order-CO"><a href="#因果序-Causal-Order-CO" class="headerlink" title="因果序(Causal Order, CO)"></a>因果序(Causal Order, CO)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>对于所有$(s, r)\in T$和$(s’, r’)\in T$，如果$r\sim r’$且$s\prec s’$，则$r\prec r’$<ul>
<li>如果发送事件$s$和$s’$通过因果关系相关联(不是物理时间顺序)，那么对应的接收事件$r$和$r’$在所有共同目的地以相同的顺序发生</li>
</ul>
</li>
<li><p>如果$send(m^1)\prec send(m^2)$，则对于消息$m^1, m^2$的每个共同目的地$d$，必须满足$deliver_d(m^1)\prec deliver_d(m^2)$</p>
<ul>
<li>当两个消息由同一进程发送时，CO 退化为 FIFO。</li>
</ul>
</li>
<li><p>用途: 更新共享数据，实现分布式共享内存、公平资源分配、协作应用、事件通知系统、分布式虚拟环境。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Causal%20Order.png" alt="img"></p>
<h3 id="消息的到达与交付"><a href="#消息的到达与交付" class="headerlink" title="消息的到达与交付"></a>消息的到达与交付</h3><ul>
<li>消息到达<ul>
<li>到达操作系统缓冲区的消息$m$在$P_i$可能需要延迟，直到$m$发送之前发送给$P_i$的消息(被超越的)到达</li>
<li>应用程序处理到达消息的事件被称为交付事件(接收不等于交付)</li>
</ul>
</li>
<li>没有消息被一系列消息超越: 同一发送者和接收者对之间没有消息被一系列消息超越</li>
</ul>
<h3 id="CO的其他特征"><a href="#CO的其他特征" class="headerlink" title="CO的其他特征"></a>CO的其他特征</h3><h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><ul>
<li>对于所有$(s, r)$和$(s’, r’)\in T$，如果$s\prec s’$，则$r\prec r’$</li>
</ul>
<h4 id="空区间属性-Empty-Interval-EI"><a href="#空区间属性-Empty-Interval-EI" class="headerlink" title="空区间属性(Empty-Interval, EI)"></a>空区间属性(Empty-Interval, EI)</h4><ul>
<li><p>$(E, \prec)$是一个EI执行，如果对于所有$(s, r)\in T$，在偏序关系中的开区间集合${x\in E | s\prec x\prec r}$为空</p>
<ul>
<li>对于$EI<s, r>$，存在某个线性扩展使得相应的区间${x\in E | s\prec x\prec r}$为空<ul>
<li>线性扩展是一个偏序关系$(E, \prec)$的任何全序关系$(E, \lt)$，其中偏序关系的所有排序关系都被保留</li>
<li>线性扩展中，一个空的$(s, r)$区间意味着$s$和$r$是可以任意接近的，即发送和接收是可以接近的，由垂直箭头表示</li>
</ul>
</li>
<li>执行$E$是CO的，当且仅当对于每个$M$，存在某个时空图，在该图中该消息$M$可以被画为垂直的箭头<ul>
<li>但是CO不能推出所有的消息都可以在同一个时空图中被画成垂直箭头，否则所有的发送和接收$(s, r)$区间在相同的线性扩展中为空，同步执行<ul>
<li>在因果顺序中，事件之间的关系是基于因果关系的偏序关系。这意味着，并非所有事件都可以被直接比较；有些事件可能是并行发生的，即它们之间没有因果关系。如果所有消息都能在同一时空图中画为垂直箭头，那么这将意味着存在一个全序关系，可以对所有事件进行排序。然而，在实际的分布式系统中，由于不同的进程可能有不同的时钟，并且不是所有的事件都具有因果关系，所以无法保证所有事件能够被如此排序。</li>
<li>如果所有消息可以在同一时空图中画为垂直箭头，那意味着我们实际上是在描述一种同步执行的情况。在这种情况下，每个消息的发送和接收事件在所有进程中看起来都是按相同的顺序发生的。然而，现实中的分布式系统通常是异步的，即不同进程的时间线是独立的，消息传递可能会有延迟，而且不同进程的时钟也可能不同步。因此，不可能保证所有消息的发送和接收事件能按照同一个时间线来表示。</li>
<li>对于一个满足因果顺序的执行来说，它并不需要满足空区间属性，意味着，在两个事件s和r之间可能存在其他事件x，这些事件既不在s的过去也不在r的未来。这样的情况就不能简单地通过一条垂直箭头来表示，因为那样会暗示s和r是连续的、中间没有任何其他事件发生。</li>
<li>满足因果顺序的执行允许存在弱共同过去和未来的概念，即一个事件可以发生在消息的发送事件和接收事件之间。如果所有消息都在同一时空图中画为垂直箭头，则意味着不存在这样的中间事件，这与分布式系统的实际情况不符。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="共同过去和未来-Common-Past-and-Future"><a href="#共同过去和未来-Common-Past-and-Future" class="headerlink" title="共同过去和未来(Common Past and Future)"></a>共同过去和未来(Common Past and Future)</h4><ul>
<li>一个执行$(E, \prec)$是CO当且仅当对于每对$(s, r)\in T$和每个事件$e\in E$<ul>
<li>弱共同过去: $e\prec r \Rightarrow \lnot(s\prec e)$</li>
<li>弱共同未来: $s\prec e\Rightarrow \lnot(e\prec r)$</li>
<li>如果$s$和$r$的过去是相同的(或者未来是相同的)，则$e\prec r\Rightarrow e\prec s$和$s\prec e\Rightarrow r\prec e$，得到CO执行的一个子类，即同步执行(synchronous executions)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="同步执行-Synchronous-executions"><a href="#同步执行-Synchronous-executions" class="headerlink" title="同步执行(Synchronous executions)"></a>同步执行(Synchronous executions)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>同步因果关系$&lt;&lt;$在$E$上是最小的传递关系，满足以下条件<ul>
<li>如果事件x在同一进程中发生在事件y之前，则$x&lt;&lt;y$，事件发生在之前则因果在前</li>
<li>如果$(s, r)\in T$，则对于所有$x\in E$，$[(x &lt;&lt; s \Leftrightarrow x &lt;&lt; r)]$，且$[(s &lt;&lt; x \Leftrightarrow r &lt;&lt; x)]$，如果s和r有因果关系，则与s或r有因果关系的事件x也必须保持相同的因果顺序</li>
<li>如果$x&lt;&lt;y \And y &lt;&lt; z$则$x &lt;&lt; z$，因果顺序是传递的</li>
</ul>
</li>
<li>同步执行<ul>
<li>$(E, &lt;&lt;)$是同步执行，其中因果关系$&lt;&lt;$是一个偏序关系</li>
</ul>
</li>
<li>对同步执行进行时间戳<ul>
<li>执行$(E, \prec)$是同步的当且仅当存在从$E$到$T$(标量时间戳)的映射，使得<ul>
<li>对于任何消息$M$，$T(s(M))=T(r(M))$，即发送事件和接收事件具有相同的时间戳</li>
<li>对于每个进程$P_i$，如果$e_i\prec e_i’$，则$T(e_i)\lt T(e_i’)$，之前发生的事件时间戳更小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Synchronous%20Executions1.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/deadlocks%20when%20using%20synchronous%20primitives.png" alt="img"></p>
<h2 id="异步执行与同步通信-Asynchronous-Execution-with-Synchronous-Communication"><a href="#异步执行与同步通信-Asynchronous-Execution-with-Synchronous-Communication" class="headerlink" title="异步执行与同步通信(Asynchronous Execution with Synchronous Communication)"></a>异步执行与同步通信(Asynchronous Execution with Synchronous Communication)</h2><ul>
<li>一个异步系统编写的程序使用同步原语运行(发送和接收必须配对)可能会导致死锁<ul>
<li>死锁发生在两个或多个进程互相等待对方的操作完成，从而无法继续执行。</li>
</ul>
</li>
<li>非RSC执行是指在同步通信下不可实现的异步执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/non-RSC%20A-executions.png" alt="img"></p>
<h3 id="RSC执行"><a href="#RSC执行" class="headerlink" title="RSC执行"></a>RSC执行</h3><ul>
<li><p>Realizable with Synchronous Communication (RSC) 是一个概念，用于描述异步系统中的执行是否可以被解释为等效于同步通信环境下的执行。如果一个异步执行(A-execution)可以通过某种方式重新排序，使得它看起来就像是在一个所有消息传递都是即时完成的同步系统中发生的，那么这个异步执行就是可由同步通信实现的(RSC)。</p>
</li>
<li><p>非分离线性扩展$(E, \prec)$</p>
<ul>
<li>$(E, \prec)$的一个线性扩展，使得对于每一对$(s, r)\in T$，区间${x\in E | s\prec x\prec r}$是空的</li>
</ul>
</li>
<li>RSC执行 <ul>
<li>一个异步执行是一个RSC执行，当且仅当存在一个非分离线性扩展的偏序关系$(E, \prec)$(在所有可能的线性扩展中，至少有一个满足非分离条件。)<ul>
<li>为了确定一个异步执行是否是RSC，我们需要找到一个线性扩展(即对事件的一个全序排列)，在这个排列中，对于每一个消息$m$的发送事件$s(m)$和接收事件$r(m)$，在它们之间的开区间${x\in E | s(m)\prec x\prec r(m)}$是空的。这意味着没有其他事件发生在消息的发送和接收之间，就像同步系统中那样。</li>
<li>检查所有线性扩展具有指数级成本！</li>
<li>实际测试使用Crown皇冠特征化方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Crown测试法"><a href="#Crown测试法" class="headerlink" title="Crown测试法"></a>Crown测试法</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>设$E$是一个执行，在$E$中，大小为k的Crown是一个序列$&lt;(s^i, r^i), i\in {0, 1, …, k-1}&gt;$，其中包含对应发送事件和接收事件配对，满足以下条件:<ul>
<li>$s^0\prec r^1$</li>
<li>$s^1\prec r^2$</li>
<li>…</li>
<li>$s^{k-2}\prec r^{k-1}$</li>
<li>$s^{k-1}\prec r^0$</li>
<li>即在一个大小为k的Crown中，每个发送事件$s^i$都发生在下一个接收事件$r^{i+1}$之前，直到最后一个接收事件$r^0$</li>
</ul>
</li>
<li>在一个Crown中，$s^i$和$r^{i+1}$可能在同一个进程，也可能在不同进程</li>
<li>非CO执行必须有一个Crown</li>
<li>CO执行(非同步的)也会有一个Crown</li>
<li>Crown中的循环依赖关系意味着无法串行地调度消息，因此不是RSC</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Crown%20Test%20for%20RSC%20executions.png" alt="img"></p>
<h4 id="Crown准则"><a href="#Crown准则" class="headerlink" title="Crown准则"></a>Crown准则</h4><ul>
<li>一个执行是RSC的，即它可以实现在具有同步通信的系统上，当且仅当它不包含任何的Crown</li>
<li>复杂度<ul>
<li>$O(|E|)$，$E$为通信事件的数量</li>
</ul>
</li>
</ul>
<h4 id="RSC执行的时间戳"><a href="#RSC执行的时间戳" class="headerlink" title="RSC执行的时间戳"></a>RSC执行的时间戳</h4><ul>
<li>执行$(E, \prec)$是RSC的当且仅当存在从$E$到$T$(标量时间戳)的映射，使得<ul>
<li>对于任何消息$M$，$T(s(M))=T(r(M))$</li>
<li>对于每个$(a, b)\in (E\times E)/T$，$a\prec b \Rightarrow T(a)\lt T(b)$</li>
</ul>
</li>
</ul>
<h3 id="消息排序范式的层次结构"><a href="#消息排序范式的层次结构" class="headerlink" title="消息排序范式的层次结构"></a>消息排序范式的层次结构</h3><h4 id="RSC条件"><a href="#RSC条件" class="headerlink" title="RSC条件"></a>RSC条件</h4><ul>
<li>一个A-execution(这是异步执行)是RSC的当且仅当它是一个S-execution</li>
</ul>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><ul>
<li>$RSC\subset CO\subset FIFO\subset A$<ul>
<li>更小的类对可能的消息排序有更多的限制</li>
<li>并发度最高的是A，最低的是SYNC</li>
<li>使用同步通信的程序最容易开发和验证</li>
<li>使用非FIFO通信的程序，导致A-execution，最难设计和验证</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Hierarchy%20of%20Message%20Ordering%20Paradigms.png" alt="img"></p>
<h3 id="异步原语在同步系统上模拟执行"><a href="#异步原语在同步系统上模拟执行" class="headerlink" title="异步原语在同步系统上模拟执行"></a>异步原语在同步系统上模拟执行</h3><ul>
<li><p>使发送者与接收者解耦，但这种实现成本较高。</p>
</li>
<li><p>按照消息在同步程序(S-program)中出现的顺序进行调度。</p>
<ul>
<li>如果同步程序中消息$m_1$先于消息$m_2$出现，则在异步系统上也应按此顺序调度这些消息。</li>
</ul>
</li>
<li>同步执行(S-execution)中的偏序关系保持不变。如果在同步执行中消息$m_1$必须先于消息$m_2$发送，则在异步系统上也必须保持</li>
<li>在异步系统上使用异步原语进行通信。发送和接收无需立即完成，可以在后台异步处理</li>
<li>当同步发送被调度时: 等待确认(ack)后再完成发送。发送方阻塞直到收到确认</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Async%20Programs%20on%20Sync%20Systems.png" alt="img"></p>
<h3 id="异步系统上模拟同步程序的顺序执行"><a href="#异步系统上模拟同步程序的顺序执行" class="headerlink" title="异步系统上模拟同步程序的顺序执行"></a>异步系统上模拟同步程序的顺序执行</h3><ul>
<li>确定性程序<ul>
<li>确定性接收: 重复运行产生相同的偏序关系。意味着确定性执行，即$(E, \prec)$是固定的</li>
</ul>
</li>
<li>非确定性(除了由于不可预测的消息延迟): <ul>
<li>接收调用不指定发送者。</li>
<li>多个发送和接收在一个进程中启用；可以以可交换的顺序执行。<ul>
<li>$G_1\rightarrow CL_1 || G_2\rightarrow CL_2 || \dots|| G_k\rightarrow CL_k$</li>
</ul>
</li>
</ul>
</li>
<li>如何在异步系统上调度非确定性的同步通信调用？<ul>
<li>用相应的事件匹配发送或接收</li>
</ul>
</li>
<li>二元会合(Binary rendezvous, 使用令牌实现)<ul>
<li>每个启动的交互有一个令牌</li>
<li>在线、原子地、分布式地进行调度</li>
<li>无Crown调度(安全性): 也保证进度</li>
<li>调度中的公平性和效率</li>
</ul>
</li>
</ul>
<h4 id="Bagrodia-的二元会合-Binary-Rendezvous-算法"><a href="#Bagrodia-的二元会合-Binary-Rendezvous-算法" class="headerlink" title="Bagrodia 的二元会合(Binary Rendezvous)算法"></a>Bagrodia 的二元会合(Binary Rendezvous)算法</h4><ul>
<li>假设: <ul>
<li>接收总是启用的，这意味着任何进程都可以随时接收消息</li>
<li>发送一旦启用，就保持启用状态。这意味着一旦进程开始发送消息，它将继续发送直到完成</li>
<li>为了打破死锁，使用进程标识符(PIDs)引入不对称性</li>
<li>每个进程一次只调度一个发送</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous%200.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous.png" alt="img"></p>
<ul>
<li>消息类型:<ul>
<li>$M$: 普通消息</li>
<li>$ack(M)$: 确认消息</li>
<li>$request(M)$: 请求发送消息</li>
<li>$permission(M)$: 响应发送请求</li>
</ul>
</li>
<li>进程在知道它可以成功同步当前消息时阻塞</li>
<li>防止消息循环死锁的措施:<ul>
<li>高优先级阻塞: 高优先级进程发送消息后，阻塞自身等待低优先级进程的确认。</li>
<li>低优先级非阻塞: 低优先级进程发送要发送消息的请求后，等待高优先级进程的许可。不需要阻塞等待<ul>
<li>高优先级进程返回许可后得阻塞直到收到低优先级进程发送的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Bagrodia%20Algorithm%20for%20Binary%20Rendezvous%201.png" alt="img"></p>
<h2 id="组通信-Group-Communication"><a href="#组通信-Group-Communication" class="headerlink" title="组通信(Group Communication)"></a>组通信(Group Communication)</h2><h3 id="单播、多播和广播"><a href="#单播、多播和广播" class="headerlink" title="单播、多播和广播"></a>单播、多播和广播</h3><ul>
<li>单播: 消息从一个发送者发送给一个接收者。</li>
<li>多播: 消息从一个发送者发送给一组接收者。</li>
<li>广播: 消息从一个发送者发送给所有接收者。</li>
</ul>
<h3 id="网络层或硬件辅助多播难以提供的功能"><a href="#网络层或硬件辅助多播难以提供的功能" class="headerlink" title="网络层或硬件辅助多播难以提供的功能"></a>网络层或硬件辅助多播难以提供的功能</h3><ul>
<li>应用特定的消息传递顺序语义: 不同的应用程序可能需要不同的消息传递顺序</li>
<li>适应动态成员变化: 组成员可能会动态加入或离开</li>
<li>每次发送时将多播消息发送到任意进程集: 发送者可以选择不同的接收者集合</li>
<li>提供多种容错语义: 不同的容错策略可能适用于不同的应用场景</li>
</ul>
<h3 id="封闭组与开放组"><a href="#封闭组与开放组" class="headerlink" title="封闭组与开放组"></a>封闭组与开放组</h3><ul>
<li>封闭组: 组成员固定，不允许动态加入或离开</li>
<li>开放组: 组成员可以动态加入或离开</li>
</ul>
<h3 id="Raynal-Schiper-Toueg-RST-算法"><a href="#Raynal-Schiper-Toueg-RST-算法" class="headerlink" title="Raynal-Schiper-Toueg (RST) 算法"></a>Raynal-Schiper-Toueg (RST) 算法</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Raynal-Schiper-Toueg%20(RST" alt="img">%20Algorithm.png)</p>
<ul>
<li><p>假设</p>
<ul>
<li>FIFO通道</li>
<li>活跃性: 假设没有故障，传播时间是有限的</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>SENT: 二维数组$SENT[1…n, 1…n]$，其中n是系统的进程数量。$SENT[i, j]$表示进程$P_i$发送给进程$P_j$的最后一条消息的序列号</li>
<li>DELIV: 一维数组，表示每个进程已经本地交付的消息数量</li>
</ul>
</li>
<li><p>消息格式</p>
<ul>
<li>每条消息不仅包含本身内容，还附带发送者的$SENT$数组副本，接收者可以了解到所有其他进程的最新消息状态</li>
</ul>
</li>
<li><p>发送事件: 当进程$P_i$想要向进程$P_j$发送消息时</p>
<ul>
<li>更新自身的$SENT$数组，增加$SENT[i, j]$</li>
<li>构建消息为$(M, SENT)$，其中$M$是实际消息内容，$SENT$是当前进程$P_i$的整个$SENT$数组</li>
</ul>
</li>
<li><p>接收事件: 当进程$P_i$收到一条来自进程$P_j$的消息$(M, ST)$</p>
<ul>
<li>首先检查是否可以立即交付这条消息，对于每一个进程$x$，如果$DELIV[x] &gt;= ST[x, i]$，那么就可以安全地交付消息$M$给进程$P_i$<ul>
<li>因为是异步的，所以可能后续先到达，如果没有因果序可以先交付，就会有这个情况。</li>
</ul>
</li>
<li>更新自己的$SENT$数组反映从$P_j$接收到的新信息，设置$max(SENT[x, y], ST[x, y])$</li>
<li>更新$DELIV[j]$，因为已经接收到并准备交付来自$P_j$的新消息</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>空间复杂度<ul>
<li>每个进程: $O(n^2)$</li>
<li>每条消息: $O(n^2)$</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>每次发送和接收事件: $O(n^2)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最优的-KS-算法-Optimal-KS-Algorithm"><a href="#最优的-KS-算法-Optimal-KS-Algorithm" class="headerlink" title="最优的 KS 算法(Optimal KS Algorithm)"></a>最优的 KS 算法(Optimal KS Algorithm)</h3><ul>
<li>$M_{i, a}$: 进程$P_i$发送的第a个多播消息</li>
</ul>
<h4 id="正确性交付条件"><a href="#正确性交付条件" class="headerlink" title="正确性交付条件"></a>正确性交付条件</h4><ul>
<li>消息$M’$携带信息$d\in M.Dests$，其中消息$M$在$Send(M’)$的因果过去被发送到$d$，如果$M$尚未被交付给$d$，则$M’$也不会交付给$d$</li>
</ul>
<h4 id="优化的必要和充分条件"><a href="#优化的必要和充分条件" class="headerlink" title="优化的必要和充分条件"></a>优化的必要和充分条件</h4><ul>
<li>存储和捎带信息的事件<ul>
<li>考虑信息$d\in M_{i, a}.Dests$应该在进程的日志中存储多长时间，并且应该捎带在信息上</li>
<li>只要且只有当以下两个传播约束成立时，需要捎带:<ul>
<li>约束1: 向后不可达性，确保消息不会过早被交付。未知消息$M_{i, a}$是否已经被交付给$d$</li>
<li>约束2: 向前可达性，未知是否已经向$d$发送了在$Send(M<em>{i, a})$因果未来的消息，因此不能保证使用基于传递性的推理来确保消息$M</em>{i, a}$将被交付给$d$</li>
</ul>
</li>
<li>如果两个约束为假，则信息$d\in M.Dests$必须不被存储或传播</li>
</ul>
</li>
<li>关于消息的两个约束条件使用$(source, ts, dest)$显示跟踪<ul>
<li>一旦有约束变为假，立即删除</li>
<li>每个多播消息显式跟踪$(source, timestamp, destination)$信息，并存储在日志Log和$O_M$中。</li>
</ul>
</li>
<li>关于消息两个约束的隐式跟踪无需存储或传播<ul>
<li>可以从显示信息推导</li>
<li>用于确定何时两个约束的显示信息变为假，该消息被存储/捎带</li>
<li>类型1: 存在$d\in M<em>{i, a}.Dests$且$d\notin l</em>{i, a}.Dests\vee d\notin o_{i, a}.Dests$<ul>
<li>当$l<em>{i, a}.Dests=\empty$或$o</em>{i, a}.Dests = \empty$</li>
</ul>
</li>
<li>类型2: 如果$a<em>1\lt a_2$且$l</em>{i, a<em>2}\in LOG_j$，则$l</em>{i, a_1}\in LOG_j$<ul>
<li>形如$l_{i, a}.Dests=\empty$的条目可以通过缺失推断，不应存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Code1.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Code2.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Optimal%20KS%20Algorithm%20for%20CO%20Example.png" alt="img"></p>
<h2 id="Total-Order"><a href="#Total-Order" class="headerlink" title="Total Order"></a>Total Order</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul>
<li>对于每一对进程$P_i$和$P_j$，以及每一对消息$M_x$和$M_y$，如果两个消息都被两个进程接收，则<ul>
<li>$P_i$在交付$M_x$之前交付$M_y$，当且仅当$P_j$在交付$M_x$之前交付$M_y$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Group%20Communication.png" alt="img"></p>
<h3 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h3><ul>
<li>当$P_i$想要广播消息$M$到组$G$时<ul>
<li>发送$M(i, G)$到协调器</li>
</ul>
</li>
<li>当$M(i, G)$从$P_i$到达协调器<ul>
<li>发送$M(i, G)$到组G的各成员</li>
</ul>
</li>
<li>当$M(i, G)$从协调器到达$P_j$<ul>
<li>交付$M(i, G)$到应用</li>
</ul>
</li>
<li>复杂度<ul>
<li>时间复杂度: 每次传输要2次hop</li>
<li>消息数量复杂度: n</li>
</ul>
</li>
</ul>
<h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Total%20Message%20Order%203-phase%20Algorithm%20Code.png" alt="img"></p>
<p> <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Total%20Order%20Distributed%20Algorithm%20Example.png" alt="img"> </p>
<ul>
<li>复杂度<ul>
<li>三个阶段</li>
<li>n-1个目的地需要$3(n-1)$条消息</li>
<li>延迟: 3个消息跳数</li>
</ul>
</li>
<li>也能实现因果序</li>
</ul>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><h3 id="目的地关系四种分类"><a href="#目的地关系四种分类" class="headerlink" title="目的地关系四种分类"></a>目的地关系四种分类</h3><ul>
<li>SSSG (Single Source Single Group): 单个源和单个目的地组，容易实现</li>
<li>MSSG (Multiple Sources Single Group): 多个源和单个目的地组，容易实现(集中式算法)</li>
<li>SSMG (Single Source Multiple Groups): 单个源和多个，可能重叠的目的地组，容易实现</li>
<li>MSMG (Multiple Sources Multiple Groups): 多个源和多个，可能重叠的目的地组，半集中式的传播树算法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/A%20Nomenclature%20for%20Multicast.png" alt="img"></p>
<h3 id="用于多播的传播树-Propagation-Trees"><a href="#用于多播的传播树-Propagation-Trees" class="headerlink" title="用于多播的传播树(Propagation Trees)"></a>用于多播的传播树(Propagation Trees)</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul>
<li>组集: $G = {G_1, …, G_g}$</li>
<li>元组集: $MG = {MG_1, \dots, MG_h}$<ul>
<li>每个进程属于一个元组，并且在该元组中的每个其他进程具有完全相同的组成员资格</li>
<li>元组之外没有其他进程具有该确切的组成员资格</li>
</ul>
</li>
<li>转换<ul>
<li>多源多组(MSMG)到组 $\rightarrow$多源单组(MSSG)到元组</li>
</ul>
</li>
<li><p>管理节点</p>
<ul>
<li>每个元组中有一个区分的节点作为管理者</li>
</ul>
</li>
<li><p>传播森林/树</p>
<ul>
<li>所有元组组织成一个传播森林/树，满足以下条件<ul>
<li>对于用户组$G_i$, $PM(G_i)$位于树的最低可能就级别(离根最远)，使得所有目标包含$G_i$中任何节点的元组都属于以$PM(G_i)$为根的子树</li>
</ul>
</li>
</ul>
</li>
<li>传播树不是唯一的<ul>
<li>具有来自更多用户组成员的元组作为根节点，使得树高度较低</li>
</ul>
</li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul>
<li><p>主元组($PM(G)$)</p>
<ul>
<li>对于每个用户组$G_i$，选择其中一个元组作为其主元组(PM)，记为$PM(G_i)$   </li>
<li>传播树中所有其他元组的祖先   </li>
<li>唯一定义的   </li>
<li>对于任何元组$MG$，从该元组所属的任何用户组的主元组到$MG$都有一条唯一的路径</li>
<li>任何$PM(G_1)$和$PM(G_2)$要么位于同一棵树的同一分支上，要么位于不同的树上。在后一种情况下，它们的组成员集合是不相交的。</li>
<li>多播消息首先发送到元组$PM(G_i)$，因为只有以$PM(G_i)$为根的子树可以包含$G_i$中的节点。随后消息沿着以$PM(G_i)$为根的子树向下传播</li>
</ul>
</li>
<li><p>元组之间的关系   </p>
<ul>
<li>$MG_1$包含$MG_2$，如果$MG_1$是每个用户组$G$的子集，而$MG_2$也是这些用户组的子集</li>
<li>$MG_1$和$MG_2$相交，如果两者都不包含对方，且存在某个组$G$，使得$MG_1, MG_2\subset G$</li>
</ul>
</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20Example.png" alt="img"></p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20(CO%20and%20TO" alt="img">%20Code.png)</p>
<ul>
<li>每个进程都知道传播树</li>
<li>每个元组都有一个用于区分的进程(manager)</li>
<li>$SV_i[k]$在每个$P_i$处: 由$P_i$多播的消息数量，这些消息通过$PM(G_k)$传播。附带在每个由$P_i$发送的多播消息上</li>
<li>$RV_{manager(PM(G_z))}[k]$: 由$P_k$发送并被$PM(G_z)$接收的消息的数量</li>
<li>$manager(PM(G<em>z))$: 如果$SV_i[z]==RV</em>{manager(PM(G_z))}[i]$，则处理来自$P_i$的消息$M$，否则缓冲消息$M$直到条件成立</li>
<li>在非主元组的管理者处: 消息顺序已经确定，因为它从未直接从多播发送者接收消息。转发(伪代码的2d-2g)。</li>
</ul>
<h3 id="Total-Order的正确性"><a href="#Total-Order的正确性" class="headerlink" title="Total Order的正确性"></a>Total Order的正确性</h3><ul>
<li>考虑$MG_1, MG_2\subset G_x, G_y$<ul>
<li>$PM(G_x), PM(G_y)$都包含$MG_1, MG_2$，并且位于传播树的同一个分支上，终点是$MG_1$或$MG_2$</li>
<li>由树下主元组(+FIFO)看到的顺序等于由被它包含的元组中的进程看到的顺序</li>
</ul>
</li>
</ul>
<h3 id="因果序的正确性-Causal-order"><a href="#因果序的正确性-Causal-order" class="headerlink" title="因果序的正确性(Causal order)"></a>因果序的正确性(Causal order)</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Propagation%20Trees%20for%20Multicast%20Correctness%20for%20CO.png" alt="img"></p>
<h3 id="应用级多播算法"><a href="#应用级多播算法" class="headerlink" title="应用级多播算法"></a>应用级多播算法</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Classification%20of%20Application-Level%20Multicast%20Algorithms.png" alt="img"></p>
<ul>
<li>基于通信历史的算法: RST, KS, Lamport, NewTop</li>
<li>基于特权的算法: Token-holder多播<ul>
<li>进程按 seq_no 的顺序传递消息</li>
<li>通常是封闭组，并且保证因果排序(CO)和总排序(TO)</li>
<li>示例：Totem, On-demand</li>
</ul>
</li>
<li>移动排序器算法: Change-Maxemchuck, Pinwheel<ul>
<li>排序器的令牌包含 seq_no 和已分配 seq_no 的消息列表(这些是发送的消息)</li>
<li>在接收令牌时，排序器为收到但未排序的消息分配 seq_nos，并将新排序的消息发送到目的地</li>
<li>目的地按 seq_no 的顺序传递消息</li>
</ul>
</li>
<li>固定排序器算法: 简化移动排序器的方法<ul>
<li>传播树、ISIS、Amoeba、Phoenix、Newtop-asymmetric</li>
</ul>
</li>
<li>目的地协议算法: 目的地接收有限的排序信息<ul>
<li>基于时间戳的(Lamport 的三阶段)</li>
<li>基于协议的，目的地之间达成一致</li>
</ul>
</li>
</ul>
<h3 id="容错多播的语义"><a href="#容错多播的语义" class="headerlink" title="容错多播的语义"></a>容错多播的语义</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>多播是非原子的！</li>
<li>在故障期间有明确定义的行为 $\Rightarrow$ 明确定义的恢复动作<ul>
<li>(统一)规范：指定故障进程的行为(良性故障模型)</li>
</ul>
</li>
</ul>
<h4 id="统一可靠的多播"><a href="#统一可靠的多播" class="headerlink" title="统一可靠的多播"></a>统一可靠的多播</h4><ul>
<li>有效性: 如果一个正确进程多播了消息 $M$，那么所有正确进程最终都会交付$M$。</li>
<li>(统一)一致性: 如果一个正确(或故障)进程交付了消息$M$，那么所有正确进程最终都会交付$M$。</li>
<li>(统一)完整性: 每个正确(或故障)进程最多交付一次消息$M$，并且仅当$M$之前由发送者多播时。</li>
<li>(统一)FIFO顺序: 如果一个进程在广播$M$之前广播了$M’$，那么没有正确(或故障)进程会在未先交付$M$的情况下交付$M’$</li>
<li>(统一)因果顺序: 如果一个进程在因果上先广播$M$再广播了$M’$，那么没有正确(或故障)进程会在未先交付$M$的情况下交付$M’$</li>
<li>(统一)总顺序: 如果正确(或故障)进程a和b都交付了$M$和$M’$，那么a在交付$M$之前交付$M’$当且仅当b在交付$M$之前交付$M’$</li>
</ul>
<h4 id="基于全局时钟或本地时钟的规范-需要时钟同步"><a href="#基于全局时钟或本地时钟的规范-需要时钟同步" class="headerlink" title="基于全局时钟或本地时钟的规范(需要时钟同步)"></a>基于全局时钟或本地时钟的规范(需要时钟同步)</h4><ul>
<li>(统一)Real Time $\Delta$-Timeliness: 对于某个已知的常数$\Delta$，如果$M$在实际时间$t$被多播，那么没有正确(或故障)进程在实际时间$t+\Delta$之后交付$M$，要求在此之前交付</li>
<li>(统一)Local $\Delta$-Timeliness: 对于某个已知的常数$\Delta$，如果$M$在本地时间$t_m$被多播，那么没有正确(或故障)进程在其本地时间$t_m+\Delta$之后交付$M$，要求在此之前交付</li>
</ul>
<h3 id="反向路径转发-Reverse-Path-Forwarding-RPF"><a href="#反向路径转发-Reverse-Path-Forwarding-RPF" class="headerlink" title="反向路径转发(Reverse Path Forwarding, RPF)"></a>反向路径转发(Reverse Path Forwarding, RPF)</h3><ul>
<li>用于受限泛洪</li>
<li>网络层多播利用拓扑结构<ul>
<li>例如，桥接局域网(LANs)使用生成树学习目的地并分发信息</li>
<li>IP层RPF近似于DVR/LSR类似算法，但成本更低</li>
</ul>
</li>
<li>主要特点<ul>
<li>广播被限制以近似生成树</li>
<li>近似的根生成树被识别出来，而无需计算或存储</li>
<li>消息数量更接近$|N|$节点数，而不是$|L|$边数</li>
</ul>
</li>
<li>具体步骤<ul>
<li>当进程$P_i$想要向组Dest发送消息$M$<ul>
<li>在所有出站链路上发送$M(i, Dest)$</li>
</ul>
</li>
<li>当节点i从节点j接收到消息$M(x, Dest)$<ul>
<li>如果$Next_hop(x) = j$，则这将是一个新消息</li>
<li>向除(i, j)以外的所有其他入站链路转发$M(x, Dest)$</li>
<li>否则忽略该消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Kou-Markowsky-Berman（KMB）启发式算法"><a href="#Kou-Markowsky-Berman（KMB）启发式算法" class="headerlink" title="Kou-Markowsky-Berman（KMB）启发式算法"></a>Kou-Markowsky-Berman（KMB）启发式算法</h3><ul>
<li>应用于Steiner树问题 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Kou-Markowsky-Berman%20Heuristic%20for%20Steiner%20Tree.png" alt="img"></p>
<h3 id="受约束的-延迟受限的-Steiner树-Constrained-Delay-bounded-Steiner-Trees"><a href="#受约束的-延迟受限的-Steiner树-Constrained-Delay-bounded-Steiner-Trees" class="headerlink" title="受约束的(延迟受限的)Steiner树(Constrained Delay-bounded Steiner Trees)"></a>受约束的(延迟受限的)Steiner树(Constrained Delay-bounded Steiner Trees)</h3><ul>
<li>对于给定的延迟容忍度$\Delta$，给定的源节点$s$和目标节点集$Dest$，其中${s}\bigcup Dest = N’\subset N$，识别一个覆盖所有$N’$中节点的生成树$T$，满足以下约束条件: <ul>
<li>$\sum_{l\in T} C(l)$最小化，其中$C(l)$是边的成本</li>
<li>对于所有$v\in N’$，路径$path(s, v)$上的所有边l的延迟之和$\sum_{l\in path(s, v)}D(l)\lt \Delta$，其中$path(s, v)$表示从s到v在T中的路径<ul>
<li>路径的成本和延迟分别表示为$C(x, y), D(x, y)$</li>
</ul>
</li>
<li>受约束的最便宜路径是从x到y的路径，其延迟要小于$\Delta$</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Constrained%20(Delay-Bounded" alt="img">%20Steiner%20Trees%20Algorithm.png)</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Constrained%20(Delay-Bounded" alt="img">%20Steiner%20Trees%20Example.png)</p>
<ul>
<li>启发式算法<ul>
<li>启发式$CST_{CD}$: 尝试选择低成本的边，同时尽量最大化剩余允许的延迟</li>
<li>启发式$CST_C$: 确保满足延迟界限的同时最小化成本</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>找到所有节点上的受约束最短路径，$O(n^3\Delta)$(主导步骤)</li>
<li>在闭合图上构建受约束的最小生成树，该图有k个节点，$O(k^3)$</li>
<li>扩展受约束的生成树<ul>
<li>涉及将k条边扩展到最多n-1条边，并消除环路，$O(kn)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于核心的多播树"><a href="#基于核心的多播树" class="headerlink" title="基于核心的多播树"></a>基于核心的多播树</h3><ul>
<li>多播树动态构建，按需增长</li>
<li>每个组都有一个或多个核心节点</li>
<li>希望加入树作为接收者的节点<ul>
<li>发送单播加入消息到核心节点</li>
</ul>
</li>
<li>加入过程标记边<ul>
<li>加入消息在传输过程中标记边；它要么到达核心节点，要么到达已经属于树的一部分的某个节点</li>
<li>从加入消息开始到核心/多播树的路径被嫁接到多播树上</li>
</ul>
</li>
<li>树上的节点进行多播<ul>
<li>使用核心树上的泛洪来多播消息</li>
</ul>
</li>
<li>不在树上的节点<ul>
<li>向核心节点发送消息；一旦消息到达树上的任何节点，它就在树上泛洪</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高级分布式系统</category>
      </categories>
      <tags>
        <tag>高级分布式系统</tag>
      </tags>
  </entry>
</search>
