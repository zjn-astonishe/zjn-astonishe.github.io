<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>基准评测集 | ZJN_BLOG</title><meta name="keywords" content="高级计算机体系结构"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基准评测集计算机性能 计算机性能: 通常指机器的速度，程序执行时间的倒数 程序执行时间(Wall-clock time, response time, or elapsed time): 指用户的响应时间(访问磁盘和访问存储器的时间，CPU时间，I&#x2F;O时间以及操作系统的开销) CPU时间: 表示CPU的工作时间，不包括I&#x2F;O等待时间和运行其他任务的时间  The Processor Perform">
<meta property="og:type" content="article">
<meta property="og:title" content="基准评测集">
<meta property="og:url" content="http://zjn-astonishe.github.io/2024/09/25/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-09-25-%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="基准评测集计算机性能 计算机性能: 通常指机器的速度，程序执行时间的倒数 程序执行时间(Wall-clock time, response time, or elapsed time): 指用户的响应时间(访问磁盘和访问存储器的时间，CPU时间，I&#x2F;O时间以及操作系统的开销) CPU时间: 表示CPU的工作时间，不包括I&#x2F;O等待时间和运行其他任务的时间  The Processor Perform">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2024-09-25T07:36:36.000Z">
<meta property="article:modified_time" content="2024-11-09T04:33:57.469Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="高级计算机体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2024/09/25/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-09-25-%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基准评测集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-09 12:33:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基准评测集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-25T07:36:36.000Z" title="发表于 2024-09-25 15:36:36">2024-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-09T04:33:57.469Z" title="更新于 2024-11-09 12:33:57">2024-11-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">高级计算机体系结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基准评测集"><a href="#基准评测集" class="headerlink" title="基准评测集"></a>基准评测集</h1><h2 id="计算机性能"><a href="#计算机性能" class="headerlink" title="计算机性能"></a>计算机性能</h2><ul>
<li>计算机性能: 通常指机器的速度，程序执行时间的倒数</li>
<li>程序执行时间(Wall-clock time, response time, or elapsed time): 指用户的响应时间(访问磁盘和访问存储器的时间，CPU时间，I/O时间以及操作系统的开销)</li>
<li>CPU时间: 表示CPU的工作时间，不包括I/O等待时间和运行其他任务的时间</li>
</ul>
<h3 id="The-Processor-Performance-Equation"><a href="#The-Processor-Performance-Equation" class="headerlink" title="The Processor Performance Equation"></a>The Processor Performance Equation</h3><ul>
<li>CPU time for a program can then be expressed two ways: <ul>
<li>CPU time = CPU clock cycles for a program x Clock cycle time(CPU时间 = 一个程序的CPU时钟周期 x 时钟周期时间)</li>
<li>CPU time = CPU clock cycles for a program / Clock rate(CPU时间 = 一个程序的CPU时钟周期 / 时钟频率，与上面的公式是一样的，因为时钟周期时间和时钟频率互为倒数)</li>
<li>CPU time = Instruction count(Total Instruction Count / Program) x Cycles per instruction(Total Clock cycles / Total Instructin Count) x Clock cycle time(Toal Cost Seconds / Total Clock cycle)(CPU时间 = 指令数量 x 每条指令所需的时钟周期数 x 时钟周期时间) = Total Cost Seconds / Total Program Num(每个程序执行的时间)<ul>
<li>clock cycles per instruction(CPI): CPI = CPU clock cycles for a program / Instruction count(每条指令所需的时钟周期数CPI = 一个程序的CPU时钟周期 / 指令的条数)</li>
</ul>
</li>
</ul>
</li>
<li>Different instruction types having different CPIs(不同的指令集类型有不同的CPI)<ul>
<li>$CPU\quad clock\quad cycles = \Sigma_{i = 1}^n IC_i \times CPI_i$(总的CPU时钟周期数为各种指令集的时钟周期数之和)</li>
<li>$CPU\quad time = (\Sigma_{i = 1}^n IC_i \times CPI_i) \times Clock\quad cycle\quad time$</li>
</ul>
</li>
<li><p>Overall CPI(整体的CPI，所有指令集类型的加权平均)</p>
<ul>
<li>$CPI = \frac{\Sigma_{i=1}^n IC_i \times CPI_i}{Instruction\quad count} = \Sigma——{i=1}^n \frac{IC_i}{Instruction\quad count} \times CPI_i$</li>
</ul>
</li>
<li><p>It is difficult to change one parameter in completet isolation from others(Clock cycle time, CPI and Instruction count)</p>
<ul>
<li>Clock cycle time: Hardware technology and organization(取决于硬件和组织)</li>
<li>CPI: Organization and instruction set architecture(取决于组织和指令集架构)</li>
<li>Instruction count: Instruction set architecture and compiler technology(取决于指令集架构和编译技术)</li>
</ul>
</li>
<li><p>具体影响因素</p>
<ul>
<li>算法<ul>
<li>影响程序的执行指令数(Instruction Count)</li>
<li>好的算法可以大幅度减少运算的次数，从而大幅度减少执行的指令数</li>
</ul>
</li>
<li>编程语言<ul>
<li>影响程序的执行指令数(Instruction Count)</li>
<li>编程语言可能对执行指令数产生巨大的影响，例如: 解释执行、即时编译或者原生编译的三大类语言完成同样的功能所需要的指令数可能有数量级的差异</li>
</ul>
</li>
<li>编译器和库<ul>
<li>影响程序的执行指令数(Instruction Count)和CPI</li>
<li>编译器和库决定了源程序到计算机指令的翻译过程，编译程序的效率既影响到程序的执行指令数，又影响到CPI(Intel的ICC编译器编译出来的程序，效率比GCC高30%，因为ICC充分利用向量化指令和针对处理器结构进行了优化)</li>
</ul>
</li>
<li>指令系统结构<ul>
<li>影响程序的执行指令数(Instruction Count)、CPI和时钟频率</li>
</ul>
</li>
<li>微体系结构<ul>
<li>影响CPI和时钟频率</li>
<li>微体系结构的改进可以降低CPI，细分流水线提高时钟频率</li>
</ul>
</li>
<li>物理设计<ul>
<li>影响时钟频率</li>
<li>物理设计和电路的进步可以降低时钟周期，从而提高时钟频率(倒数)</li>
</ul>
</li>
<li>工艺<ul>
<li>影响时钟频率</li>
<li>工艺的进步使得晶体管变快从而提高时钟频率</li>
</ul>
</li>
</ul>
</li>
<li><p>MIPS(Million Instruction Per Second，每秒百万次指令数，用于不同计算机横向比较，忽略了不同指令系统之间的差异)</p>
<ul>
<li>$MIPS = \frac{I_N}{(T_E \times 10^6)} = \frac{R_C}{CPI\times 10^6}$<ul>
<li>$T_E$表示程序执行时间</li>
<li>$R_C$表示时钟速率，$T_C$的倒数</li>
<li>$I_N$表示指令数量</li>
</ul>
</li>
<li>相对MIPS: $MIPS<em>{Rel} = (\frac{T</em>{Ref}}{T<em>V} \times MIPS</em>{Ref}$<ul>
<li>$MIPS<em>{Ref}$和$T</em>{Ref}$为参照机器的执行时间和MIPS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="FLOPS-Floating-point-Operations-Per-Second-每秒浮点运算次数"><a href="#FLOPS-Floating-point-Operations-Per-Second-每秒浮点运算次数" class="headerlink" title="FLOPS(Floating-point Operations Per Second, 每秒浮点运算次数)"></a>FLOPS(Floating-point Operations Per Second, 每秒浮点运算次数)</h3><ul>
<li>$MFLOPS = \frac{I_{FN}}{(T_E \times 10^6)}$<ul>
<li>$I_{FN}$表示程序中的浮点运算次数</li>
<li>一般认为在标量计算机中执行一次浮点运算平均需要3条指令<ul>
<li>$1FLOPS \approx 3MIPS$</li>
</ul>
</li>
<li>每秒百万次浮点运算次数(Mega Floating-point Operations Per Second, MFLOPS, megaFLOPS,  MFlop/s)</li>
<li>每秒十亿次浮点运算次数(Giga Floating-point Operations Per Second, GFLOPS, gigaFLOPS, GFlop/s)</li>
<li>每秒万亿次浮点运算次数(Tera Floating-point Operations Per Second,TFLOPS,teraFLOPS,TFlop/s)</li>
<li>每秒千万亿次浮点运算次数(Peta Floating-point Operations Per Second,PFLOPS,petaFLOPS,PFlop/s)</li>
<li>每秒百亿亿次浮点运算次数(Exa Floating-point Operations Per Second,EFLOPS,exaFLOPS,EFlop/s)</li>
</ul>
</li>
</ul>
<h3 id="其他性能"><a href="#其他性能" class="headerlink" title="其他性能"></a>其他性能</h3><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.png" alt="img"></p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li>提高计算机的使用效率</li>
<li>减少用户购机的盲目性，降低投资的风险</li>
<li>改进系统结构设计，提高机器的性能</li>
<li>促进软/硬件结合，合理功能划分</li>
<li>优化“结构-算法-应用”的最佳组合</li>
<li>提供客观、公正的评价计算机的标准</li>
</ul>
<h3 id="机器级性能评测"><a href="#机器级性能评测" class="headerlink" title="机器级性能评测"></a>机器级性能评测</h3><h4 id="CPU的某些基本性能指标"><a href="#CPU的某些基本性能指标" class="headerlink" title="CPU的某些基本性能指标"></a>CPU的某些基本性能指标</h4><ul>
<li>工作负载<ul>
<li>执行时间</li>
<li>浮点运算数</li>
<li>指令数目</li>
</ul>
</li>
<li>总时间$T_n$ = 并行执行时间$T_comput$ + 并行开销时间$T_paro$ + 相互通信时间$T_comm$</li>
</ul>
<h4 id="存储器的某些基本性能指标"><a href="#存储器的某些基本性能指标" class="headerlink" title="存储器的某些基本性能指标"></a>存储器的某些基本性能指标</h4><ul>
<li>层次结构<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="img"></li>
<li>带宽</li>
</ul>
<h4 id="并行和通信开销的分析"><a href="#并行和通信开销的分析" class="headerlink" title="并行和通信开销的分析"></a>并行和通信开销的分析</h4><h4 id="计算机的可用性与好用行以及机器成本、价格与性价比"><a href="#计算机的可用性与好用行以及机器成本、价格与性价比" class="headerlink" title="计算机的可用性与好用行以及机器成本、价格与性价比"></a>计算机的可用性与好用行以及机器成本、价格与性价比</h4><ul>
<li>机器的性价比(Performance/Cost Ratio)指用单位代价(以百万美元表示)所获取的性能(MIPS或GFLOPS)</li>
<li>利用率(Utilization): 可达到的速度与峰值速度之比</li>
</ul>
<h3 id="算法级性能评测"><a href="#算法级性能评测" class="headerlink" title="算法级性能评测"></a>算法级性能评测</h3><h4 id="加速比-Speedup"><a href="#加速比-Speedup" class="headerlink" title="加速比(Speedup)"></a>加速比(Speedup)</h4><ul>
<li><p>并行系统的加速比指对于一个给定的应用，并行算法(并行程序)的执行速度相对于串行算法(串行程序)的执行速度加快了多少倍</p>
</li>
<li><p>符号: </p>
<ul>
<li>$P$: 处理器数</li>
<li>$W$: 问题规模(计算负载、工作负载、给定问题的总计算量)<ul>
<li>$W_S$: 应用程序中的串行分量，$f$是串行分量比例($f = \frac{W_S}{W}$)</li>
<li>$W_P$: 应用程序中可并行化的部分，$(1-f)$为并行分量的比例</li>
<li>$W_S + W_P = W$: </li>
</ul>
</li>
<li>$T_S = T_1$: 串行执行时间</li>
<li>$T_P$: 并行执行时间</li>
<li>$S$: 加速比</li>
<li>$E$: 效率</li>
</ul>
</li>
<li><p>Speedup of computer X relative to computer Y(相对加速比)</p>
<ul>
<li>$n = \frac{Execution\quad time_Y}{Execution\quad time_X} = \frac{\frac{1}{Performance_Y}}{\frac{1}{Performance_X}} = \frac{Performance_X}{Performance_Y}$(X is n times as fast as Y)</li>
<li>$S = \frac{T_S}{T_P}$</li>
</ul>
</li>
<li><p>Amdahal定律</p>
<ul>
<li>固定负载条件下程序并行化效率提升的理论上界(固定的计算负载分布在多个处理器上，达到加速的目的)</li>
<li>常用于预测使用多个处理器后的理论加速比上界</li>
<li>固定负载的加速公式<ul>
<li>$S = \frac{W_S + W_P}{W_S + \frac{W_P}{p}} = \frac{f+(1-f)}{f + \frac{1-f}{p}} = \frac{p}{1+f(p-1)}$<ul>
<li>$W_S + W_P = [f + (1-f)]W$</li>
<li>$p \rightarrow \infin$，上式的极限为: $S = \frac{1}{f}$</li>
<li>因此在固定负载的情况下，加速比是有上限的</li>
</ul>
</li>
</ul>
</li>
<li>除非一段串行程序的所有部分都可以并行化，否则可以达到的加速比是非常有限的(不论使用多少核)</li>
<li>并行程序的加速比与串行执行所需要的时间无关，只与可并行部分的长度$W_P$和并行系数p有关</li>
<li>实际并行加速不仅受限于程序的串行分量，也受到并行程序运行时额外开销的影响，令$W_O$为额外开销<ul>
<li>$S=\frac{W_S + W_P}{W_S + \frac{W_P}{p} + W_O} = \frac{W}{fW + \frac{W(1-f)}{p} + W_O} = \frac{p}{1+f(p-1)+\frac{W_Op}{W}}$</li>
<li>$p \rightarrow \infin$，$S = \frac{W}{fW + W_O}$</li>
</ul>
</li>
</ul>
</li>
<li>Gustafson定律<ul>
<li>对于很多大型计算，精度要求很高，即在此类应用中<strong>精度是个关键因素</strong>，而<strong>计算时间是固定不变的</strong>。此时为了提高精度，必须加大计算量，相应地亦<strong>必须增多处理器数才能维持时间不变</strong></li>
<li>除非学术研究，在实际应用中没有必要固定工作负载而计算程序运行在不同数目的处理器上，<strong>增多处理器必须相应地增大问题规模才有实际意义</strong></li>
<li>Gustafson加速定律<ul>
<li>$S’ = \frac{W_S + pW_P}{W_S + \frac{p\cdot W_P}{p}} = \frac{W_S + pW_P}{W_S + W_P}= f + p(1-f) = p + f(1-p) = p - f(p-1)$</li>
<li>并行开销$W_O$<ul>
<li>$S’ = \frac{W_S + pW_P}{W_S + W_P + W_O} = \frac{f + p(1-f)}{1+\frac{W_O}{W}}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Sun-Ni定律(存储受限的加速定律)<ul>
<li>只要存储空间许可，应尽量增大问题规模以产生更好和更精确的解(可能使执行时间略微增加)</li>
<li>假定在单节点上使用了全部存储容量M并在相应于W的时间内求解之，此时工作负载$W = fW + (1-f)W$</li>
<li>在p个节点的并行系统上，能够求解较大规模的问题是因为存储容量可增加到pM。令因子$G(p)$反映存储容量增加到p倍时并行工作负载的增加量，所以扩大后的工作负载$W = fW + (1-f)G(p)W$</li>
<li>存储受限的加速公式<ul>
<li>$S’’ = \frac{fW + (1-f)G(p)W}{fW + \frac{(1-f)G(p)W}{p}} = \frac{f + (1-f)G(p)}{fW + \frac{(1-f)G(p)}{p}}$</li>
</ul>
</li>
<li>加入并行开销$W_O$<ul>
<li>$S’’ = \frac{fW + (1-f)WG(p)}{fW + \frac{(1-f)G(p)W}{p} + W_O} = \frac{f + (1-f)G(p)}{f + \frac{(1-f)G(p)}{p} + \frac{W_O}{W}} $</li>
</ul>
</li>
<li>$G(p) = 1$，Amdahl加速定律</li>
<li>$G(p) = p$，Gustafson加速定律</li>
<li>$G(p) &gt; p$，相应于计算机负载比存储要求增加得快，此时Sun-Ni加速均比Amdahl加u是和Gustafson加速高</li>
</ul>
</li>
<li>参考的加速经验公式: $\frac{P}{logP} \le S \le P$</li>
<li>线性加速比: 很少通信开销的矩阵相加、内积运算</li>
<li>$\frac{P}{logP}$的加速比: 分治类的应用问题(二叉树，树的同级可并行执行，但向根逐级推进时，并行度逐渐减少)</li>
<li>通信密集类的应用问题: $S = \frac{1}{C(p)}$，$C(p)$是p个处理器的某一通信函数(线性/对数)</li>
<li>超级性加速: 并行搜索算法(提前取消无谓的搜索分支)</li>
<li>绝对加速: 最佳并行算法与串行算法相比</li>
<li>相对加速: 同一算法在单机和并行机的运行时间之比</li>
</ul>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><ul>
<li>加速比S与线性加速比p的比值<ul>
<li>$E = \frac{S}{p} = \frac{\frac{T_S}{T_P}}{p} = \frac{T_S}{p\cdot T_P}$</li>
<li>线性加速比<ul>
<li>对于p核的高性能计算机: $T_P = \frac{T_S}{p}$，此时并行程序拥有线性加速比p</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可扩展性-三种度量标准是等效的"><a href="#可扩展性-三种度量标准是等效的" class="headerlink" title="可扩展性(三种度量标准是等效的)"></a>可扩展性(三种度量标准是等效的)</h4><ul>
<li>可扩展性最简朴的含义是: 在确定的应用背景下，计算机系统(或算法或程序等)性能随处理器数量的增加而按比例提高的能力</li>
<li>影响加速比的因素: 处理器数量p和问题规模W<ul>
<li>求解问题中的串行分量</li>
<li>并行处理所引起的额外开销(通信、等待、竞争、冗余操作、同步)</li>
<li>加大的处理器数量超过了算法中的并发程度</li>
</ul>
</li>
<li>增加问题的规模有利于提高加速的因素<ul>
<li>较大的问题规模可提供较高的并发度</li>
<li>额外开销的增加可能慢于有效计算的增加</li>
<li>算法中的串行分量比例不是固定不变的(串行部分所占的比例随着问题规模的增大而缩小)</li>
</ul>
</li>
<li>增加处理器数量会增大额外开销和降低处理器的利用率。所以对于一个特定的并行系统(算法或程序)，能否有效利用不断增加的处理器的能力应是受限的，而度量这种能力就是可扩展性指标</li>
<li>因此可扩展性是调整什么和按什么比例调整<ul>
<li>并行计算要调整的是处理器数p和问题规模W</li>
<li>两者可按不同比例进行调整，比例关系可能是线性的，多项式的或指数的</li>
</ul>
</li>
<li><p>可扩展性的主要目的是</p>
<ul>
<li>确定解决某类问题用何种并行算法与何种并行体系结构的组合，可以有效地利用大量的处理器</li>
<li>对于运行于某种体系结构的并行机上的某种算法当移植到大规模处理机上后运行的性能</li>
<li>对固定的问题规模，确定在某类并行机上最优的处理器数量与可获得的最大加速比</li>
<li>用于指导改进并行算法和并行体系结构，以使并行算法尽可能地充分利用可扩充的大量处理器</li>
<li>目前无一个公认的、标准的和被普遍接受的严格定义和评判标准</li>
</ul>
</li>
<li><p>等效率度量标准(非唯一的方法): 保持效率E不变的前提下，研究问题规模W如何随着处理器个数p而变化</p>
<ul>
<li>令$t_e^i$和$t_o^i$分别是并行系统上第i个处理器的有用计算时间和额外开销时间(通信、同步和空闲等待时间)<ul>
<li>$T<em>e = \Sigma</em>{i=0}^{p-1} t_e^i$(整个系统的有用计算时间)</li>
<li>$T<em>o = \Sigma</em>{i=0}^{p-1} t_o^i$(整个系统的额外开销时间)</li>
</ul>
</li>
<li>$T_p$是p个处理器系统上并行算法的运行时间，对于任意i显然有$T_p = t_e^i + t_o^i$，且$T_e + T_o = pT_p$</li>
<li>问题的规模W为最佳串行算法所完成的计算量$W=T_e$<ul>
<li>$S = \frac{T_e}{T_p} = \frac{T_e}{\frac{T_e+T_o}{p}} = \frac{p}{1+\frac{T_o}{T_e}} = \frac{p}{1+ \frac{T_o}{W}}$</li>
<li>$E = \frac{S}{p} = \frac{1}{1+\frac{T_o}{T_e}} = \frac{1}{1+\frac{T_o}{W}}$</li>
</ul>
</li>
<li>优点: <ul>
<li>简单可定量计算</li>
<li>只需少量参数完成计算</li>
</ul>
</li>
<li>缺点: <ul>
<li>$T_o$以解析计算得到，但有时难以计算: 例如非局部访问的读写时间、进程调度的时间、存储竞争的时间以及高速缓存一致性操作时间等都是难以准确计算的</li>
</ul>
</li>
</ul>
</li>
<li>等速度度量标准(iso-speed, 以试验测试为主要手段): 保持平均速度不变的前提下，研究处理器个数p增多时，应相应增加多少工作量W<ul>
<li>$T_o$隐含在所测量的执行时间中</li>
</ul>
</li>
<li><p>平均延迟度量标准(average latency, 以试验测试为主要手段): 保持效率E不变的前提下，用平均延迟的比值来标志随处理器个数p增加需要增加的工作量W</p>
<ul>
<li>调节W与p测量并行和串行执行时间，最终通过平均延迟反映出$T_o$</li>
</ul>
</li>
<li><p>主要目的</p>
<ul>
<li>探索算法和并行架构的组合<ul>
<li>确定解决某类问题使用何种并行算法和并行架构的组合，更有利于利用大量的硬件资源</li>
</ul>
</li>
<li>预测算法性能<ul>
<li>根据某个算法在特定架构下的小规模处理器上的性能，预测该算法移植到较大规模的处理器上后算法的运行性能</li>
</ul>
</li>
<li>计算最大加速比<ul>
<li>探索在固定的问题规模下，确定利用的处理器数量及其能获得的最大加速比</li>
</ul>
</li>
<li>指导算法改进和并行架构设计<ul>
<li>根据拓展性指标，指导开发、研究人员改进并行算法或者系统架构，以提高处理器的利用效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序级性能评测"><a href="#程序级性能评测" class="headerlink" title="程序级性能评测"></a>程序级性能评测</h3><h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h4><ul>
<li>基本测试</li>
<li>数据库测试</li>
<li>并行测试程序</li>
</ul>
<h3 id="HPC架构"><a href="#HPC架构" class="headerlink" title="HPC架构"></a>HPC架构</h3><h4 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h4><ul>
<li>速度<ul>
<li>系统组件的速度(处理器时钟频率)</li>
</ul>
</li>
<li>并行性<ul>
<li>系统的并发度，同时能执行的操作数</li>
</ul>
</li>
<li>效率<ul>
<li>系统的利用率</li>
<li>常用度量: <ul>
<li>持续浮点性能</li>
<li>理论峰值性能的比值</li>
</ul>
</li>
</ul>
</li>
<li>峰值性能<ul>
<li>超级计算机理论上在其硬件资源的支持下能够获得的最大性能值</li>
<li>理论峰值性能: 计算机理论上能达到的每秒钟完成浮点计算最大次数，由CPU的主频、CPU每个时钟周期执行浮点运算的次数和系统总CPU核数共同决定<ul>
<li>理论峰值性能 = CPU时钟频率 x CPU每个时钟周期执行的浮点运算次数 x CPU数量  </li>
<li>适用于通用的硬件体系结构，但忽略了内存架构及带宽、I/O性能、缓存一致性等因素的影响，从而无法真正反映系统的真实峰值性能</li>
</ul>
</li>
<li>实测峰值性能<ul>
<li>通过标准的程序测试得到</li>
</ul>
</li>
</ul>
</li>
<li>功率<ul>
<li>处理器主频与功率相关</li>
<li>冷却系统</li>
</ul>
</li>
<li>可靠性<ul>
<li>软硬件故障</li>
<li>Checkpoint机制(用于回滚)</li>
</ul>
</li>
<li>可编程性<ul>
<li>涉及系统的易用性和生产率</li>
</ul>
</li>
</ul>
<h2 id="基准评测集-1"><a href="#基准评测集-1" class="headerlink" title="基准评测集"></a>基准评测集</h2><ul>
<li>性能基准评测就是从基准测试程序和测试规范的角度评价和预测系统的性能<ul>
<li>可以帮助机构确定所需要采购的超级计算机</li>
<li>可以指导制造商设计高性能计算机系统的方向</li>
<li>探索HPC趋势的重要历史记录</li>
</ul>
</li>
</ul>
<h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><ul>
<li>The best choice of benchmarks to measure performance is <strong>real applications</strong><ul>
<li>Kernels: small, key pieces of real applications</li>
<li>Toy programs: 100-line programs(基础的程序，不超过100行) for in beginning programming assignment</li>
<li>Synthetic benchmarks: fake programs invented to try to match the profile and behavior of real applications(Dhrystone, 整数运算能力；浮点数运算能力)</li>
<li>benchmark suites: collections of benchmark applications(SPEC06fp, TPC-C)</li>
</ul>
</li>
</ul>
<h3 id="商用基准测试程序"><a href="#商用基准测试程序" class="headerlink" title="商用基准测试程序"></a>商用基准测试程序</h3><h4 id="Transaction-processing-TP-benchmarks-事务处理能力"><a href="#Transaction-processing-TP-benchmarks-事务处理能力" class="headerlink" title="Transaction-processing(TP) benchmarks(事务处理能力)"></a>Transaction-processing(TP) benchmarks(事务处理能力)</h4><ul>
<li><p>measure the ability of a system to handle transactions that consist of database accesses and updates</p>
</li>
<li><p>Transaction Processing Council(TPC): create realistic and fair benchmarks for TP</p>
<ul>
<li>TPC-A,TPC-B(已废弃)</li>
<li>TPC-C: simulates a complex query environment(目前最流行的在线事务处理, (Online Transaction Processing, OLTP), 商用基准测试程序, 能模拟一个大公司的整个销售环境(仓库、区域、用户、订单等事务的比例、响应时间)，用于测试事务处理系统的性能与价性比)<ul>
<li>性能结果tpmC: 描述了系统在执行Payment、Order-status、Delivery、Stock-Level等交易的同时，每分钟可以处理多少个New-Order交易<ul>
<li>所有的交易响应时间必须满足TPC-C测试规范的要求</li>
<li>流量指标值越大越好</li>
</ul>
</li>
<li>价性比结果$/tpmC: 结果越小越好</li>
<li>各厂商的TPC-C测试结果都按TPC组织规定的两种形式发布<ul>
<li>测试结果概要(Executive Summary)<ul>
<li>描述了主要的测试指标、测试环境示意图以及完整的系统配置、报价</li>
</ul>
</li>
<li>详细测试报告(Executive Report)<ul>
<li>还详细说明了整个测试环境的设置和测试的过程</li>
</ul>
</li>
</ul>
</li>
<li>TPC-C允许被测系统放大和缩小，但终端数和数据库规模也必须按规模缩放</li>
</ul>
</li>
<li>TPC-H</li>
<li>TPC-DI</li>
<li>TPC-E</li>
</ul>
</li>
</ul>
<h4 id="SPEC-System-Performance-Evaluation-Cooperative-测试程序"><a href="#SPEC-System-Performance-Evaluation-Cooperative-测试程序" class="headerlink" title="SPEC(System Performance Evaluation Cooperative)测试程序"></a>SPEC(System Performance Evaluation Cooperative)测试程序</h4><ul>
<li>由计算机厂商、系统集成商、大学、研究机构、咨询等多家公司组成的非营利性组织</li>
<li>SPEC CPU系列测试程序集合主要关注CPU的性能，通过分析具体程序的行为寻找优化方向<ul>
<li>SPECratio(单进程)分值主要反映PC系统性能<ul>
<li>A ratio by dividing the time on the reference computer by the time on the computer being rated(参考计算机与测试计算机的SPEC的执行时间的比值)</li>
<li>综合测试结果是取SPECratio的几何平均值</li>
<li>SPEC CPU ratio是一个相对比值，IPC高分值不一定高(IPC指的是每周期执行的指令数？)</li>
</ul>
</li>
<li>衡量服务器的吞吐量通常采用SPECrate，在多CPU执行SPEC CPU的多份拷贝，并且把CPU的时间转换为比率(rate)</li>
<li>随CPU性能提高已发展了6轮: 1989、1992、1995、2000、2006、2017<ul>
<li>SPEC CPU2000: 12个定点程序，14个浮点程序<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%202000%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
<li>SPEC CPU2006: 12个定点程序，17个浮点程序<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%202006%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
<li>SPEC CPU2017: 10个定点，14个浮点程序，分为<ul>
<li>Rate(多道程序): 多个拷贝多核运行</li>
<li>Speed(多线程): 单个拷贝、代码针对openMP自动并行化做了修改<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%2020171%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"><br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/SPEC%20CPU%2020172%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%A5%97%E4%BB%B6.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Summarize performance results of the suite in a unique number<ul>
<li>arithmetic means of execution times of programs in the suite(算术平均)</li>
<li>the weighted arithmetic mean(加权算术平均)</li>
<li>normalize execution times to a reference computer(标准化到参考计算机)</li>
</ul>
</li>
</ul>
<h3 id="HPC基准评测集"><a href="#HPC基准评测集" class="headerlink" title="HPC基准评测集"></a>HPC基准评测集</h3><h4 id="计算性能评测集"><a href="#计算性能评测集" class="headerlink" title="计算性能评测集"></a>计算性能评测集</h4><ul>
<li>Linpack(Linear system package)<ul>
<li>图灵奖得主美国计算机科学家Jack Dongarra等几位学者于1979年开发的线性系统软件库(Linear system package)</li>
<li><a target="_blank" rel="noopener" href="http://www.netlib.org/lapack/lug/">Linkpack用户手册</a></li>
<li>目标是集成常用的线性方程组求解的程序(最小平方问题、稠密矩阵运算)至一个通用的线性代数软件库，支持求解大部分常见的线性代数问题</li>
<li>用来度量系统的浮点计算能力<ul>
<li>评测指标: 每秒浮点运算次数(FLOPS)</li>
</ul>
</li>
<li>Linpack性能是指求解双精度线性代数方程组时所达到的实际性能<ul>
<li>Linpack100: 使用Fortran中的Linpack软件求解规模为100阶的稠密线性代数方程组<ul>
<li>为了运行该程序，需要提供一个称为<code>SECOND</code>的计时函数，报告已经过去的CPU时间</li>
<li>运行此基准评测的基本规则是不能对Fortran代码进行任何更改，甚至不允许更改注释，只允许采用编译优化选项进行优化</li>
<li><a target="_blank" rel="noopener" href="http://www.netlib.org/benchmark/linpackd">Linpack100 测试程序</a></li>
</ul>
</li>
<li>Linpack1000: 求解规模为1000阶的线性代数方程组<ul>
<li>运行此基准评测的基本规则要宽松一些，可以指定希望求解的任何线性方程，用任何语言实现。</li>
<li>而且在达到必须满足要求的情况下，可以在不改变计算量的前提下做算法和代码上的优化<ul>
<li>必须满足要求是必须计算出一个解决方案，并且该解决方案必须返回一个达到规定精度的结果</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.netlib.org/benchmark/1000d">Linpack1000 测试程序</a></li>
</ul>
</li>
<li>类似的HPL是针对现代高性能计算机的评测基准，是国际超级计算系统TOP500的重要依据<ul>
<li>具体为求一个n维的线性方程组的解: <ul>
<li>$Ax=b; A\in R^{n\times n};x, b\in R^n$</li>
</ul>
</li>
<li>$n\times(n+1)$的系数矩阵$[A, b]$, 进行LU分解: <ul>
<li>$[A. b] = [[LU], y]$</li>
</ul>
</li>
<li>方程组的解$x$转化为求解三角矩阵U作为系数矩阵的线性方程组$Ux=y$而得到</li>
<li>目标是尽可能地使得高性能计算机对矩阵A的不同部分并行地做出更新，需要对矩阵进行分块<ul>
<li>$N$为最高GFLOPS值的矩阵规模，$N_B$为求解矩阵的分块大小</li>
<li>$P$为处理器网格中水平方向处理器的个数，$Q$为处理器网格中垂直方向处理器的个数</li>
<li>如下图，矩阵首先划分为$N_B=4\times 4$个数据块，之后所有$N_B$个数据块映射到数目为$P\times Q=2\times2$的进程阵<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/HPL.png" alt="img"></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.netlib.org/benchmark/hpl">HPL 采用 C 语言进行编写的测试程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HPCG(High-Performance Conjugate Gradient, 高性能共轭梯度法，C++)<ul>
<li>然而，实际应用中的计算存在大量使用偏微分方程建模、稀疏计算和不规则访存的情况，以上这些情况无法用Linpack进行衡量。这是就需要用到HPCG，但要注意: HPCG只是一种求解稀疏矩阵方程组的迭代算法，作为Linpack的补充，而不能替代，促使计算机系统的设计不仅仅只专注于计算能力的发展，还要向访存、通信这些方面发展</li>
<li>目的是适应目前大部分应用程序所采用的计算和数据访问模式，最终促进计算机性能的整体提升</li>
<li>模拟三维热力学运动问题，从而转化为求解离散的三维偏微分方程模型问题<ul>
<li>三维热力学运动问题转化步骤: <ul>
<li>网格划分: 将热力学问题转化为离散的三维空间网格。根据实际情况，可以选择均匀网格或非均匀网格</li>
<li>离散化: 根据具体的热力学方程，将偏微分方程转化为差分方程。例如，可以使用有限差分法或有限元法来离散化方程<ul>
<li>利用差分方程迭代的过程中，采用全局通信和邻近进程数据的通信方式以及向量更新、点乘、稀疏矩阵向量乘法和局部三角求解器等计算模式，覆盖了高性能计算领域中常见的计算操作</li>
</ul>
</li>
<li>边界条件: 根据实际问题，在离散的网格上设置正确的边界条件。这些条件用于描述问题的物理特性</li>
<li>代数方程组: 将离散化的方程整理为矩阵形式，并构建一个稀疏线性方程组。方程组的未知数通常是网格点上的温度或其他物理量</li>
<li>解方程组: 使用HPCG或其他合适的求解器，通过迭代方法(如共轭梯度法)求解离散方程组。这涉及到矩阵向量乘法和共轭梯度法的实现</li>
<li>并行计算: 为了提高性能，利用并行计算技术(如MPI或OpenMP)将计算任务分配给多个处理器或多个计算节点</li>
</ul>
</li>
<li>使用局部对称高斯·塞德尔(Local Symmetric Gauss-Seidel, LSGS)预条件子的预处理共轭梯度法(Conjugate Gradient, CG)<ul>
<li>通过将原始线性系统矩阵分解为局部块矩阵，使用Gauss-Seidel迭代逐块求解，能够有效地加速CG方法的收敛速度</li>
<li>基本步骤: <ul>
<li>定义原始线性系统: 将原始线性系统表示为$Ax=b$的形式，其中$A$是对称正定的稀疏矩阵，$x$是解向量，$b$是右侧向量</li>
<li>分解稀疏矩阵: 将稀疏矩阵A分解为对角矩阵形式(如D-L-U, 主对角线矩阵、严格的下三角、严格的上三角)</li>
<li>预处理: 采用Gauss-Seidel迭代对分解后的系数矩阵进行预处理，通过使用前一步求解得到的分量更新当前的分量，直到达到所需要的精度。对于块矩阵来说，每个块的更新是独立进行的</li>
<li>执行共轭梯度法迭代: 使用预处理后的分解系数矩阵(块对角矩阵)和预处理后的右侧向量进行共轭梯度法迭代求解</li>
</ul>
</li>
<li>主要优点: <ul>
<li>能够利用块矩阵的局部性质和Gauss-Seidel迭代的迭代更新加速共轭梯度法的收敛</li>
</ul>
</li>
<li>限制: <ul>
<li>对块矩阵的分解和求解过程复杂</li>
<li>在某些情况下可能会受到块矩阵形状和特征值分布的影响</li>
</ul>
</li>
</ul>
</li>
<li>主要处理的数据为对称正定稀疏矩阵<ul>
<li>稀疏线性方程组通过配置文件中的参数构建，其中未知数是网格点上的温度或其他的物理量<ul>
<li>网格维度(<code>nx</code>, <code>ny</code>, <code>nz</code>): 设置三维网格的大小，决定方程组中未知数的个数</li>
<li>网格划分(<code>px</code>, <code>py</code>, <code>pz</code>): 定义并行计算中网格划分的方式</li>
<li>通信模式(<code>cg_iter</code>, <code>symmetry</code>, <code>overlap</code>, <code>global_mpi</code>): 决定通信方式，是否引入对称性</li>
<li>矩阵类型(<code>exec_set</code>, 值可以为<code>laplacian</code>, <code>elasticity</code>): 决定了稀疏矩阵的结构</li>
<li>非零元素密度(<code>toc</code>): 决定矩阵的稀疏程度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>运行要求: <ul>
<li>问题规模所需占用的内存大小至少占系统总内存的四分之一以上<ul>
<li>主要是由于问题规模太小会导致数据访存开销以及访存不规则的问题无法暴露</li>
</ul>
</li>
<li>禁止用户改变预处理器的设置，保证系统测试的合理性<ul>
<li>禁止修改数据在内存中的存储长度等修改数据存储格式的操作</li>
<li>禁止通过修改算法减少通信开销</li>
</ul>
</li>
</ul>
</li>
<li>指标<ul>
<li>HPCG得分: 作为一个综合评估指标，度量计算机的整体性能，反应了计算机在求解稀疏线性系统方面的速度和效率</li>
<li>迭代次数: 反映的是计算机的计算能力和收敛速度</li>
<li>内存带宽: HPCG基准测试是一个内存密集型的应用程序，通过测试可以了解计算机在高速缓存和主存之间的数据传输效率</li>
</ul>
</li>
<li>指出了未来计算机的改进方向: 通过异步通信以及能够降低通信延迟的相关技术</li>
</ul>
</li>
<li><p>Graph500(Sandia National Laboratories, SNL. Richard Murphy)</p>
<ul>
<li>在图遍历的基础上设计出来(因为图遍历是一种典型的数据密集型应用)</li>
<li>旨在评测高性能计算机对复杂数据的处理性能(特别是数据密集型应用)，侧重于系统的通信子系统，不再专注于计算性能</li>
<li><p>流程: </p>
<ul>
<li>图数据生成</li>
<li>图遍历验证<ul>
<li>利用广度优先搜索(BFS)或单源点最短路径(SSSP, Single source shortest path?)算法作为核心搜索程序，随机选择一个根节点作为源点进行遍历并检查保存的结果与原来的生成图是否匹配</li>
<li>迭代次数与源点数量相同</li>
</ul>
</li>
<li>结果计算与输出 </li>
<li>在访问搜索根源点之前立即开始对搜索时间计时，将输出的结果写入内存后，停止计时</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Graph500%E6%B5%81%E7%A8%8B.png" alt="img"></p>
</li>
<li><p>Graph500基准评测程序按照问题的规模分为六个等级，也被称为等级10-15</p>
<p>大小|规模(2的次方)|节点数($\times 10^8$)|内存要求/TB<br>:-:|:-:|:-:|:-:<br>Toy|26|1|0.02<br>Mini|29|5|0.14<br>Small|32|43|1.1<br>Medium|36|687|17.6<br>Large|39|5498|141<br>Huge|42|43980|1126</p>
</li>
<li><p>指标: </p>
<ul>
<li>每秒遍历的边数(Traversed Edges Per Second, TEPS)，是生成图的边数和核心搜索程序算法的耗时比值</li>
</ul>
</li>
<li>目标: <ul>
<li>公平遵守基准规范的意图</li>
<li>给定机器的最大问题大小</li>
<li>给定问题大小的最短执行时间</li>
<li>次要目标: <ul>
<li>最小代码量(不包括验证码)</li>
<li>最少的开发时间</li>
<li>最大的可维护性</li>
<li>最大的可扩展性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IO性能评测集-评估文件系统和存储性能"><a href="#IO性能评测集-评估文件系统和存储性能" class="headerlink" title="IO性能评测集(评估文件系统和存储性能)"></a>IO性能评测集(评估文件系统和存储性能)</h4><ul>
<li>MDTest: 广泛使用的文件和目录创建、访问和删除的基准测试工具，用于评估文件系统的元数据性能<ul>
<li>通过在一组机器(通常是HPC集群中的计算节点)上并行创建、统计和删除目录树和文件树评测I/O性能</li>
<li>指标是每秒的操作数(OP/秒)</li>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/mdtest/">MDTest测试程序</a></li>
</ul>
</li>
<li>IOR(Interoperability of I/O Ribbons): 使用多种I/O接口(POSIX, MPI-IO, HDF5)和访问模式来测量并行文件系统和存储系统I/O性能的基准测试工具<ul>
<li>通过接收参数，在客户端上产生特定的工作负载从而测试系统的I/O性能并输出评测结果</li>
<li>评测结果中的带宽是通过传输的数据量除以停止时间戳与开始时间戳的差值得到</li>
</ul>
</li>
<li>IO500: 一个综合性的基准测试套件，旨在评估高性能计算环境下文件系统和存储系统的性能<ul>
<li>由于测试方法、工具和参数甚至测试步骤的先后顺序不同，不同厂商发布的I/O性能测试结果具有很大的差异性，使用IO500可以对高性能存储系统进行标准的测试和比较</li>
<li>方法: 分为两组进行评测<ul>
<li>第一组评测的是高性能计算机I/O的理想性能，通过大文件的读写等方式测评计算机存储系统的性能上限，能够有效激励世界各大存储厂商不断提升系统的极限性能<ul>
<li>IOR easy</li>
<li>MDTest easy</li>
</ul>
</li>
<li>第二组评测的是高性能计算机I/O的极限性能，通过海量小文件的读写测评计算机存储系统的性能极限<ul>
<li>IOR hard</li>
<li>MDTest hard</li>
</ul>
</li>
</ul>
</li>
<li>最终分数是IOR分数和MDTest分数的几何平均值(乘积开方)</li>
</ul>
</li>
</ul>
<h4 id="网络性能评测集"><a href="#网络性能评测集" class="headerlink" title="网络性能评测集"></a>网络性能评测集</h4><ul>
<li><p>IMB: 用于评估HPC集群在不同消息粒度下节点间点对点、全局通信的效率</p>
<ul>
<li>点对点通信<ul>
<li>评测测试的是两个进程间的消息传递，包括Ping-Pong和Ping-Ping(互ping?)测试</li>
</ul>
</li>
<li>并行通信<ul>
<li>评测测试的是全局负载下消息的收发效率，包括Sendrecv和Exchange测试</li>
</ul>
</li>
<li>群体通信<ul>
<li>评测测试的是一对多或者多对一的消息传递</li>
</ul>
</li>
</ul>
</li>
<li><p>OSU(Ohio State University) Benchmark</p>
<ul>
<li>程序生成不同规模的数据并执行各种不同模式的MPI通信(跨语言通信协议)，测试各种通信模式的延迟和带宽<ul>
<li>延迟测试采用的是Ping-Pong方式</li>
<li>带宽测试分为点对点通信和组通信两种形式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="能耗评测集"><a href="#能耗评测集" class="headerlink" title="能耗评测集"></a>能耗评测集</h4><ul>
<li>Green 500: 提供高性能计算机的能耗排名<ul>
<li>指标: 使用PPW(performance per watt, 每瓦特性能, 通常单位为GFLOPS Per Watt)作为其指标对能源效率进行排名<ul>
<li>$PPW = \frac{Performance}{Power} = \frac{R<em>{max}}{\overline{P}(R</em>{max})}$</li>
<li>$\overline{P}(R<em>{max}) = N \cdot \overline{P}</em>{unit}(R_{max})$(超级计算机的整体功耗包括计算节点、网络和存储等各个部分的能耗之和，这里是假定各部分能耗一致)</li>
</ul>
</li>
</ul>
</li>
<li>功率测量方法<ul>
<li>直接测量: 通过使用功率计或电流传感器直接测量超级计算机的电力输入。功率计可以接入电源线路测量电流和电压，并计算功率($P = UI$)。这种方法可以提供较准确的功率测量结果，但需要考虑电流和电源的稳定性</li>
<li>间接测量: 通过测量超级计算机的其他物理参数间接估计功率<ul>
<li>使用温度传感器测量系统的温度，根据热传导定律和热功率模型推导功率($Q=Pt$?)</li>
</ul>
</li>
<li>硬件监控: 使用超级计算机中的硬件监控功能获取功耗数据</li>
<li>软件监控: 使用特定的性能检测工具和软件估计功耗，可以通过检测处理器利用率、内存访问模式和其他负载信息推断功耗</li>
</ul>
</li>
<li>超级计算机的功率测量需要综合考虑软硬件监控方法，以获得更准确的数据，用于评估和优化能源效率</li>
<li>任何的功率测量方法都有一定的误差范围，并且测量都有不确定性。</li>
<li>要定期进行功耗测量，以监控和评估超级计算机的能源效率，并在必要的时候进行调整优化</li>
</ul>
<h4 id="应用评测集"><a href="#应用评测集" class="headerlink" title="应用评测集"></a>应用评测集</h4><ul>
<li><p>Miniapplication</p>
<ul>
<li>是真实应用程序的更小版本，用于评估超级计算机对于动态应用程序的性能<ul>
<li>既要足够复杂，又要足够小</li>
<li>性能包括内存、网络、加速器和处理器元素的参数和交互空间</li>
</ul>
</li>
<li>开源Miniapplication<ul>
<li>MiniAMR: 用于探索自适应网格细化和动态执行的小型应用程序</li>
<li>MiniFE: 有限元代码的小型应用程序，提供了对多核节点上进行计算的支持</li>
<li>MiniGhost: 有限差分小型应用程序，可在均匀三维域上实现有限差分</li>
<li>MiniMD: 基于分子动力学工作负载的小型应用程序</li>
<li>Cloverleaf: 使用显式的二阶精确方法来求解可压缩欧拉方程</li>
<li>TeaLeaf: 求解线性热传导方程工作负载的小型应用程序</li>
</ul>
</li>
</ul>
</li>
<li><p>戈登·贝尔奖(ACM Gordon Bell Prize): 超算界的诺贝尔奖</p>
<ul>
<li>评选对象是当年前500排名的超级电脑系统上所跑的应用程序</li>
<li>奖项：<ul>
<li>最高性能奖(Peak Performance)</li>
<li>最高性价比奖(Price/Performance)</li>
<li>特别奖(Special Achievement)</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">高级计算机体系结构</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/21/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-21-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式系统简介</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式计算模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/11/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-09-11-%E7%BB%AA%E8%AE%BA/" title="绪论"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">绪论</div></div></a></div><div><a href="/2024/10/09/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-09-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/" title="如何提高性能"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-09</div><div class="title">如何提高性能</div></div></a></div><div><a href="/2024/10/16/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-16-%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="高性能计算机的体系结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="title">高性能计算机的体系结构</div></div></a></div><div><a href="/2024/10/23/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-23-%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF/" title="高性能处理器的并行计算技术"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="title">高性能处理器的并行计算技术</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">基准评测集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD"><span class="toc-text">计算机性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Processor-Performance-Equation"><span class="toc-text">The Processor Performance Equation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FLOPS-Floating-point-Operations-Per-Second-%E6%AF%8F%E7%A7%92%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%AC%A1%E6%95%B0"><span class="toc-text">FLOPS(Floating-point Operations Per Second, 每秒浮点运算次数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%80%A7%E8%83%BD"><span class="toc-text">其他性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-text">意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-text">机器级性能评测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E7%9A%84%E6%9F%90%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">CPU的某些基本性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%9F%90%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">存储器的某些基本性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E9%80%9A%E4%BF%A1%E5%BC%80%E9%94%80%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text">并行和通信开销的分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E4%B8%8E%E5%A5%BD%E7%94%A8%E8%A1%8C%E4%BB%A5%E5%8F%8A%E6%9C%BA%E5%99%A8%E6%88%90%E6%9C%AC%E3%80%81%E4%BB%B7%E6%A0%BC%E4%B8%8E%E6%80%A7%E4%BB%B7%E6%AF%94"><span class="toc-text">计算机的可用性与好用行以及机器成本、价格与性价比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BA%A7%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-text">算法级性能评测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94-Speedup"><span class="toc-text">加速比(Speedup)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-text">效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-%E4%B8%89%E7%A7%8D%E5%BA%A6%E9%87%8F%E6%A0%87%E5%87%86%E6%98%AF%E7%AD%89%E6%95%88%E7%9A%84"><span class="toc-text">可扩展性(三种度量标准是等效的)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BA%A7%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-text">程序级性能评测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Benchmark"><span class="toc-text">Benchmark</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HPC%E6%9E%B6%E6%9E%84"><span class="toc-text">HPC架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-text">关键特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86-1"><span class="toc-text">基准评测集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmarks"><span class="toc-text">Benchmarks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E7%94%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">商用基准测试程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Transaction-processing-TP-benchmarks-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B"><span class="toc-text">Transaction-processing(TP) benchmarks(事务处理能力)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPEC-System-Performance-Evaluation-Cooperative-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">SPEC(System Performance Evaluation Cooperative)测试程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HPC%E5%9F%BA%E5%87%86%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">HPC基准评测集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">计算性能评测集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E9%9B%86-%E8%AF%84%E4%BC%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD"><span class="toc-text">IO性能评测集(评估文件系统和存储性能)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">网络性能评测集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E8%80%97%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">能耗评测集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%AF%84%E6%B5%8B%E9%9B%86"><span class="toc-text">应用评测集</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/MCP/2025-04-14-Function%20Calling,%20MCP%20and%20A2A/" title="Function Calling, MCP and A2A">Function Calling, MCP and A2A</a><time datetime="2025-04-14T12:54:40.000Z" title="发表于 2025-04-14 20:54:40">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/%E6%99%BA%E8%83%BD%E4%BD%93/2025-04-14-OS%20Agents%20%E7%AC%94%E8%AE%B0/" title="OS Agents 笔记">OS Agents 笔记</a><time datetime="2025-04-14T03:05:57.000Z" title="发表于 2025-04-14 11:05:57">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/MCP/2025-04-08-MCP/" title="MCP">MCP</a><time datetime="2025-04-08T07:31:07.000Z" title="发表于 2025-04-08 15:31:07">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/2025-03-10-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="算法分析与问题的计算复杂度">算法分析与问题的计算复杂度</a><time datetime="2025-03-10T11:53:48.000Z" title="发表于 2025-03-10 19:53:48">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/" title="消息序和组通信">消息序和组通信</a><time datetime="2025-01-11T11:43:17.000Z" title="发表于 2025-01-11 19:43:17">2025-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>