<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>全局状态及快照算法 | ZJN_BLOG</title><meta name="keywords" content="高级分布式系统"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="全局状态及快照算法System model The system consists of a collection of $n$ processes $p_1, p_2, …, p_n$ that are connected by channels There are no globally shared memory and physical global clock and processes">
<meta property="og:type" content="article">
<meta property="og:title" content="全局状态及快照算法">
<meta property="og:url" content="http://zjn-astonishe.github.io/2024/10/25/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-10-25-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="全局状态及快照算法System model The system consists of a collection of $n$ processes $p_1, p_2, …, p_n$ that are connected by channels There are no globally shared memory and physical global clock and processes">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2024-10-25T13:25:26.000Z">
<meta property="article:modified_time" content="2024-11-09T04:33:57.468Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="高级分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2024/10/25/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-10-25-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '全局状态及快照算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-09 12:33:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">全局状态及快照算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-25T13:25:26.000Z" title="发表于 2024-10-25 21:25:26">2024-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-09T04:33:57.468Z" title="更新于 2024-11-09 12:33:57">2024-11-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">高级分布式系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="全局状态及快照算法"><a href="#全局状态及快照算法" class="headerlink" title="全局状态及快照算法"></a>全局状态及快照算法</h1><h2 id="System-model"><a href="#System-model" class="headerlink" title="System model"></a>System model</h2><ul>
<li>The system consists of a collection of $n$ processes $p_1, p_2, …, p_n$ that are connected by channels</li>
<li>There are no globally shared memory and physical global clock and processes communicate by passing messages through communication channels with unpredicatable message delays<ul>
<li>$C_{ij}$ denotes the channel from process $p_i$ to process $p_j$ and its state is denoted by $SC_{ij}$<ul>
<li>For a channel $C_{ij}$, the following set of messages can be defined based on the local states of the processes $p_i$ and $p_j$</li>
<li>Transit: $transit(LS_i, LS_j)=\{m_{ij}|send(m_{ij}\in LS_i \wedge rec(m_{ij})\notin LS_j\}$(发送端发送了，但接收端没接收，说明消息在信道)</li>
</ul>
</li>
</ul>
</li>
<li>The actions performed by a process are modeled as three types of events: <ul>
<li>Internal events, </li>
<li>the message send event</li>
<li>the message receive event</li>
</ul>
</li>
<li>For a message $m_{ij}$ that is sent by process $p_i$ to process $p_j$, let $send(m_{ij})$ and $rec(m_{ij})$ denote its send and receive events</li>
<li>At any distant, the state of process $p_i$, denoted by $LS_i$, is a result of the sequence of all the events executed by $p_i$ till that instant(进程的状态是之前所有执行过的事件)<ul>
<li>For an event $e$ and a process state $LS_i, e\in LS_i$ iff $e$ belongs to the sequence of events that have taken process $p_i$ to state $LS_i$</li>
<li>For an event $e$ and a process state $LS_i, e\notin LS_i$, iff $e$ does not belong to the sequence of events that have taken process $p_i$ to state $LS_i$</li>
</ul>
</li>
</ul>
<h3 id="Models-of-communication"><a href="#Models-of-communication" class="headerlink" title="Models of communication"></a>Models of communication</h3><ul>
<li>In FIFO model, each channel acts as a first-in first-out message queue and thus, message ordering is preserved by a channel(FIFO消息是有序到达)</li>
<li>In non-FIFO model, a channel acts like a set in which the sender process adds messages and the receiver process removes messages from it in a random order.(non-FIFO消息是无序到达)</li>
<li>A system that supports causal delivery of messages satisfies the following property: <ul>
<li>“For any two messages $m_{ij}$ and $m_{kj}$, if $send(m_{ij})\rightarrow send(m_{kj})$, then $rec(m_{ij}) −→ rec(m_{kj})$”</li>
<li>因果序，先发和后发有因果序，则先发的会先收，且和后收有因果序</li>
</ul>
</li>
</ul>
<h2 id="Consistent-global-state"><a href="#Consistent-global-state" class="headerlink" title="Consistent global state"></a>Consistent global state</h2><ul>
<li>The global state of a distributed system is a collection of the local states of the processes and the channels<ul>
<li>Notationally, global state $GS$ is defined as<ul>
<li>$GS=\{\bigcup_i LS_i, \bigcup_{i, j}SC_{ij}\}$(所有的进程状态和所有的信道状态)</li>
</ul>
</li>
</ul>
</li>
<li>A global state $GS$ is a consistent global state iff it satisfies the following two conditions:<ul>
<li>$C1: send(m_{ij})\in LS_i \Rightarrow m_{ij}\in SC_{ij} \bigoplus rec(m_{ij})\in LS_j$, ($\bigoplus$ is Ex-OR operator, 异或)(发出去的消息要么被接收要么在信道，不可能同时在接收方和信道，也不可能都不在)</li>
<li>$C2: send(m_{ij})\notin LS_i \Rightarrow m_{ij}\notin SC_{ij}\wedge rec(m_{ij})\notin LS_j$(没发的消息不可能出现在接收方和信道)</li>
</ul>
</li>
</ul>
<h3 id="Interpretation-in-terms-of-cuts"><a href="#Interpretation-in-terms-of-cuts" class="headerlink" title="Interpretation in terms of cuts"></a>Interpretation in terms of cuts</h3><ul>
<li>(从剪切的角度解释，看<a href="https://zjn-astonishe.github.io/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/">分布式计算模型</a>)</li>
<li>A cut in a space-time diagram is a line joining an arbitrary point on each process line that slices the space-time diagram into a <code>PAST</code> and a <code>FUTURE</code></li>
<li>A consistent global state corresponds to a cut in which every message received in the <code>PAST</code> of the cut was sent in the <code>PAST</code> of that cut(在过去接收的只能是在过去发送的), and such a cut is known as a consistent cut</li>
</ul>
<h3 id="Issues-in-recording-a-global-state"><a href="#Issues-in-recording-a-global-state" class="headerlink" title="Issues in recording a global state"></a>Issues in recording a global state</h3><ul>
<li>How to distinguish between the messages to be recorded in the snapshot from those not to be recorded(区分记录在快照的消息和未记录的消息)<ul>
<li>Any message that is sent by a process before recording its snapshot, must be recorded in the global snapshot (from C1).(在快照前发送的消息必须在快照中记录，无论是信道还是接收方)</li>
<li>Any message that is sent by a process after recording its snapshot, must not be recorded in the global snapshot (from C2).(在快照后发送的消息不能出现在快照中)</li>
</ul>
</li>
<li>How to determine the instant when a process takes its snapshot(如何确定何时该进行快照)<ul>
<li>A process $p_j$ must record its snapshot before processing a message $m_{ij}$ that was sent by process $p_i$ after recording its snapshot.(在发送进程快照后才发送的消息，接收进程必须在接收后处理该消息之前进行快照)</li>
</ul>
</li>
</ul>
<h2 id="Snapshot-algorithms"><a href="#Snapshot-algorithms" class="headerlink" title="Snapshot algorithms"></a>Snapshot algorithms</h2><p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Snapshot%20algorithms.png" alt="img"></p>
<h3 id="Chandy-Lamport-algorithm-For-FIFO-channels"><a href="#Chandy-Lamport-algorithm-For-FIFO-channels" class="headerlink" title="Chandy-Lamport algorithm(For FIFO channels)"></a>Chandy-Lamport algorithm(For FIFO channels)</h3><ul>
<li>uses a control message, called a <code>marker</code> whose role in a FIFO system is to separate messages in the channels(<code>marker</code>用于分离信道中的消息)</li>
<li>After a site has recorded its snapshot(记录快照后), it sends a <code>marker</code>, along all of its outgoing channels before sending out any more messages(发送更多消息前，沿着所有的传出信道发送<code>marker</code>)</li>
<li>A marker separates the messages in the channel into those to be included in the snapshot from those not to be recorded in the snapshot.(分为在快照中的消息和不在快照中的消息)</li>
<li>A process must record its snapshot no later than when it receives a marker on any of its incoming channels.(进程必须在其任何传入信道接收<code>marker</code>后处理<code>marker</code>前记录自己的快照)</li>
</ul>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><ul>
<li>The algorithm can be initiated by any process by executing the “Marker Sending Rule” by which it records its local state and sends a <code>marker</code> on each outgoing channel(任何一个进程都能作为发起者)</li>
<li>A process executes the “Marker Receiving Rule” on receiving a marker. If the process has not yet recorded its local state, it records the state of the channel on which the marker is received as empty and executes the “Marker Sending Rule” to record its local state.(所有如果在处理<code>marker</code>的时候没有保存本地快照，则相当于没有收到此<code>marker</code>，然后自己执行Marker Sending Rule，此前传<code>marker</code>的进程也会收到该进程的<code>marker&#39;</code>，则会再发一遍)</li>
<li>The algorithm terminates after each process has received a marker on all of its incoming channels.(如果每个进程在所有的传入信道都接收到了<code>marker</code>则算法终止)<ul>
<li>All the local snapshots get disseminated to all other processes and all the processes can determine the global state.(所有本地快照都会传播到所有其他进程，因此所有进程都可以确定全局状态。)</li>
</ul>
</li>
</ul>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Marker Sending Rule for process i</span><br><span class="line">1- Process i records its state</span><br><span class="line">2- For each outgoing channel C on which a marker has not been sent, i sends a marker along C, before i sends further messages along C</span><br><span class="line"></span><br><span class="line">Marker Receiving Rule for process j</span><br><span class="line">On receiving a marker along channel C:</span><br><span class="line">    if j has not recorded its state then</span><br><span class="line">        Record the state of C as the empty set</span><br><span class="line">        Follow the &quot;Marker Sending Rule&quot;</span><br><span class="line">    else</span><br><span class="line">        Record the state of C as the set of messages</span><br><span class="line">        received along C after j&#x27;s state was recorded</span><br><span class="line">        and before j received the marker along C</span><br></pre></td></tr></table></figure>
<h4 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h4><ul>
<li>Due to FIFO property of channels, it follows that no message sent after the marker on that channel is recorded in the channel state. Thus, condition $C2$ is satisfied(FIFO的特性，使得marker后发送的消息不会被记录，满足$C2$规则)</li>
<li>When a process $p_j$ receives message $m_{ij}$ that precedes the marker on channel $C_{ij}$($p_j$从信道$C_{ij}$收到在marker之前的$m_{ij}$后), it acts as follows: <ul>
<li>If process $p_j$ has not taken its snapshot yet, then it includes $m_{ij}$ in its recorded snapshot. (如果$p_j$还没进行快照，那么在后面进行快照的时候，需要包括$m_{ij}$)</li>
<li>Otherwise, it records $m_{ij}$ in the state of the channel $C_{ij}$. Thus, condition C1 is satisfied(否则把$m_{ij}$记录在信道$C_{ij}$的状态中，满足$C1$规则)</li>
</ul>
</li>
<li>$C1$和$C2$都满足，因此该算法是正确的</li>
</ul>
<h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><ul>
<li>The recoding part of a single instance of the algorithm requires $O(e)$ messages(该算法整个过程需要$O(e)$条消息，因为每个进程需要向各个信道都发marker，$e$表示的是消息信道的数量) and $O(d)$ time($d$表示网络的直径，表明的是marker传输的最长距离), where $e$ is the number of edges in the network and $d$ is the diameter of the network</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul>
<li>The recorded global state may not correspond to any of the global states that occurred during the computation.(记录的全局状态可能不对应于计算期间发生的任何全局状态)</li>
<li>This happens because a process can change its state asynchronously before the markers it sent are received by other sites and the other sites record their states.(进程可以在发送的marker被其他站点接收之前异步更改其自己的状态，并且其他站点记录自身的状态。其实就是说记录的状态被发出去后，发送者会继续运行，其他站点记录状态后记录在全局快照中，也会继续运行。全局状态的快照是由不同的异步局部状态组成的)<ul>
<li>But the system could have passed through the recorded global states in some equivalent executions.(虽然全局状态快照的情景没有同时发生，但异步发生过)</li>
<li>The recorded global state is a valid state in an equivalent execution and if a stable property (i.e., a property that persists) holds in the system before the snapshot algorithm begins, it holds in the recorded global snapshot.(记录的全局状态是等效执行的有效状态，如果在快照算法开始之前系统中保持稳定的属性(持久属性)，则将保持在记录的全局快照中)</li>
<li>Therefore, a recorded global state is useful in detecting stable properties(记录的全局状态在检测平稳的特点是有用的)</li>
</ul>
</li>
</ul>
<h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ul>
<li>In a non-FIFO system, a marker cannot be used to delineate messages into those to be recorded in the global state from those not to be recorded in the global state.(消息到达不按顺序，则无法划分记录在全局状态中的消息和不需要记录在全局状态中的消息)<ul>
<li>In a non-FIFO system, either some degree of inhibition or piggybacking of control information on computation messages to capture out-of-sequence messages.(只能通过某种程度的抑制或在计算消息上附加控制消息来捕获乱序消息)</li>
</ul>
</li>
</ul>
<h3 id="Spezialetti-Kearns-algorithm-For-FIFO-channels"><a href="#Spezialetti-Kearns-algorithm-For-FIFO-channels" class="headerlink" title="Spezialetti-Kearns algorithm(For FIFO channels)"></a>Spezialetti-Kearns algorithm(For FIFO channels)</h3><ul>
<li>There are two phases in obtaining a global snapshot(两个阶段获取全局快照): <ul>
<li>locally recording the snapshot at every process(每个进程本地记录快照) </li>
<li>distributing the resultant global snapshot to all the initiators(每个进程将生成的全局快照分发)</li>
</ul>
</li>
</ul>
<h4 id="Efficient-snapshot-recording-高效记录快照"><a href="#Efficient-snapshot-recording-高效记录快照" class="headerlink" title="Efficient snapshot recording(高效记录快照)"></a>Efficient snapshot recording(高效记录快照)</h4><ul>
<li>In the Spezialetti-Kearns algorithm, a markers carries the identifier of the initiator of the algorithm. Each process has a variable master to keep track of the initiator of the algorithm.(marker携带算法发起者的标识符，每个进程都由一个变量主控器来跟踪算法的发起者)</li>
<li>A key notion used by the optimizations is that of a region in the system. A region encompasses all the processes whose master field contains the identifier of the same initiator.(优化使用的一个关键概念是系统中的区域，每个区域包含的所有进程，都有包含同一启动器标识符的主字段)<ul>
<li>When the initiator’s identifier in a marker received along a channel is different from the value in the master variable, the sender of the marker lies in a different region.(当随着信道接收到的marker中的启动器的标识符与主变量中的值不同时，标识符的发送者处于不同的区域)</li>
<li>The identifier of the concurrent initiator is recorded in a local variable id-border-set.(并发启动器的标识符记录在局部变量中的id-border-set)</li>
</ul>
</li>
<li>The state of the channel is recorded just as in the Chandy-Lamport algorithm(including those that cross a border between regions, 包括跨越区域边界的信道).</li>
<li>Snapshot recording at a process is complete after it has received a marker along each of its channels.(进程的快照记录在沿其每个信道接收到标识符后完成)</li>
<li>After every process has recorded its snapshot, the system is partitioned into as many regions as the number of concurrent initiations of the algorithm.(每个进程记录其快照后，系统被划分为算法并发启动次数一样多的区域)</li>
<li>Variable id-border-set at a process contains the identifiers of the neighboring regions.(进程中的变量id-border-set包含相邻区域的标识符)</li>
</ul>
<h4 id="Efficient-dissemination-of-the-recorded-snapshot-高效传播记录的快照"><a href="#Efficient-dissemination-of-the-recorded-snapshot-高效传播记录的快照" class="headerlink" title="Efficient dissemination of the recorded snapshot(高效传播记录的快照)"></a>Efficient dissemination of the recorded snapshot(高效传播记录的快照)</h4><ul>
<li>In the snapshot recording phase, a forest of spanning trees is implicitly created in the system. The initiator of the algorithm is the root of a spanning tree and all processes in its region belong to its spanning tree.(在快照的记录阶段，系统中会隐式地创建一个生成森林，该算法的发起者是生成树的根，其区域中的所有进程都属于其生成树)</li>
<li>If $p_i$ receives its first marker from $p_j$ then process $p_j$ is the parent of process $p_i$ in the spanning tree.(进程接收到的第一个marker对应的发送者进程是该进程在生成树的父母节点)</li>
<li>When an intermediate process in a spanning tree has received the recorded states from all its child processes and has recorded the states of all incoming channels, it forwards its locally recorded state and the locally recorded states of all its descendent processes to its parent.(当生成树中的中间进程接收到其所有子进程记录的状态并记录了所有传入信道的状态时，会将其本地记录的状态及其所有子进程的本地记录状态转发给其父进程)</li>
<li>When the initiator receives the locally recorded states of all its descendents from its children processes, it assembles the snapshot for all the processes in its region and the channels incident on these processes.(当启动器从其子进程接收到其所有子进程的本地记录状态时，会为其区域中的所有进程以及这些进程上的信道进行快照)</li>
<li>The initiator exchanges the snapshot of its region with the initiators in adjacent regions in rounds.(发起者在轮次中与相邻区域的发起者交换各自区域的快照)</li>
<li>The message complexity of snapshot recording is $O(e)$ irrespective of the number of concurrent initiations of the algorithm.(快照记录的消息复杂度为$O(e)$，与算法的并发启动次数无关。$e$是传递消息的次数) The message complexity of assembling and disseminating the snapshot is $O(rn^2)$ where $r$ is the number of concurrent initiations.(消息包装和分发的复杂度是$O(rn^2)$，$r$是并发启动的数量，$n$是每个并发启动的子区域包含的进程节点的数量，平方是因为互相交换)</li>
</ul>
<h3 id="Lai-Yang-algorithm-For-non-FIFO-channels"><a href="#Lai-Yang-algorithm-For-non-FIFO-channels" class="headerlink" title="Lai-Yang algorithm(For non-FIFO channels)"></a>Lai-Yang algorithm(For non-FIFO channels)</h3><ul>
<li>The Lai-Yang algorithm fulfills this role of a marker in a non-FIFO system by using a coloring scheme on computation messages(使用涂色方案实现non-FIFO的marker) that works as follows:<ul>
<li>Every process is initially white(进程是初始化为白色) and turns red while taking a snapshot.(快照后变红) The equivalent of the “Marker Sending Rule” is executed when a process turns red.(变红的时候需要执行Marker Sending Rule)</li>
<li>Every message sent by a white (red) process is colored white (red).(什么色的进程发送什么颜色的消息)</li>
<li>Thus, a white (red) message is a message that was sent before (after) the sender of that message recorded its local snapshot.(发送者记录本地快照之前发送的为白色消息，之后发送的为红色消息)</li>
<li>Every white process takes its snapshot at its convenience, but no later than the instant it receives a red message.(每个白色进程都会在该进程方便的时候拍摄快照，但不能迟于它受到其他进程的红色消息的那一刻，最迟可以在接收到红色消息之后，处理红色消息之前)</li>
<li>Every white process records a history of all white messages sent or received by it along each channel(每个白色进程都记录了它沿每个信道发送或接收的所有白色消息的历史记录)</li>
<li>When a process turns red, it sends these histories along with its snapshot to the initiator process that collects the global snapshot(当一个进程变为红色时，会将这些历史记录及其快照发送给收集全局快照的启动器进程initiator)</li>
<li>The initiator process evaluates $transit(LS_i, LS_j)$ to compute the state of a channel $C_{ij}$ as given below:<ul>
<li>$SC_{ij}=$ white messages sent by $p_i$ on $C_{ij}$ — white messages received by $p_j$ on $C_{ij}=\{send(m_{ij})|send(m_{ij})\in LS_i\} - \{rec(m_{ij})|rec(m_{ij})\in LS_j\}$(得到的便是在信道中的消息)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Mattern’s-algorithm-For-non-FIFO-channels"><a href="#Mattern’s-algorithm-For-non-FIFO-channels" class="headerlink" title="Mattern’s algorithm(For non-FIFO channels)"></a>Mattern’s algorithm(For non-FIFO channels)</h3><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><ul>
<li>Mattern’s algorithm is based on vector clocks and assumes a single initiator process(该算法基于向量时钟和假设一个启动器进程) and works as follows:<ul>
<li>The initiator “ticks” its local clock and selects a future vector time $s$ at which it would like a global snapshot to be recorded(启动器根据本地时钟选定一个未来的向量时间$s$，该时间记录全局快照). It then broadcasts this time $s$ and freezes all activity until it receives all acknowledgements of the receipt of this broadcast.(该进程将整个未来向量时间$s$广播出去，然后阻塞该进程，直到收到广播出去的所有确认回复为止)</li>
<li>When a process receives the broadcast, it remembers the value $s$ and returns an acknowledgement to the initiator.(接收到广播的进程，会记住该广播来的值$s$并向发送者，即启动器返回确认)</li>
<li>After having received an acknowledgement from every process, the initiator increases its vector clock to $s$ and broadcasts a dummy message to all processes.(启动器收到所有的进程的确认回复后，启动器将自己的虚拟时钟修改为$s$，然后广播一个dummy消息)</li>
<li>The receipt of this dummy message forces each recipient to increase its clock to a value $\geq s$ if not already $\geq s$.(接收到dummy消息的进程也把自己的时钟修改为$s$)</li>
<li>Each process takes a local snapshot and sends it to the initiator when (just before) its clock increases from a value less than $s$ to a value $\geq s$.(每个进程在将少于$s$的时钟值修改为$s$前，拍摄一个本地快照，并将快照发送给启动器)</li>
<li>The state of $C_{ij}$ is all messages sent along $C_{ij}$, whose timestamp is smaller than $s$ and which are received by $p_j$ after recording $LS_j$.(信道的状态是时间戳小于s，且在接收进程拍摄快照后才接收的所有消息)</li>
</ul>
</li>
</ul>
<h4 id="Termination-detection-scheme-如何判断算法结束"><a href="#Termination-detection-scheme-如何判断算法结束" class="headerlink" title="Termination detection scheme(如何判断算法结束)"></a>Termination detection scheme(如何判断算法结束)</h4><ul>
<li><p>A termination detection scheme for non-FIFO channels is required to detect that no white messages are in transit(算法结束的条件是没有白消息在传输)</p>
</li>
<li><p>First Method</p>
<ul>
<li>Each process i keeps a counter $cntr_i$ that indicates the difference between the number of white messages it has sent and received before recording its snapshot.(进程都保持一个计数器$cntr_i$，用来表示在拍摄快照之前已经发送的白消息和已经接收到的白消息的差值)</li>
<li>It reports this value to the initiator process along with its snapshot and forwards all white messages, it receives henceforth, to the initiator.(将此值与其快照一起报告给启动器进程，并在此后将后续收到的所有白色消息转发给启动器)</li>
<li>Snapshot collection terminates when the initiator has received $\Sigma_i cntr_i$ number of forwarded white messages(当启动器收到的白消息的数量和计数器$cntr_i$的总和相等时，算法结束)</li>
</ul>
</li>
<li><p>Second Method</p>
<ul>
<li>Each red message sent by a process carries a piggybacked value of the number of white messages sent on that channel before the local state recording.(进程发送的每条红色消息都附带了在本地状态记录之前在该信道上发送的白色消息数量的值)</li>
<li>Each process keeps a counter for the number of white messages received on each channel.(每个进程保持了一个计数器，用来记录每个信道上接收到的白色消息的数量，因为是通常是互相的，所以接收的应该等于发出去的)</li>
<li>A process can detect termination of recording the states of incoming channels when it receives as many white messages on each channel as the value piggybacked on red messages received on that channel.(当一个进程在每个信道上接收到的白色消息与在该信道上接收的红色消息上附带的值一样多时，可以检测到记录传入信道状态的终止)</li>
</ul>
</li>
</ul>
<h3 id="Snapshots-in-a-causal-delivery-system"><a href="#Snapshots-in-a-causal-delivery-system" class="headerlink" title="Snapshots in a causal delivery system"></a>Snapshots in a causal delivery system</h3><ul>
<li>The causal message delivery property CO provides a built-in message synchronization to control and computation messages.(因果消息传递属性CO为控制和计算消息提供了内置的消息同步，即有因果序)<ul>
<li>assume that the underlying system supports causal message delivery</li>
</ul>
</li>
<li>In both these algorithms recording of process state is identical(记录过程状态的算法是相同的) and proceed as follows :<ul>
<li>An initiator process broadcasts a token, denoted as token, to every process including itself.(启动器进程向每个进程广播一个token)</li>
<li>Let the copy of the token received by process $p_i$ be denoted $token_i$.(进程接收到token后都拷贝一个token副本)</li>
<li>A process $p_i$ records its local snapshot $LS_i$ when it receives $token_i$ and sends the recorded snapshot to the initiator.(接收到$token_i$时拍摄其本地快照$LS_i$，并将该记录的快照发送给启动器initiator)</li>
<li>The algorithm terminates when the initiator receives the snapshot recorded by each process.(当启动器接收到每个进程记录的快照后算法终止)</li>
</ul>
</li>
</ul>
<h4 id="Correctness-1"><a href="#Correctness-1" class="headerlink" title="Correctness"></a>Correctness</h4><ul>
<li>For any two processes $p_i$ and $p_j$, the following property is satisfied:<ul>
<li>$send(m_{ij})\notin LS_i \Rightarrow rec(m_{ij})\notin LS_j$(消息$m_{ij}$不在进程$p_i$的快照$LS_i$中，能推断出接收消息$m_{ij}$也不在进程$p_j$的快照$LS_j$中)</li>
<li>This is due to the causal ordering property of the underlying system as explained next<ul>
<li>Let a message $m_{ij}$ be such that $rec(token_i)\rightarrow send(m_{ij})$($send(m_{ij})\notin LS_i$)</li>
<li>Then $send(token_j)\rightarrow send(m_{ij})$ and the underlying causal ordering property ensures that $rec(token_j)$, at which instant process $p_j$ records $LS_j$, happens before $rec(m_{ij})$(进程$p_i$先发送$token_j$给进程$p_j$，然后才发送$m_{ij}$，所以进程$p_j$先收到$token_j$拍摄快照$LS_j$，然后才接收$m_{ij}$?)</li>
<li>Thus, $m_{ij}$ whose send is not recorded in $LS_i$, is not recorded as received in $LS_j$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Acharya-Badrinath-algorithm"><a href="#Acharya-Badrinath-algorithm" class="headerlink" title="Acharya-Badrinath algorithm"></a>Acharya-Badrinath algorithm</h4><ul>
<li>Each process $p_i$ maintains arrays $SENT_i[1, …, N]$ and $RECD_i[1, …, N]$(进程$p_i$维护两个数组，一个发送数组，一个接收数组)<ul>
<li>$SENT_i[j]$ is the number of messages sent by process $p_i$ to process $p_j$</li>
<li>$RECD_i[j]$ is the number of messages received by process $p_i$ from process $p_j$</li>
</ul>
</li>
<li>Channel states are recorded as follows:<ul>
<li>When a process $p_i$ records its local snapshot $LS_i$ on the receipt of $token_i$, it includes arrays $RECD_i$ and $SENT_i$ in its local state before sending the snapshot to the initiator(发送给启动器的快照包括发送数组和接收数组)</li>
</ul>
</li>
<li>When the algorithm terminates, the initiator determines the state of channels as follows:(判断算法终止)<ul>
<li>The state of each channel from the initiator to each process is empty(从启动器到每个进程的每个信道都是空的，即没有消息在信道)<ul>
<li>The state of channel from process $p_i$ to process $p_j$ is the set of messages whose sequence numbers are given by $\{RECD_j[i]+1, …, SENT_i[j]\}$(在两个进程之间信道的消息是根据发送和接收数组确定的，发送数组里有而接收数组里没有的则在信道)</li>
</ul>
</li>
</ul>
</li>
<li>Complexity<ul>
<li>This algorithm requires $2n$ messages and 2 time units for recording and assembling the snapshot, where one time unit is required for the delivery of a message.(遍历所有的各个进程的传入传出信道)</li>
<li>If the contents of messages in channels state are required, the algorithm requires $2n$$ messages and 2 time units additionally.(就是还要遍历所有各个进程的传入传出信道)</li>
</ul>
</li>
</ul>
<h4 id="Alagar-Venkatesan-algorithm"><a href="#Alagar-Venkatesan-algorithm" class="headerlink" title="Alagar-Venkatesan algorithm"></a>Alagar-Venkatesan algorithm</h4><ul>
<li>A message is referred to as old if the send of the message causally precedes the send of the token, Otherwise, the message is referred to as new.(在发送token之前的消息为旧消息，否则为新消息)</li>
<li>When a process receives the token, it takes its snapshot(收到token后拍摄快照), initializes the state of all channels to empty(将所有的信道状态初始化为空), and returns <code>Done</code> message to the initiator(将Done消息返回给启动器). </li>
<li>Now onwards, a process includes a message received on a channel in the channel state only if it is an old message.(当消息是旧消息的时候，进程才会接收到信道上的消息，因为新消息是token发送之后的消息，而收到token后将信道都变为空，即新消息都丢了？)</li>
<li>After the initiator has received <code>Done</code> message from all processes, it broadcasts a Terminate message.(启动器接收到所有进程的Done消息后，广播一个终止消息)<ul>
<li>A process stops the snapshot algorithm after receiving a Terminate message.(非启动器进程则在收到终止消息后终止快照算法)</li>
</ul>
</li>
</ul>
<h3 id="Necessary-and-sufficient-conditions-for-consistent-global-snapshots"><a href="#Necessary-and-sufficient-conditions-for-consistent-global-snapshots" class="headerlink" title="Necessary and sufficient conditions for consistent global snapshots"></a>Necessary and sufficient conditions for consistent global snapshots</h3><h4 id="Consistent-global-snapshots"><a href="#Consistent-global-snapshots" class="headerlink" title="Consistent global snapshots"></a>Consistent global snapshots</h4><ul>
<li>许多应用要求在执行或post martem期间定期记录和分析本地进程状态</li>
<li>进程在执行过程中保存的中间状态称为进程的本地检查点(local checkpoint)</li>
<li>一致的快照由一组同时发生或可能同时发生的本地状态集合组成</li>
<li>进程异步保存checkpoint，假设每个进程在执行前保存一个初始checkpoint，在执行完后保存一个虚拟checkpoint(virtual)<ul>
<li>进程$p_p$第i个checkpoint表示为$C_{p, i}$</li>
<li>进程$p_p$的第i个checkpoint间隔(interval)包括它的第i-1个checkpoint和第i个checkpoint之间执行的所有计算(包括了第i-1个checkpoint期间的计算但不包括第i个checkpoint)</li>
</ul>
</li>
<li>即使两个本地checkpoint没有存在因果路径，也可能不属于一致的全局快照</li>
</ul>
<h4 id="zigzag-path"><a href="#zigzag-path" class="headerlink" title="zigzag path"></a>zigzag path</h4><ul>
<li><p>A zigzag path exists from a checkpoint $C_{x, i}$ to a checkpoint $C_{y, j}$ iff there exists messages $m_1, m_2, …, m_n(n\geq 1)$:</p>
<ul>
<li>$m_1$ is sent by process $p_x$ after $C_{x, i}$(第一条消息由zigzag路径起点快照发送)</li>
<li>If $m_k(1\leq k\leq n)$ is received by process $p_z$, then $m_{k+1}$ is sent by $p_z$ in the same or a later checkpoint interval(although $m_{k+1}$ may be sent before or after $m_k$ is received)(通常来讲是消息有顺序。但也允许进程在接收到因果路径中的前一个消息之前发送消息，只要在同一个checkpoint间隔。后发送的消息在后一个间隔则不需考虑上述情况)</li>
<li>$m_n$ is received by process $p_y$ before $C_{y, j}$(最后一条消息由zigzag路径终点快照接收)</li>
<li>A zigzag path between two checkpoints is a causal path(因果路径)<ul>
<li>A causal path exists from a checkpoint A to another checkpoint B iff there is chain of messages starting after A and ending before B such that each message is sent after the previous one in the chain is received(因果路径消息必须有序)</li>
<li>a causal path is always a zigzag path, but a zigzag path need not be a causal path.</li>
</ul>
</li>
<li>如下图的进程$p_1$的快照$C_{1,1}$和进程$p_2$的快照$C_{2,2}$存在因果路径，zigzag路径允许进程$p_2$在接收消息$m_3$之前发送消息$m_4$给进程$p_3$，由快照$C_{3,2}$记录。因此$C_{1,1}$和$C_{3,2}$之间存在zigzag path<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/zigzag-path.png" alt="img"></li>
</ul>
</li>
<li><p>特殊的zigzag path—— zigzag cycle</p>
<ul>
<li>A checkpoint $C$ is involved in a zigzag cycle iff there is a zigzag path from $C$ to itself(起点和终点都是自己的zigzag路径)</li>
<li>如下图的进程$p_2$的快照$C_{2, 1}$，起始消息$m_2$给$p_1$，$p_1$在同一个checkpoint间隙早些时候发送消息$m_1$给$p_2$，终点也是$C_{2, 1}$</li>
<li>a causal path never forms a cycle.(因果路径不存在环)<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/zigzag-cycle.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="Necessary-and-sufficient-conditions"><a href="#Necessary-and-sufficient-conditions" class="headerlink" title="Necessary and sufficient conditions"></a>Necessary and sufficient conditions</h4><ul>
<li>if no zigzag path (or cycle) exists between any two checkpoints from a set S of checkpoints, then a consistent snapshot can be formed that includes the set S of checkpoints and vice versa.(checkpoint集合中任意两个checkpoint之间都没有zigzag路径的话，则整个集合的checkpoint可以构成consistent global snapshot，反之亦然)<ul>
<li>The absence of a causal path between checkpoints in a snapshot corresponds to the necessary condition for a consistent snapshot(必要条件：如果一个snapshot是consistent的，则其中的检查点之间没有因果路径，zigzag路径是特殊的因果路径，没有因果路径自然也没有zigzag路径)</li>
<li>The absence of a zigzag path between checkpoints in a snapshot corresponds to the necessary and sufficient conditions for a consistent snapshot.(充要条件)</li>
<li>A set of checkpoints S can be extended to a consistent snapshot if and only if no checkpoint in S has a zigzag path to any other checkpoint in S.</li>
<li>A checkpoint can be a part of a consistent snapshot if and only if it is not invloved in a Z-cycle(要在consistent的snapshot中加入一个checkpoint，则当且仅当该checkpoint和snapshot中的任意一个checkpoint之间不存在zigzag路径，而其自身不存在zigzag回路)</li>
</ul>
</li>
</ul>
<h4 id="Finding-consistent-global-snapshots-in-a-distributed-computation"><a href="#Finding-consistent-global-snapshots-in-a-distributed-computation" class="headerlink" title="Finding consistent global snapshots in a distributed computation"></a>Finding consistent global snapshots in a distributed computation</h4><ul>
<li>Discuss how individual local checkpoints can be combined with those from other processes to form global snapshots that are consistent.</li>
<li>Let $A, B$ be individual checkpoints and $R, S$ be sets of checkpoints. Let $\leadsto$ be a relation defined over checkpoints and sets of checkpoints such that:<ul>
<li>$A\leadsto B$ iff a Z-path exists from $A$ to $B$</li>
<li>$A\leadsto S$ iff a Z-path exists from $A$ to some member of $S$</li>
<li>$S\leadsto A$ iff a Z-path exists from some member of $S$ to $A$</li>
<li>$R\leadsto S$ iff a Z-path exists from some member of $R$ to some member of $S$</li>
<li>$S\nrightarrow S$ defines that no Z-path(including Z-cycle) exists from any member of $S$ to any other member of $S$ and implies that checkpoints in $S$ are all from different processes</li>
</ul>
</li>
<li>A set of checkpoints $S$ can be extended to a consistent global snapshot iff $S\nrightarrow S$<ul>
<li>A checkpoint $C$ can be part of a consistent global snapshot iff it is not involved in a Z-cycle</li>
<li>A set of checkpoints $S$ is a consistent global snapshot iff $S\nrightarrow S$ and $|S|=N$, where $N$ is the number of processes</li>
</ul>
</li>
<li>Given a set $S$ of checkpoints such that $S\nrightarrow S$, what checkpoints from other processes can be combined with $S$ to build a consistent global snapshot?<ul>
<li>None of the checkpoints that have a Z-path to or from any of the checkpoints in $S$ can be used</li>
<li>Only those checkpoints that have no Z-paths to or from any of the checkpoints in $S$ are candidates for inclusion in the consistent snapshot<ul>
<li>The set of all such candidates is called as the Z-zone of $S$ and </li>
<li>All checkpoints that have no causal path to or from any checkpoint in $S$ is called as the C-cone of $S$ </li>
<li>the Z-cone of $S$ is a subset of the C-cone of $S$ for an arbitrary $S$<br><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Z-cone%20and%20S-cone.png" alt="img"></li>
</ul>
</li>
<li>Although candidates for building a consistent snapshot from $S$ must lie in the Z-cone of $S$, not all checkpoints in the Z-cone can form a consistent snapshot with $S$. (在Z-cone里的检查点不一定能与$S$构成一致性的快照，但能与$S$构成一致性快照的检查点一定在Z-cone)<ul>
<li>If a checkpoint in the Z-cone is involved in a Z-cycle, then it cannot be part of a consistent snapshot.(Z-cone里可能存在zigzag环)</li>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$. Then, for each process $p_q$, the set $S_{useful}^q$ is defined as <ul>
<li>$S_{useful}^q=\{C_{q, i} | (S\nrightarrow C_{q, i}\bigwedge(C_{q, i}\nrightarrow S)\bigwedge(C_{q, i}\nrightarrow C_{q, i})\}$</li>
<li>$\displaystyle S_{useful}=\bigcup_q S_{useful}^q$(各个进程可与$S$构成一致性快照的检查点的并集)</li>
</ul>
</li>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$, let $C_{q, i}$ be any checkpoint of process $p_q$ such that $C_{q, i}\notin S$. Then $S\bigcup \{C_{q, i}\}$ can be extended to a consistent snapshot iff $C_{q, i}\in S_{useful}$($S_{useful}$是所有可以与$S$构成一致性快照的检查点)</li>
</ul>
</li>
<li>Although none of the checkpoints in $S_{useful}$ has a Z-path to or from any checkpoint in $S$, Z-paths may exist between members of $S_{useful}$($S_{useful}$里的检查点之间可能会存在Z-path)</li>
<li>One final constraint is placed on the set $T$ we choose from $S_{useful}$ to build a consistent snapshot from $S$: checkpoints in $T$ must have no Z-paths between them. Furthermore, since $S\nrightarrow S$, at least one such $T$ must exist(即使只有一个元素)<ul>
<li>Let $S$ be a set of checkpoints such that $S\nrightarrow S$ and let $T$ be any set of checkpoints such that $S\bigcap T=\empty$. Then $S\bigcup T$ is a consistent global snapshot iff <ul>
<li>$T\subseteq S_{useful}$</li>
<li>$T\nrightarrow T$</li>
<li>$|S\bigcup T|=N$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Manivannan-Netzer-Singhal-algorithm-for-enumerating-consistent-snapshots-算法伪代码"><a href="#Manivannan-Netzer-Singhal-algorithm-for-enumerating-consistent-snapshots-算法伪代码" class="headerlink" title="Manivannan-Netzer-Singhal algorithm for enumerating consistent snapshots(算法伪代码)"></a>Manivannan-Netzer-Singhal algorithm for enumerating consistent snapshots(算法伪代码)</h4><ul>
<li>compute all consistent snapshots that include a given set a set of checkpoints $S$</li>
</ul>
<p>ComputeAllCgs($S$) {  // 计算一个完整的一致性快照<br>  $\quad$let $G=\empty$<br>  $\quad$if $S\nrightarrow S$ then<br>  $\quad<script type="math/tex">\quad$let `AllProcs` be the set of all processes not represented in $S$ // 在没有加入一致性快照的进程里选择
  $\quad</script>\quad$<code>ComputeAllCgsForm</code>($S$, $AllProcs$)<br>  $\quad$return $G$<br>}<br>ComputeAllCgsForm($T$, $ProcSet$) {<br>  $\quad$if $(ProcSet=\empty)$ then   // 已经是完整的一致性快照了<br>  $\quad<script type="math/tex">\quad</script>G=G\bigcup\{T\}$<br>  $\quad$else //否则递归查找<br>  $\quad<script type="math/tex">\quad$let $p_q$ be any process in $ProcSet$
  $\quad</script>\quad$for each checkpoint $C\in T_{useful}^q$ do  // 首先还是得保证检查点是可用的<br>  $\quad<script type="math/tex">\quad</script>\quad$<code>ComputeAllCgsForm</code>($T\bigcup\{C\}$, $ProcSet\setminus \{p_q\}$)<br>}</p>
<ul>
<li>Let $S$ be a set of checkpoints and $G$ be the set returned by <code>ComputeAllCgs</code>. If $S\nrightarrow S$, then $T\in G$ iff $T$ is a consistent snapshot containing $S$. That is, $G$ contains exactly the consistent snapshots that contain $S$</li>
</ul>
<h4 id="R-graph-to-determine-the-existence-of-Z-paths-between-checkpoints"><a href="#R-graph-to-determine-the-existence-of-Z-paths-between-checkpoints" class="headerlink" title="R-graph to determine the existence of Z-paths between checkpoints"></a>R-graph to determine the existence of Z-paths between checkpoints</h4><ul>
<li>Discuss a method for determining the existence of Z-paths between checkpoints in a distributed computation that has terminated or has stopped execution, using the rollback-dependency graph (R-graph).</li>
<li>The rollback-dependency graph of a distributed computation is a directed graph $G=(V, E)$, where the vertices $V$ are the checkpoint of the distributed computation and an edge $(C_{p, i}, C_{q, j})$ from checkpoint $C_{p, i}$ to checkpoint $C_{q, j}$ belongs to $E$ if<ul>
<li>$p=q$ and $j=i+1$</li>
<li>$p\neq q$ and a message $m$ sent from the $i^{th}$ checkpoint interval of $p_p$ is received by $p_q$ in its $j^{th}$ checkpoint interval($i, j\gt 0$)</li>
<li>there is a path from $C$ to $D$ in the R-graph by $C\rightsquigarrow^{rd} D$, only denotes the existence of a path, does not specify any particular path</li>
</ul>
</li>
<li>Let $G=(V, E)$ be the R-graph of a distributed computation. For any two checkpoints $C_p^i$ and $C_q^j$, $C_p^i\rightsquigarrow C_q^j$ iff:<ul>
<li>$p=q$ and $i\lt j$(因果路径)</li>
<li>$ C_p^{i+1}\rightsquigarrow^{rd} C_q^j$ in $G$(note that in this case $p$ could still be equal to $q$)</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Rgraph.png" alt="img"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">高级分布式系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/23/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2024-10-23-%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高性能处理器的并行计算技术</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Ray%20conclusion/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ray conclusion</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/28/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-28-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/" title="分布式计算模型"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="title">分布式计算模型</div></div></a></div><div><a href="/2024/09/21/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-21-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" title="分布式系统简介"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="title">分布式系统简介</div></div></a></div><div><a href="/2024/09/29/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-09-29-%E9%80%BB%E8%BE%91%E6%97%B6%E9%97%B4/" title="逻辑时间"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-29</div><div class="title">逻辑时间</div></div></a></div><div><a href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%9C%AF%E8%AF%AD%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/" title="术语和基本算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="title">术语和基本算法</div></div></a></div><div><a href="/2025/01/11/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2025-01-11-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%92%8C%E7%BB%84%E9%80%9A%E4%BF%A1/" title="消息序和组通信"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="title">消息序和组通信</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95"><span class="toc-text">全局状态及快照算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#System-model"><span class="toc-text">System model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Models-of-communication"><span class="toc-text">Models of communication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consistent-global-state"><span class="toc-text">Consistent global state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpretation-in-terms-of-cuts"><span class="toc-text">Interpretation in terms of cuts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Issues-in-recording-a-global-state"><span class="toc-text">Issues in recording a global state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Snapshot-algorithms"><span class="toc-text">Snapshot algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Chandy-Lamport-algorithm-For-FIFO-channels"><span class="toc-text">Chandy-Lamport algorithm(For FIFO channels)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#process"><span class="toc-text">process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Code"><span class="toc-text">Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Correctness"><span class="toc-text">Correctness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Complexity"><span class="toc-text">Complexity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disadvantages"><span class="toc-text">Disadvantages</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spezialetti-Kearns-algorithm-For-FIFO-channels"><span class="toc-text">Spezialetti-Kearns algorithm(For FIFO channels)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Efficient-snapshot-recording-%E9%AB%98%E6%95%88%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7"><span class="toc-text">Efficient snapshot recording(高效记录快照)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Efficient-dissemination-of-the-recorded-snapshot-%E9%AB%98%E6%95%88%E4%BC%A0%E6%92%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BF%AB%E7%85%A7"><span class="toc-text">Efficient dissemination of the recorded snapshot(高效传播记录的快照)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lai-Yang-algorithm-For-non-FIFO-channels"><span class="toc-text">Lai-Yang algorithm(For non-FIFO channels)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mattern%E2%80%99s-algorithm-For-non-FIFO-channels"><span class="toc-text">Mattern’s algorithm(For non-FIFO channels)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Process"><span class="toc-text">Process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Termination-detection-scheme-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95%E7%BB%93%E6%9D%9F"><span class="toc-text">Termination detection scheme(如何判断算法结束)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshots-in-a-causal-delivery-system"><span class="toc-text">Snapshots in a causal delivery system</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Correctness-1"><span class="toc-text">Correctness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Acharya-Badrinath-algorithm"><span class="toc-text">Acharya-Badrinath algorithm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alagar-Venkatesan-algorithm"><span class="toc-text">Alagar-Venkatesan algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Necessary-and-sufficient-conditions-for-consistent-global-snapshots"><span class="toc-text">Necessary and sufficient conditions for consistent global snapshots</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Consistent-global-snapshots"><span class="toc-text">Consistent global snapshots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zigzag-path"><span class="toc-text">zigzag path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Necessary-and-sufficient-conditions"><span class="toc-text">Necessary and sufficient conditions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Finding-consistent-global-snapshots-in-a-distributed-computation"><span class="toc-text">Finding consistent global snapshots in a distributed computation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Manivannan-Netzer-Singhal-algorithm-for-enumerating-consistent-snapshots-%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-text">Manivannan-Netzer-Singhal algorithm for enumerating consistent snapshots(算法伪代码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#R-graph-to-determine-the-existence-of-Z-paths-between-checkpoints"><span class="toc-text">R-graph to determine the existence of Z-paths between checkpoints</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-21_Exploration_and_Discovery/" title="21_Exploration_and_Discovery">21_Exploration_and_Discovery</a><time datetime="2025-09-14T05:24:13.000Z" title="发表于 2025-09-14 13:24:13">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-20_Prioritization/" title="20_Prioritization">20_Prioritization</a><time datetime="2025-09-14T05:23:46.000Z" title="发表于 2025-09-14 13:23:46">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-19_Evaluation_and_Monitoring/" title="19_Evaluation_and_Monitoring">19_Evaluation_and_Monitoring</a><time datetime="2025-09-14T05:23:25.000Z" title="发表于 2025-09-14 13:23:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-18_Guardrails_Safety_Patterns/" title="18_Guardrails_Safety_Patterns">18_Guardrails_Safety_Patterns</a><time datetime="2025-09-14T05:23:02.000Z" title="发表于 2025-09-14 13:23:02">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-17_Reasoning_Techniques/" title="17_Reasoning_Techniques">17_Reasoning_Techniques</a><time datetime="2025-09-14T05:22:31.000Z" title="发表于 2025-09-14 13:22:31">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>