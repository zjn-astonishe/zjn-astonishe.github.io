<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Ray conclusion | ZJN_BLOG</title><meta name="keywords" content="论文阅读"><meta name="author" content="ZJN"><meta name="copyright" content="ZJN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《Ray: A Distributed Framework for Emerging AI Applications》 ReviewAbstract本文提出了一个分布式强化学习框架Ray，以解决其他框架无法统一直接地完成强化学习计算的问题。  功能上，Ray实现了一个统一的接口，由一个动态执行的引擎提供并行任务(task-parallel)和基于actor的计算(actor-based compu">
<meta property="og:type" content="article">
<meta property="og:title" content="Ray conclusion">
<meta property="og:url" content="http://zjn-astonishe.github.io/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Ray%20conclusion/index.html">
<meta property="og:site_name" content="ZJN_BLOG">
<meta property="og:description" content="《Ray: A Distributed Framework for Emerging AI Applications》 ReviewAbstract本文提出了一个分布式强化学习框架Ray，以解决其他框架无法统一直接地完成强化学习计算的问题。  功能上，Ray实现了一个统一的接口，由一个动态执行的引擎提供并行任务(task-parallel)和基于actor的计算(actor-based compu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png">
<meta property="article:published_time" content="2024-10-27T01:06:43.000Z">
<meta property="article:modified_time" content="2024-11-09T04:33:57.466Z">
<meta property="article:author" content="ZJN">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zjn-astonishe.github.io/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Ray%20conclusion/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZJN","link":"链接: ","source":"来源: ZJN_BLOG","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#000000","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ray conclusion',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-09 12:33:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3207144_mqiyof22xva.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ZJN_BLOG" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJN_BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ray conclusion</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-27T01:06:43.000Z" title="发表于 2024-10-27 09:06:43">2024-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-09T04:33:57.466Z" title="更新于 2024-11-09 12:33:57">2024-11-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="《Ray-A-Distributed-Framework-for-Emerging-AI-Applications》-Review"><a href="#《Ray-A-Distributed-Framework-for-Emerging-AI-Applications》-Review" class="headerlink" title="《Ray: A Distributed Framework for Emerging AI Applications》 Review"></a>《Ray: A Distributed Framework for Emerging AI Applications》 Review</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文提出了一个分布式强化学习框架Ray，以解决其他框架无法统一直接地完成强化学习计算的问题。</p>
<ul>
<li>功能上，Ray实现了一个统一的接口，由一个动态执行的引擎提供并行任务(task-parallel)和基于actor的计算(actor-based computation)的支持。</li>
<li>性能上，Ray采用分布式调度器和一个分布式的(distributed)且容许出错的(falut-tolerant)存储以管理系统的状态控制。</li>
<li>实验结果表明：Ray拥有每秒超过180万个任务的扩展性，以及在几个具有挑战性的强化学习应用中拥有比其他现有专门系统更好的性能。</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>新兴的人工智能应用越来越多地运行在动态的环境中。它们对环境的变化做出反应，并采取一系列行动来完成长期目标——不仅是利用收集到的数据，而且还要探索可能的行动空间。这些更广泛的要求很自然地被置于强化学习(RL)的范式中。</p>
<p>强化学习(Reinforcement Learning，RL)，即在一个不确定的环境中，基于延迟和有限的反馈，进行不断地学习。它的核心目标是学习一个策略(strategy)，实现从环境状态到行动选择的映射，以达到更好的效果。这就提出了它需要具备的三个主要能力：</p>
<ul>
<li>依赖于模拟(simulation)去评估策略，探索不同的行动序列，并了解这些选择的长期后果。</li>
<li>需要进行分布式训练，根据模拟或与物理世界的互动产生的数据改进策略。</li>
<li>策略的目的是提供解决方案以控制问题。因此有必要在closed-loop和open-loop的控制场景中为策略提供服务。</li>
</ul>
<h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>考虑RL系统的基本组成部分，如图1所示，在一个RL环境中，一个agent会反复与环境进行交互，它的目标是学习一个使奖励(reward)最大化的策略(policy)。策略则是一个从环境状态到行动选择的映射。其中的Environment、Agent、state、action、reward的精确定义是视应用而定的。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/16.png" style="zoom: 33%;" /></p>
<p>为了学习一个策略，Agent通常要采用两步程序：</p>
<ul>
<li>评估策略<ul>
<li>为了评估策略，Agent需要与Environment互动，产生由state和reward二元组构成的trajectory。</li>
</ul>
</li>
<li>改进策略<ul>
<li>根据得到的trajectory改进policy：按照使reward最大化的梯度方向更新policy。</li>
</ul>
</li>
</ul>
<p>图2显示了一个Agent学习策略的伪代码例子，通过调用<code>rollout(environment, policy)</code>生成trajectory评估策略，然后调用<code>train_policy()</code>通过<code>policy_update(trajectories)</code>改进当前策略。随后不断重复，直到收敛。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/1.png" style="zoom:45%;" /></p>
<p>由伪代码可以看出，RL应用的框架必须为Training、Serving和Simulation提供有效的支持：</p>
<ul>
<li>Training涉及运行随机梯度下降(SGD)以更新策略。</li>
<li>Serving使用训练过的策略，根据环境的当前状态采取一个行动。</li>
<li>Simulation进行策略评估。</li>
</ul>
<p>因此，RL应用的框架应该满足以下的需求：</p>
<ul>
<li><p>支持细粒度的计算：</p>
<ul>
<li>在真实世界交互在毫秒内呈现动作，并执行大量的计算。</li>
</ul>
</li>
<li><p>支持异构的计算</p>
<ul>
<li><p>时间上：计算的持续时间从毫秒到小时不等</p>
</li>
<li><p>硬件上：训练通常需要异构的硬件(CPU、GPU、TPU)</p>
</li>
</ul>
</li>
<li><p>灵活的计算模型：无状态计算和有状态计算</p>
<ul>
<li>无状态计算：在任何节点上都可运行，很适合细粒度的模拟和数据处理，如从图像或视频中提取特征。</li>
<li>有状态计算，非常适合实现参数服务器(parameter server)，对GPU支持的数据进行重复计算，或运行不暴露其状态的第三方模拟器。</li>
</ul>
</li>
<li><p>动态执行</p>
<ul>
<li>计算完成的顺序并不总是事先知道的。</li>
<li>计算的结果可以决定未来的计算。</li>
</ul>
</li>
<li><p>高吞吐量</p>
<ul>
<li>为了在大型集群中实现较高的利用率，框架必须每秒能处理数百万的任务。</li>
</ul>
</li>
<li><p>通用性</p>
<ul>
<li>能够与现有的模拟器和深度学习框架无缝集成。</li>
</ul>
</li>
</ul>
<h3 id="Deficiencies"><a href="#Deficiencies" class="headerlink" title="Deficiencies"></a>Deficiencies</h3><p>RL要求Training、Serving和Simulation必须紧密耦合在一个应用程序中，且三者有严格的延迟要求。但目前没有任何框架能支持。</p>
<ul>
<li>MapReduce、Apache Spark、Dryad等批量同步并行系统(Bulk-synchronous parallel systems)不支持细粒度模拟(fine-grained simulation)或策略服务(policy serving)。</li>
<li>CIEL、Dask等任务并行系统(Task-parallel systems)和Naiad、Storm等流媒体系统(streaming systems)几乎不支持分布式的训练和服务(distributing training and serving)</li>
<li>TensorFlow和MXNet等分布式深度学习框架不支持模拟(simulation)和服务(serving)。</li>
<li>TensorFlow Serving和Clipper等模型服务系统不支持训练(training)和模拟(simulation)。</li>
</ul>
<p>也许在理论上可以直接缝合多个专门的框架以提供整体功能，但在实践中，系统间由此产生的数据移动和延迟会令人望而却步。</p>
<p>如果为专门的RL应用程序构建一次性的系统(one-off systems)，会给分布式应用程序的开发带来巨大的系统工程负担，因为基本把系统层需要处理的问题推到了应用层。</p>
<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><h3 id="Programming-and-Computation-Model"><a href="#Programming-and-Computation-Model" class="headerlink" title="Programming and Computation Model"></a>Programming and Computation Model</h3><p>Ray实现了一个动态任务图计算模型(dynamic task graph computation model)，将应用程序建模为一个在执行过程中不断变化的依赖性任务图。在此基础上，提供了actor和task-parallel的编程抽象。</p>
<h4 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h4><p>在Ray中有两种编程模型：task和actor</p>
<ul>
<li><p>task：表示在无状态worker上执行一个remote函数。当调用一个remote函数的时候，会立即返回表示task结果的future(可以由<code>ray.get()</code>API获取)。也可以作为参数传递给其他remote函数，而无需等待结果。</p>
<ul>
<li>由于是无状态的，所以输出完全由输入决定。</li>
<li>相当于C/C++中的函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running a Task</span></span><br><span class="line"><span class="comment"># Define the square task.</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch four parallel square tasks.</span></span><br><span class="line">futures = [square.remote(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve results</span></span><br><span class="line"><span class="built_in">print</span>(ray.get(futures))</span><br><span class="line"><span class="comment"># -&gt;[0, 1, 4, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>actor：表示有状态的计算模型，每个actor都公开了其可以被远程调用并连续执行的方法(这些方法类似于task，不同之处是这些方法在有状态worker上执行)。actor的句柄可以传递给其他的actor或者task，使它们也能够调用该actor上的方法。</p>
<ul>
<li>相当于C/C++中的类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calling an Actor</span></span><br><span class="line"><span class="comment"># Define the Counter actor.</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">incr</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.i += value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Counter actor.</span></span><br><span class="line">c = Counter.remote()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Submit calls to the actor. These calls run asynchronously but in</span></span><br><span class="line"><span class="comment"># submission order on the remote actor process.</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    c.incr.remote(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve final actor state.</span></span><br><span class="line"><span class="built_in">print</span>(ray.get(c.get.remote()))</span><br><span class="line"><span class="comment"># -&gt; 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两者主要区别如表2所示：</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/17.png" style="zoom:50%;" /></p>
<p>为了满足异构性和灵活性的需求，用三种方式增强API：</p>
<ul>
<li>为了处理具有不同持续时间的并发任务，引入<code>ray.wait()</code>，等待前k个可用结果，而不是像<code>ray.get()</code>等待所有的结果。</li>
<li>为了处理资源异构任务，Ray使开发人员能够指定资源需求(在定义task和actor的时候指定)，以便Ray调度器可以高效管理资源。</li>
<li>为了提高灵活性，启用了嵌套的remote函数，意味着remote函数可以调用其他remote函数。对于实现高可扩展性也是至关重要的，因为它允许多个进程以分布式方式调用remote函数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2.png" style="zoom:50%;" /></p>
<div style="page-break-after: always;"></div>

<h4 id="Computation-Model"><a href="#Computation-Model" class="headerlink" title="Computation Model"></a>Computation Model</h4><p>Ray采用了动态任务图计算模型。当remote函数与actor方法的输入可用时，系统会自动触发它们的执行。其构建方式可以从下面图3和图4实例得知：</p>
<p><center class = "half">
  <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/4.png" width="49%"/>
  <img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/3.png" width="50%"/>
</center></p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>如图5所示，Ray的架构设计分为两层：</p>
<ul>
<li>提供API的应用层。</li>
<li>提供高扩展性和容错的系统层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/22.png" style="zoom: 40%;" /></p>
<h4 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h4><p>Ray的应用层采用传统的driver-worker模式进行组织：</p>
<ul>
<li>driver：运行用户程序的进程。</li>
<li>worker：一个无状态的进程，用于执行由driver或另一个worker调度的task(remote函数)。它会自动启动，并由系统曾分配任务。</li>
<li>actor：一个有状态的进程，只执行它公开的方法。相当于worker或driver的显式实例化。<ul>
<li>方法是串行执行的，且每个方法都依赖于前一个方法执行所产生的状态。</li>
</ul>
</li>
</ul>
<h4 id="System-Layer"><a href="#System-Layer" class="headerlink" title="System Layer"></a>System Layer</h4><p>系统层包括三个主要的组件：所有的组件都具备水平可扩展性和容错性。</p>
<ul>
<li><p>全局控制存储(global control store，GCS)</p>
<ul>
<li>负责维护系统的整个控制状态，核心是具有发布订阅(pub-sub)功能的KV(key-value)存储。<ul>
<li>每条存储的数据都会采用一条随机生成的数据作为ID，利用ID作为分片键将数据分散到多个GCS分片中。由于GCS也是分布式的，等同于一个分布式的redis集群加上一个统一入口，分片提供了扩展能力。并且每个分片都进行了链复制(chain-replicated)以保证容错。</li>
</ul>
</li>
<li>GCS显著简化了Ray的总体设计，使得系统中的每个节点(除了GCS节点)都是无状态的。<ul>
<li>实现了持久脉络存储(durable lineage storage)与其他系统组件的解耦。所有的节点在故障时只需重新启动并从GCS读取存储的脉络(lineage)即可恢复。</li>
<li>将对象元数据(object metadata)存储在GCS，而不是全局调度器中，实现任务调度和数据传输的解耦，最大限度减少任务调度的开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>自下而上的分布式调度器(bottom-up distributed scheduler，DS)</p>
<ul>
<li><p>设计了一个由全局调度器和每个节点上的本地调度器组成的两级层次调度器。</p>
<ul>
<li>都使用事件驱动的单线程进程(event-driven singlet-hreaded process)实现。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/19.png" style="zoom:50%;" /></p>
</li>
<li><p>本地调度器(local scheduler)</p>
<ul>
<li>为了避免全局调度器过载，在节点上创建的task首先提交到节点的本地调度器。自下而上的意思便是首先在本地尝试调度task。</li>
<li>如果节点过载(本地task队列超过了预定义的阈值)，或者不能满足task的需求(例如缺乏GPU)，本地调度器将决定不在本地调度task，而将其转发给全局调度器。</li>
</ul>
</li>
<li><p>全局调度器(global scheduler)</p>
<ul>
<li>考虑每个节点的负载和task的约束条件做出调度决定。更确切的说，全局调度器确定有足够的任务所要求类型的资源的节点集，并在这些节点中选择那个具有最低估计等待时间的节点。<ul>
<li>最低估计等待时间(lowest estimated waiting time)为以下两项之和：<ul>
<li>task在该节点排队的估计时间(task队列大小*平均task执行时间)。</li>
<li>task的远程输入的估计传输时间(远程输入的总大小除以平均带宽)。</li>
</ul>
</li>
</ul>
</li>
<li>全局调度器通过心跳(heartbeats)获取每个节点的队列大小和资源的可用性。</li>
<li>全局调度器使用简单的指数平均(simple exponential averaging)计算平均task执行时间和平均传输带宽。</li>
<li>全局调度器实际也是分布式的。如果全局调度器成为了瓶颈，可以通过GCS实例化更多的共享相同信息的调度器副本，使得调度器架构具有很高的可扩展性。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存中的分布式对象存储(In-Memory distributed object store，DOS)</p>
<ul>
<li>为了最小化task的延迟，实现了一个基于内存的分布式存储系统，用于存储每个task的输入和输出，或者无状态的计算结果。<ul>
<li>Ray中的节点在启动时，默认会从机器的物理内存占据一部分作为对象存储。</li>
<li>对象存储直接采用Apache Arrow数据格式。</li>
</ul>
</li>
<li>每个节点通过共享内存进行对象存储：<ul>
<li>如果本地资源能够满足，则允许在同一节点上运行的不同task之间进行零拷贝的数据共享。</li>
<li>对象存储仅限于不可变的数据，无需更新对象。</li>
<li>如果task的输入不是来自本地，则在执行之前DOS会将输入复制到本地的对象存储中。task的输出也会写入本地的对象存储。<ul>
<li>复制消除了由热数据对象引起的潜在瓶颈(不需要多次通信传输相同对象)。内存不够时，使用LRU机制将部分数据换出内存，写入磁盘。</li>
<li>task只需要从本地内存读取数据或像本地内存写入数据(应用层)，因此最大限度地缩短了任务的执行时间，但也增加了计算绑定工作负载的吞吐量。</li>
</ul>
</li>
<li>当节点出现故障时，Ray通过重启节点运行re-execution进行恢复，在初始执行期间，存储在GCS中的脉络会追踪无状态的task和有状态的actor，并使用前者重构重启节点存储中的对象。</li>
<li>对象存储不支持分布式对象，使用者可以在应用层去实现。</li>
</ul>
</li>
<li>为了在不同的对象存储之间传输大型的对象，将对象分割到多个TCP连接中。</li>
</ul>
</li>
</ul>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Ray是一个活跃的开源项目(40k代码)，与Python环境完全集成，只需要执行以下指令即可轻松安装。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Ray</span><br></pre></td></tr></table></figure>
<div style="page-break-after: always;"></div>

<h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><p>下面展示Ray是如何运行端到端的工作的：以将两个对象(可以是标量或者矩阵)<code>a</code>和<code>b</code>相加，并返回结果<code>c</code>为例。</p>
<p>图a表示的是driver程序调用$add.remote(a, b)$的具体步骤，其中<code>a</code>和<code>b</code>分别存储在节点<code>N1</code>和<code>N2</code>。</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/20.png" style="zoom:50%;" /></p>
<ol>
<li>remote函数$add()$在初始化时自动注册到GCS，并分发给系统中的每个worker。</li>
<li>driver程序将$add(a,b)$提交给<code>N1</code>的本地调度器。</li>
<li><code>N1</code>的本地调度器在发现输入<code>b</code>不在本地，不满足运行条件，便将$add(a,b)$转发给全局调度器。</li>
<li>全局调度器在GCS中查找$add(a,b)$的参数位置。</li>
<li>全局调度器决定在存储参数<code>b</code>的<code>N2</code>上运行$add(a,b)$。</li>
<li><code>N2</code>的本地调度器检查本地的对象存储是否包含$add(a,b)$的参数。</li>
<li>由于<code>N2</code>的本地存储没有对象<code>a</code>，且全局调度器已经指定由其完成该task，于是它在GCS中查找对象<code>a</code>的位置。</li>
<li><code>N2</code>得知对象<code>a</code>存储在<code>N1</code>，<code>N2</code>的对象存储在本地复制<code>N1</code>中的对象<code>a</code>。</li>
<li>现在$add()$的所有参数都存储在<code>N2</code>本地，<code>N2</code>的本地调度器在本地worker处调用$add()$。</li>
<li>$add()$通过共享内存访问参数。</li>
</ol>
<p>图b表示的是在<code>N1</code>执行$ray.get()$获得在<code>N2</code>执行的$add()$所返回值的具体步骤：</p>
<p><img src="https://raw.githubusercontent.com/zjn-astonishe/image/refs/heads/main/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/21.png" style="zoom:50%;" /></p>
<ol>
<li><code>N1</code>调用$ray.get(id_c)$时，driver程序使用$add()$返回的<code>future</code>检查本地对象存储中的值<code>c</code>。</li>
<li>由于<code>N1</code>本地对象存储没有存储<code>c</code>，<code>N1</code>在GCS中查找<code>c</code>的位置。此时GCS中并没有<code>c</code>的条目，因为<code>c</code>还未被创建。因此<code>N1</code>的对象存储空间向GCS中的对象表注册一个回调，该回调在<code>c</code>的条目被创建时触发。</li>
<li>当<code>N2</code>中的worker执行完$add()$后，将结果<code>c</code>存储在<code>N2</code>的本地对象存储中。</li>
<li><code>N2</code>的本地存储将对象<code>c</code>的条目添加到GCS中。</li>
<li>GCS创建对象<code>c</code>的条目，并由此触发了<code>N1</code>的对象存储所注册的回调。</li>
<li><code>N1</code>的本地存储从<code>N2</code>的本地存储复制对象<code>c</code>。</li>
<li><code>N1</code>本地存储将对象<code>c</code>返回到$ray.get()$，完成了task。</li>
</ol>
<div style="page-break-after: always;"></div>

<h2 id="Advantages-and-Disadvantages"><a href="#Advantages-and-Disadvantages" class="headerlink" title="Advantages and Disadvantages"></a>Advantages and Disadvantages</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul>
<li>Ray设计和构建了第一个联合了训练、模拟和服务的分布式框架，能够满足新型人工智能应用对框架的各种需求。<ul>
<li>Ray在只考虑训练、模拟或服务的单独场景中拥有接近甚至超过专门系统的性能表现。</li>
<li>在Ray上实现的需要训练、模拟和服务紧密耦合的强化学习算法在性能上接近甚至超过专门为该算法设计的系统。</li>
</ul>
</li>
<li>Ray在单个动态任务图中统一了task parallel和actor programming models，采用了由全局控制存储GCS和自下而上的分布式调度器构成的架构，使得：<ul>
<li>Ray允许开发者用task对模拟actor产生的输出进行昂贵的后续处理，且Ray能够通过60个节点每秒完成100万个task，意味着可以实现Billion级别的大规模仿真。</li>
<li>Ray的GCS和分布式调度器能够水平扩展系统以支持高吞吐量的细粒度任务，同时保持容错性和低延迟任务调度。</li>
</ul>
</li>
<li>Ray非常的灵活，并没有绑定成某一种特定应用场景或计算模式的解决方案，是一个真正的原生分布式框架。<ul>
<li>在上层抽象出不同的计算模式，包括流处理、批处理、图计算、机器学习、深度学习、强化学习等。但Ray本身不提供具体计算的功能，可结合TensorFLow或者Pytorch计算框架使用。</li>
<li>在下层提供分布式服务，解决调度问题、容错问题、资源恢复问题等。通过简单的硬件资源参数设置，就能让计算运行在不同的异构硬件上。</li>
</ul>
</li>
<li>Ray的API简单高效，使得编程模式非常友好。能非常容易实现先进的RL算法。</li>
</ul>
<h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ul>
<li>Ray的task是无副作用的，而对于GPU，开发者并不只想用来运行任务、获取数据和存储数据，希望能够把状态实际保留在GPU上，导致任务不能保持无副作用，令提供容错能力变得困难。</li>
<li>Ray的actor只适用于顺序性的单独线程，在使用多线程的情况下难以提供容错性。</li>
<li>Ray缺少系统隔离能力，一个有害的actor实现可以轻易独占当前的CPU资源。</li>
<li>由于Ray的分布式节点上会有不止一个线程，需要频繁进行切换，其调度和上下文切换的开销会比理论上的结果更大。表现在当任务较多时，容易卡死。</li>
<li>Ray要在不完全了解计算图的情况下做出调度决策、优化可能需要更复杂的运行时分析。</li>
<li>Ray使用对象(object)的作用域来管理对象的生命周期，这意味着没有作用域的对象将会有无限的生命周期。Ray缺乏垃圾回收策略，无法约束GCS中的存储成本。使得在数据密集时容易出现严重的数据膨胀。</li>
<li>深度学习框架像对待数据计算一样重视且全权管理数据搬运，不能把数据搬运委托给更底层的机制以至于数据搬运隐式地在背后发生，这会丧失宝贵的确定性和可预测性，深度学习要求必须把数据搬运像计算一样作为算子显式的调度管理。但Ray通过对象存储和RPC机制实现了一套“自动”的数据搬运机制，反而可能会帮倒忙。</li>
<li>Ray主要使用gRPC通信，手段较为单一，缺乏集群通信等的支持。通信功能有待增强。</li>
<li>Ray的API和功能不够丰富，需要更高级别的为调度决策提供信息的原语和库。</li>
<li>Ray是基于Python实现的，Python主要的应用场景在数据科学(数据分析/AI/科学计算)和运维两个领域。企业应用主要还是使用Java，所以Ray好像很少有企业应用的案例。因此从市场前景的角度，Ray还离通用框架有一定距离。</li>
</ul>
<div style="page-break-after: always;"></div>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>通过对本文的学习，主要有以下收获：</p>
<ul>
<li>对新一代的分布式强化学习框架Ray有了大致的了解。</li>
<li>分布式系统中如果丢失了一些数据，可以根据保留的最初创建该数据的任务链恢复数据。如果任务(task)是无副作用且确定性的，那么重新执行将获得同样的输出。依此可以实现容错性模型。</li>
<li>集中控制状态将是未来分布式系统的一个关键设计组件。它既能简化边缘端设备的程序设计，又方便对各个边缘设备进行监控调试，在边缘节点故障时能通过集中控制状态组件迅速恢复。</li>
<li>通过将调度器划分为全局和本地两层，并将全局调度器与数据存储解耦，能够最大限度减少任务调度的开销。</li>
<li>分布式系统中的组件也可以是分布式的，这使得系统具有非常强大的扩展性。</li>
<li>复杂的算法能通过简单的API实现。</li>
<li>对开源的第三方著名项目要保持继承发扬的态度，既不应抗拒，也不应依赖。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1712.05889v2">Ray: A Distributed Framework for Emerging AI Applications</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU5ODY2MTk3Nw==&amp;mid=2247486546&amp;idx=1&amp;sn=1f9578739d434f30afc2e90556685004&amp;chksm=fe418264c9360b72b75ceddcd1c413493c9dec3061fcaddab41e82db5363676580c7c39f5b05&amp;scene=21#wechat_redirect">Ion Stoica：做成Spark和Ray两个明星项目的秘笈</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/566982400">《Ray: A Distributed Framework for Emerging AI Applications》论文解读</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/446818362">Ray解读：从论文看架构</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86658441">Ray: A Distributed Framework for Emerging AI App 笔记</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/681561996">Ray: A Distributed Framework for Emerging AI Applications 阅读笔记</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/507619560">Ray: A Distributed Framework for Emerging AI Applications 学习笔记</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61818897">分布式框架Ray及RLlib简易理解</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/265485941">如何看UCBerkeley RISELab即将问世的Ray，replacement of Spark？</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/498342150">解读谷歌 Pathways 架构（二）：向前一步是 OneFlow</a></p>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/25/%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2024-10-25-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E5%8F%8A%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全局状态及快照算法</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Sia/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sia</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2024-10-27-Sia/" title="Sia"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="title">Sia</div></div></a></div><div><a href="/2025/06/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-09-Agentic%20Workflow/" title="Agentic Workflow"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-09</div><div class="title">Agentic Workflow</div></div></a></div><div><a href="/2025/07/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-07-08-Dynamic%20Early%20Exit/" title="Dynamic Early Exit"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-08</div><div class="title">Dynamic Early Exit</div></div></a></div><div><a href="/2025/06/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-30-LLM%20Agent%20Memory/" title="LLM Agent Memory"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="title">LLM Agent Memory</div></div></a></div><div><a href="/2025/06/29/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2025-06-29-LLM%20Agent%20Serving/" title="LLM Agent Serving"><img class="cover" src="https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-29</div><div class="title">LLM Agent Serving</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZJN</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjn-astonishe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-rss card_icon"></i></a><a class="social-icon" href="https://github.com/zjn-astonishe" target="_blank" title="Github"><i class="iconfont icon-github crad_icon"></i></a><a class="social-icon" href="https://gitee.com/zhang-jianning/" target="_blank" title="Gitee"><i class="iconfont icon-gitee2 card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=627561610&amp;website=www.oicqzone.com" target="_blank" title=""><i class="iconfont icon-QQ-circle-fill card_icon"></i></a><a class="social-icon" href="mailto:627561610@qq.com" target="_blank" title="Email"><i class="iconfont icon-email-fill card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8ARay-A-Distributed-Framework-for-Emerging-AI-Applications%E3%80%8B-Review"><span class="toc-text">《Ray: A Distributed Framework for Emerging AI Applications》 Review</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Background"><span class="toc-text">Background</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Requirements"><span class="toc-text">Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deficiencies"><span class="toc-text">Deficiencies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content"><span class="toc-text">Content</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Programming-and-Computation-Model"><span class="toc-text">Programming and Computation Model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Programming-Model"><span class="toc-text">Programming Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Computation-Model"><span class="toc-text">Computation Model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Architecture"><span class="toc-text">Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-Layer"><span class="toc-text">Application Layer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Layer"><span class="toc-text">System Layer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Running"><span class="toc-text">Running</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Advantages-and-Disadvantages"><span class="toc-text">Advantages and Disadvantages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Advantages"><span class="toc-text">Advantages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disadvantages"><span class="toc-text">Disadvantages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-21_Exploration_and_Discovery/" title="21_Exploration_and_Discovery">21_Exploration_and_Discovery</a><time datetime="2025-09-14T05:24:13.000Z" title="发表于 2025-09-14 13:24:13">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-20_Prioritization/" title="20_Prioritization">20_Prioritization</a><time datetime="2025-09-14T05:23:46.000Z" title="发表于 2025-09-14 13:23:46">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-19_Evaluation_and_Monitoring/" title="19_Evaluation_and_Monitoring">19_Evaluation_and_Monitoring</a><time datetime="2025-09-14T05:23:25.000Z" title="发表于 2025-09-14 13:23:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-18_Guardrails_Safety_Patterns/" title="18_Guardrails_Safety_Patterns">18_Guardrails_Safety_Patterns</a><time datetime="2025-09-14T05:23:02.000Z" title="发表于 2025-09-14 13:23:02">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/Agent/2025-09-14-17_Reasoning_Techniques/" title="17_Reasoning_Techniques">17_Reasoning_Techniques</a><time datetime="2025-09-14T05:22:31.000Z" title="发表于 2025-09-14 13:22:31">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.3.0/picture/7.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By ZJN</div><div class="footer_custom_text">Hi, welcome to my <a href="https://zjn-astonishe.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><div class="aplayer no-destroy" data-id="7307479551" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="auto" data-autoplay="true" data-volume=0.2></div><div class="Canvas" style="position:fixed; right:0px; bottom:0px;" id="L2dCanvas"></div><script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script><script src="https://cdn.jsdelivr.net/gh/zjn-astonishe/CDN@1.2.9/live2dv3.min.js"></script><script>window.onload=()=>{new l2dViewer({width:window.screen.width / 18,height:window.screen.height / 7.5,el:document.getElementById('L2dCanvas'),basePath:'https://cdn.jsdelivr.net/gh/zjn-astonishe/cdn@1.2',modelName:'lafei_4',mobileLimit:true,sizeLimit:true })}</script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>